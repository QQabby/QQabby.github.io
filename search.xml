<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Service 启动过程]]></title>
    <url>%2F2018%2F09%2F11%2FService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[看完 Activity 的启动过程，发现 Service 的启动过程相对来说就比较简单了。 要说起启动过程，就得从 startService 开始： 1.startService根据源码的跳转，发现跳转到 ContextWrapper 这个类中，代码如下：1234@Override public ComponentName startService(Intent service) &#123; return mBase.startService(service); &#125; 其中 mBase 是类型是：Context 类型，如下：1234public class ContextWrapper extends Context &#123; Context mBase; ......&#125; 而我们又知道 Context 是一个抽象类 ，实现者是 ContextImpl ,所以我们应该是查看ContextImpl 这个类中的 startService(service) 方法。 ContextImpl 中的方法定义如下：12345@Override public ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser); &#125; 在 startService 中又调用了 startServiceCommon(service,(requirForeground:false),mUser) 这个方法，继续跟进： 2.startServiceCommonstartServiceCommon 方法如下：1234567891011121314151617181920212223242526272829private ComponentName startServiceCommon(Intent service, boolean requireForeground, UserHandle user) &#123; try &#123; //校验要启动的service validateServiceIntent(service); service.prepareToLeaveProcess(this); ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(&quot;!&quot;)) &#123; throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123; throw new SecurityException( &quot;Unable to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123; throw new IllegalStateException( &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 这里面有几个需要说明一下： ActivityManager.getService() 点进去查看12345678910111213141516/** * @hide */ public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 首先是返回的类型是 IActivityManager 类型，其中在create 方法中，拿到远程服务的Binder 对象，其中IActivityManager.Stub.asInterface(b) 不知道大家有没有想起AIDL 这就很熟悉了，就是拿到远程服务的代理对象：IActivityManager,通过代理对象调用远程的方法，是应用进程与服务进程通信的媒介，如果没猜错的话就是在ActivityManagerService 中实现了，查看ActivityManagerService 类：1234public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;.....&#125; 果然不出所料，AMS extend IActivityManager.Stub . mMainThread.getApplicationThread() 首先明白 mMainThread 是 ActivityThread 类的实例变量，通过getApplicationThread() 方法拿到一个 ApplicationThread 类的实例：1234public ApplicationThread getApplicationThread() &#123; return mAppThread; &#125; 而ApplicationThread 类定义如下：123private class ApplicationThread extends IApplicationThread.Stub &#123;.....&#125; 发现 ApplicationThread 是 ActivityThread 的一个内部类.并且实现了 IApplicationThread.Stub ,而我们又把这个类型传入给了AMS,相当于远程服务拿到了一个访问应用进程的代理，类型为：IApplicationThread 总结：到目前为止，客户端拿到了远程服务的代理（IActivityManager）, 服务端拿到了客户端的代理（IApplicationThread）,它们互相拿到各自进程的代理类，是它们进行进程间通信的基础。 ok ,我们回到最初那个地方：1234ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); 通过前面的分析我们知道：ActivityManager.getService(). 实际就是 AMS 远程代理，最终在AMS 中完成，我们去 AMS 代码中查看下 startService 代码： 3.ActivityManagerService. startService1234567891011121314151617181920212223242526272829303132@Override public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(&quot;startService&quot;); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;); &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res; try &#123; // 又调用了startServiceLocked 方法 res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return res; &#125; &#125; startServiceLocked 方法很复杂，大概如下：1234567891011ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId) throws TransactionTooLargeException &#123;.....ServiceRecord r = res.record;//启动service的信息保存在 serviceRecord 中.... ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); return cmp;.....&#125; 内部又调用了：startServiceInnerLocked 方法 4.startServiceInnerLocked如下：123456ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;... String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);...&#125; 又调用： bringUpServiceLocked 5.bringUpServiceLocked1234567 private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123;....realStartServiceLocked(r, app, execInFg);&#125; 而后又调用了 realStartServiceLocked(r, app, execInFg); 6.realStartServiceLocked12345678private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; .... app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); ....&#125; 其中 app.thread 是 IApplicationThread 类型，就是远程调用客户端进程里的方法，scheduleCreateService ,而我们又知道 ApplicationThread 实现了 IApplicationThread，所以就查看 ApplicationThread 类中的 scheduleCreateService方法，前面我们说过ApplicationThread 是 ActivityThread 的一个内部类，查看： 7.ApplicationThread.scheduleCreateService12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s); &#125; 发现内部通过发送一个 CREATE_SERVICE 的消息，H 是 Handle,继续查看：handleMessage 方法 12345case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; 到 handleCreateService 中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name); //创建context ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); //创建Application Application app = packageInfo.makeApplication(false, mInstrumentation); //通过attach 方法，将context application ，service 连接起来 service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); //调用service oncreate方法 service.onCreate(); mServices.put(data.token, service); try &#123; ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to create service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125; service.onCreate(); ok ，调用了 onCreate 方法，至此，service的启动过程的就完成了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[TransitionDrawable]]></title>
    <url>%2F2018%2F08%2F16%2FTransitionDrawable%2F</url>
    <content type="text"><![CDATA[1.首先创建一个xml 在 drawable 目录下 transition_image 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/first" /&gt; &lt;item android:drawable="@drawable/two" /&gt;&lt;/transition&gt; 2.在xml中引用 1android:drawable="@drawable/transition_image" 3.在Activity中使用 123ImageView mImageView = (ImageView) findViewById(R.id.iv); TransitionDrawable transitionDrawable = (TransitionDrawable) mImageView.getDrawable(); transitionDrawable.startTransition(3000) 另外一种写法实现多张图片效果123TransitionDrawable transitionDrawable = new TransitionDrawable(new Drawable[]&#123;getResources().getDrawable(R.drawable.first),getResources().getDrawable(R.drawable.two)&#125;);mImageView.setImageDrawable(transitionDrawable);transitionDrawable.startTransition(3000);]]></content>
      <tags>
        <tag>两个Drawable之间淡入淡出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的爬坑之路]]></title>
    <url>%2F2018%2F07%2F05%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[近期由于项目需要，需要编写小程序，遇到一些问题，记录下来，也是给自己开发的一个总结。 1.关于模板 template在看完 官方文档 里的说明之后，我并没有成功使用，按照它那个设置完成后，一直说找不到，最后在知道，原来除了实例那些之外，还要在当前 wxml 中 import 进来。 1.先建一个 template 的文件夹，新建 wxml,根据具体的路径引入进来，例如：1&lt;import src=&quot;../template/line.wxml&quot; /&gt; 还有一个就是如果有相对应的 wxss文件，可在 app.wxss文件中引用，这样整个项目都不需要引用这个样式文件了。 注意：模板拥有自己的作用域，只能使用 data 传入的数据以及模版定义文件中定义的 模块。 2. 关于水平居中，垂直居中一开始感觉这啥玩意，不听话啊，让居中也不居中，就是不动啊，很是郁闷，后来发现了一些规律。 2.1 水平居中 首先如果是行内元素，例如 这样的，如果想水平居中，使用text-align:center 你会发现不好使啊，纹丝不动，原因是因为行内元素长度随内容变化，所以它不能让你在一行的中间，因为它的长度就是文字长度。 解决方案：可以换成view 控件，或者使用：display:block + text-align:center 其它元素可以使用123456======3个一起使用==========text-align:center;align-items:center;justify-content: center;==================margin:auto # 子容器在父容器中居中,单独使用 2.2 垂直居中1234//可使用如下display:flex;align-items:center;justify-content:center; 3.关于几个控件平分整个屏幕宽度问题 一开始我还想着获取屏幕的宽和高，然后再动态给控件设置具体的值，后来发现有更简单的做法 例如：像这样一行排四个 解决方案：设置控件的宽度为 ：25%，这样就自动平分啦。当然还有其它的方式，但是我认为百分比的这种写法感觉很直观。 4. flex 布局熟练掌握 flexbox 布局，可以更轻松的编写任何常见的布局，可以查看相关专业的文章。 未完待续…..]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-可观察属性]]></title>
    <url>%2F2018%2F06%2F27%2FKotlin-%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[类似于观察者模式，当所监测的对象发生改变时，能够收到回调通知。 例如：我们监测一个变量：123456789var str: String by Delegates.observable("qianqian",&#123; property: KProperty&lt;*&gt;, oldValue: String, newValue: String -&gt; Log.i("xx","改变的属性名称：$&#123;property.name&#125; --- $&#123;oldValue&#125; -- $&#123;newValue&#125;" ) &#125;) //点击一个按钮，改变str的值 fun foo(view : View)&#123; str = "haha" &#125; 这时候我们会发现，当改变str 的值的时候，会打印信息，也就是收到回调：1改变的属性名称：str --- qianqian -- haha 再比如：检测对象里的其中一个属性：1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable("&lt;no name&gt;") &#123; prop, old, new -&gt; println("$old -&gt; $new") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "first" user.name = "second"&#125; 打印信息：12&lt;no name&gt; -&gt; firstfirst -&gt; second]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin let with run also apply区分]]></title>
    <url>%2F2018%2F04%2F28%2FKotlin-let-with-run-also-apply%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取手机屏幕的密度]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AF%86%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[目前有两种方式，一种是根据手机的分辨率计算，另外一种是通过代码获取。 第一种：根据手机分辨率进行计算(计算得出实际的dpi)比如我的手机魅族分辨率是：1920*1080，屏幕尺寸大小是：5.5寸的，那么计算：(宽的平方+高的平方之后开根号，最后除以屏幕的尺寸)dpi = (√1920^2+1080^2 ) / 5.5 ≈ 401 参照下图： ldpi（低）~120dpi density=0.75 mdpi（中）~160dpi density=1 hdpi（高）~240dpi density=1.5 xhdpi（超高）~320dpi density=2 xxhdpi（超超高）~480dpi density=3 xxxhdpi（超超超高）~640dpi density=4 对应图片的目录应该是：xxhdpi 第二种：通过代码方式(系统定义的dpi)12float xdpi = getResources().getDisplayMetrics().xdpi;float ydpi = getResources().getDisplayMetrics().ydpi; 不同手机获取的xdpi ydpi 值有的一模一样，有的有些差异，但是相差不会太大，两者获取的值近乎一样。 两者计算出的结果并不完全相同，因为你们想，实际计算得出的dpi 很容易根据屏幕尺寸的不同，得出不同的dpi ，这样的话得到的值很多，无法适配。我查阅网上相关介绍，就是每个手机初始有一个固定的dpi ，分别是上述的：120，160，240，320，480，640，安卓实际进行缩放的时候按照的是系统定义的这些，而不是实际计算得出的dpi,这一点需要注意。]]></content>
      <tags>
        <tag>dpi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus 为什么订阅的方法必须是public？]]></title>
    <url>%2F2018%2F04%2F08%2FEventBus-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A2%E9%98%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在看了源码之后发现是这样的：12345678910111213141516171819202122232425262728293031323334353637383940private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities //获取所有声明的方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; //获取方法的标识符 int modifiers = method.getModifiers(); //方法的标识符必须是public if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; //否则抛出异常 ，说这个方法必须加上@Subscribe ,并且是public 的，不能是静态的，抽象的 String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125; &#125; 然后就没有然后了，之前怀疑private 修饰的方法，反射后不能被其他类调用，后来查了相关资料，发现可以，后来去网上寻找无果，后来在我微信关注的公众号里，群主伯特说：虽然可以反射调用private 的方法，但是必须通过setAccess来修改访问权限。说是修改，实则破坏了java中的作用域，迫不得已不推荐这么做。EventBus 作为三方库，显然不会在你设置为private 时，好心办坏事，强制访问。 仅此而已，仅此而已。分享给还不知道的童鞋。]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity状态保存与恢复]]></title>
    <url>%2F2018%2F03%2F23%2FActivity%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Activity状态保存与恢复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件是什么与它们的生命周期（及Fragment）]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%8F%8AFragment%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先当我们一开始学习安卓的时候想必就是四大组件了以及它们的生命周期，现在就来复习回想下。 四大组件有：Activity, ContentProvider, BroadcastReceiver, Service Activity 提供与用户交互的界面或者可以说是一个窗口 下面我是从官方文档中关于Activity生命周期 的一张图 正常启动时：onCreate() -&gt; onStart() -&gt; onResume() 而后我们看到当 Another activity comes into the foreground 执行 onPause() 方法当按 home 键的时候： 当前Activity 已经不可见了，所以执行：onPause() -&gt; onStop() 当重新回到app时，分为两种情况就是：①是app还在后台，执行：onRestart() -&gt; onStart() -&gt; onResume(); ②是app被系统杀死了，则执行：onCreate() -&gt; onStart() &gt; onResume() 当在app 里 从 A -&gt; B 此时A隐藏，B显示，当重新返回A 时，执行：onPause() -&gt; onResume(),这种应用场景一般是比如需要返回做刷新操作的，可以将刷新方法写在onResume() 方法中执行。 最后当退出应用程序的时候执行 onDestroy() Service 服务，有前台服务和后台服务，一般提供需在后台长期运行的服务，例如：音乐播放器等 它的生命周期如下图： 因为启动服务的方法有两个：startService() 和 bindService() 两者的生命周期略有不同。 首先来看：startService() 方式启动：onCreate() -&gt; onStartCommand() 调用stopServcie() 停止服务，随后执行 onDestroy() 其次是：bindService() 方式启动：onCreate() -&gt; onBind() 服务启动起来了，调用unbindService() 停止服务，随后执行 onUnbind() -&gt; onDestroy() Broadcastreceiver 广播，可以接受来自应用内或者应用外的广播，分为两个角色：广播发送者，广播接收者 广播的注册方式有两种：一种是代码注册，一种是清单文件注册，代码注册的优先级要比清单文件注册的优先级要高； 广播的发送可以是有序广播也可以是无序广播，有序广播接收到广播的顺序按照优先级的顺序； 注意广播接收器onReceive() 方法运行在 UI 线程中，不可以做耗时操作，否则会导致ANR异常； ContentProvider 内容提供者，应用内数据共享 Fragment 一般和 viewpager 配合使用，不能单独使用，要配合Activity使用，但是有自己的生命周期 一般在onAttach()中获取参数值一些，onCreateView()中创建布局，布局加载完成后在onActivityCreated()中执行一些初始化操作，随后onStart(),onResume().onPause(),onStop(), fragment 销毁，onDestroyView() -&gt; onDestroy() -&gt;onDetach()]]></content>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点总结]]></title>
    <url>%2F2018%2F03%2F22%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[网上别人列出一些来，我把它拿过来了，需要自己一项一项复习查阅，以后有会继续添加新的，特此总结。 四大组件是什么与它们的生命周期（及Fragment）; Acitivty的四种启动模式与特点。 获取手机屏幕的密度 Activity状态保存与恢复。 Service的生命周期，启动方法，有什么区别。 service和activity怎么进行数据交互。 怎么保证service不被杀死。 广播使用的方式和场景以及广播的几种分类。 Intent的使用方法，可以传递哪些数据类型。 ContentProvider使用方法。 ContentProvider、ContentResolver、ContentObserver 之间的关系。 Thread、AsycTask、IntentService的使用场景与特点。 FrameLayout 、 LinearLayout 、 RelativeLayout 各自特点及绘制效率对比。 Android的数据存储形式。 Android两种序列化的区别和作用。 Sqlite的基本操作。 Android中的MVC、MVP模式。 Merge、ViewStub的作用。 动画有哪几类，各有什么特点？ Handler、Loop消息队列模型，各部分的作用。 Android的消息机制，子线程更新UI的方法和原理。 Android怎么加速启动Activity。 App的启动过程。 Android优化方法。 如何防止内存泄漏？ Android中弱引用与软引用的应用场景。 Bitmap的四种属性，如何加载大图（inJustDecodeBounds）。 View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。 View刷新机制和绘制流程。 Activity、Window、View的联系和理解。 invalidate和requestLayout的区别及使用。 Touch事件分发机制和冲突处理。 Android IPC:Binder原理。 Android5.0（UI库）、6.0（权限）、7.0特性、8.0特性。]]></content>
      <tags>
        <tag>Android知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 传递数据]]></title>
    <url>%2F2018%2F03%2F14%2FKotlin-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[今天在掘金看到使用 Kotlin 高阶函数传递Intent 数据很简洁，觉着可以试试，并应用到项目中去，自己再加以理解，记录笔记，方便查阅。掘金原文章地址：https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw 传统的Intent 数据传递我就不介绍了，只介绍Kotlin实现方式：123456789101112131415161718192021//目标 假设叫`KTestActivity4` 定义 object IntentOptions&#123; private const val MSG_KEY = "key for message" var Intent.message: String? get() = getStringExtra(MSG_KEY) set(message) &#123; putExtra(MSG_KEY,message) &#125; &#125;//跳转时 with(KTestActivity4.IntentOptions)&#123; intent = Intent(this@KTestActivity5,KTestActivity4::class.java) intent.message = "I am KTestActivity5" startActivity(intent) &#125;//使用with(IntentOptions)&#123; var message= intent.message Toast.makeText(this@KTestActivity4,"显示信息："+message,Toast.LENGTH_SHORT).show() &#125; 假设有多个数据传递：1234567891011121314151617181920212223object IntentOptions&#123; private const val MSG_KEY = "key for message" private const val MSG_ID = "ID for message" var Intent.message: String? get() = getStringExtra(MSG_KEY) set(message) &#123; putExtra(MSG_KEY,message) &#125; // 再多增加一条即可 var Intent.id: String? get() = getStringExtra(MSG_ID) set(id) &#123; putExtra(MSG_ID,id) &#125; &#125;// 传递时with(KTestActivity4.IntentOptions)&#123; intent = Intent(this@KTestActivity5,KTestActivity4::class.java) intent.message = "I am KTestActivity5" intent.id = "I am id" startActivity(intent) &#125; 还有另外一种传递方式：委托机制，不是特别明白。国外大神封装的github地址：https://github.com/Takhion/android-extras-delegates]]></content>
      <tags>
        <tag>Kotlin#Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴Android开发手册]]></title>
    <url>%2F2018%2F03%2F13%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Android%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[摘自阿里巴巴Android开发手册 强制要求的 1. Activity 间的数据通信，对于数据量比较大的，避免使用 intent + Parcelable 的方式，可以考虑 EventBus等替代方案，以免造成 TransationTooLargeException 2. Activity 间通过隐士 Intent的跳转，在发出 Intent 之前必须通过 resolveActivity 检查，避免找不到合适的调用组件，造成 ActivityNotFoundException 的异常。 12345678910 public void viewUrl(String url, String mimeType) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(Uri.parse(url), mimeType); if (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; startActivity(intent); &#125;else &#123; // 找不到指定的 Activity &#125;&#125; 而不应该：1234567Intent intent = new Intent();intent.setAction("com.example.DemoIntent ");try &#123; startActivity(intent);&#125; catch (ActivityNotFoundException e) &#123; e.printStackTrace();&#125; 3. 避免在Service#onStartCommand/onBind()方法中执行耗时操作，如果确实有需求，应采用IntentService 或采用其他异步机制完成。正例： 12345678910111213141516171819202122232425public class MainActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; public void startIntentService(View source) &#123; Intent intent = new Intent(this, MyIntentService.class); startService(intent); &#125;&#125;public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService"); &#125; @Override protected void onHandleIntent(Intent intent) &#123; synchronized (this) &#123; try &#123;...... &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; 4. 避免在 BroadcastReceive#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService完成，而不应该在BroadcastReceiver 内创建子线程去做。 说明：由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅，可以使用 IntentService,创建 HanlderThread 或者调用 Context#registerReceiver(BroadcastReceiver,IntentFitter,String,Handler) 方法等方式，在其他 Worker 线程执行 onReceive.BroadcastReceiver#onReceive() 方法耗时超过10秒钟，可能会被系统杀死。正例： 1234567891011IntentFilter filter = new IntentFilter();filter.addAction(LOGIN_SUCCESS);this.registerReceiver(mBroadcastReceiver, filter);mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; Intent userHomeIntent = new Intent(); userHomeIntent.setClass(this, UserHomeService.class); this.startService(userHomeIntent); &#125;&#125;; 反例：123456789mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; MyDatabaseHelper myDB = new MyDatabaseHelper(context); myDB.initData(); // have more database operation here &#125;&#125;; 5. 避免使用隐士 Intent 广播敏感信息，信息可能被其他注册了对应 BroadcastReceiver 的App接收。 说明：通过Context#sendBroadcast()发送的隐士广播会被感兴趣的 receiver 接收，恶意应用注册监听该广播的 receiver可能会获取到 Intent 中传递的敏感信息，并进行其他危险操作。如果发送的广播为使用 Context#sendOrderedBroadcast()方法发送的有序广播，优先级较高的恶意 receiver可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。 如果广播仅限于应用内，则可以是iyongLocalBroadcastManager#sendBroadcast()实现，避免敏感信息外泄和intent拦截的风险。 正例：123Intent intent = new Intent("my-sensitive-event");intent.putExtra("event", "this is a test event");LocalBroadcastManager.getInstance(this).sendBroadcast(intent); 反例：1234567891011Intent intent = new Intent();v1.setAction("com.sample.action.server_running");v1.putExtra("local_ip", v0.h);v1.putExtra("port", v0.i);v1.putExtra("code", v0.g);v1.putExtra("connected", v0.s);v1.putExtra("pwd_predefined", v0.r);if (!TextUtils.isEmpty(v0.t)) &#123; v1.putExtra("connected_usr", v0.t);&#125;context.sendBroadcast(v1); 以上广播可能被其他应用的如下 receiver 接收导致敏感信息泄露：12345678910111213final class MyReceiver extends BroadcastReceiver &#123; public final void onReceive(Context context, Intent intent) &#123; if (intent != null &amp;&amp; intent.getAction() != null) &#123; String s = intent.getAction(); if (s.equals("com.sample.action.server_running") &#123; String ip = intent.getStringExtra("local_ip"); String pwd = intent.getStringExtra("code"); String port = intent.getIntExtra("port", 8888); boolean status = intent.getBooleanExtra("connected", false); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>阿里巴巴Android开发手册规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听键盘显示与隐藏]]></title>
    <url>%2F2018%2F03%2F08%2F%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[项目中有时候需要监听keyboard的显示与隐藏，特此备注，方便使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class KeyboardWatcher &#123; private ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener; private View rootView; private int viewSize = -1; private boolean isShowing = false; private OnKeyboardListener onKeyboardListener; public KeyboardWatcher(Activity activity)&#123; rootView = activity.getWindow().getDecorView().getRootView(); &#125; public KeyboardWatcher register(OnKeyboardListener listener)&#123; onKeyboardListener = listener; if(onGlobalLayoutListener == null) &#123; onGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect r = new Rect(); rootView.getWindowVisibleDisplayFrame(r); int viewHeight = r.bottom - r.top; if(viewSize &lt; 0)&#123; viewSize = viewHeight; return; &#125; if(viewHeight != viewSize)&#123; // 大于100dp才算变化 if(Math.abs(viewHeight - viewSize) &gt; dpToPx(rootView.getContext(),100)) &#123; if (viewHeight &lt; viewSize &amp;&amp; !isShowing) &#123; onKeyboardListener.onShow(viewHeight); isShowing = true; &#125; else if(isShowing)&#123; onKeyboardListener.onHide(); isShowing = false; &#125; &#125; viewSize = viewHeight; &#125; &#125; &#125;; &#125; rootView.post(new Runnable() &#123; @Override public void run() &#123; viewSize = rootView.getHeight(); rootView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener); &#125; &#125;); return this; &#125; public void unRegister()&#123; rootView.getViewTreeObserver().removeGlobalOnLayoutListener(onGlobalLayoutListener); rootView = null; &#125; public interface OnKeyboardListener&#123; void onShow(int viewSize); void onHide(); &#125; private int dpToPx(Context context,int dp) &#123; return (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, dp, context.getResources().getDisplayMetrics() ); &#125;&#125; 使用方法1234KeyBoardWatcher keyboardWatcher = new KeyboardWatcher()keyboardWatcher.register(this)//实现KeyboardWatcher.OnKeyboardListener接口//实现方法onShow() , onHide(),对应键盘的显示与隐藏]]></content>
      <tags>
        <tag>keyboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment 懒加载]]></title>
    <url>%2F2018%2F02%2F28%2FFragment-%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[因为项目中经常用到tabLayout + viewpager 结合使用，页面切换时要用到延迟加载的情况，所以单独写出一个demo，方便查看和便于使用 1.首先新建一个BaseLazyFragment/** * Created by xuqianqian on 2018/2/28. */ public abstract class BaseLazyFragment extends Fragment { protected View mRootView; public Context mContext; protected boolean isVisible; private boolean isPrepared; private boolean isLoad = false; //最先执行 @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (getUserVisibleHint()) {//当前显示 isVisible = true; if(!isLoad){ lazyLoad(); } } else { isVisible = false; //onInvisible(); } } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mContext = getActivity(); setHasOptionsMenu(true); } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { if (mRootView == null) { mRootView = getLayout(); } return mRootView; } @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); isPrepared = true; //如果已经加载过了，就无需再重新加载 if(!isLoad){ lazyLoad(); } } /** * 懒加载 */ protected void lazyLoad() { if (!isPrepared || !isVisible) { return; } isLoad = true; initData(); } // protected void onInvisible() { // // } //初始化布局View public abstract View getLayout(); public abstract void initData(); } 2.让你的fragment extend BaseLazyFragmentpublic class GankFragment extends BaseLazyFragment { String type; public static GankFragment newInstance(String type) { GankFragment gankFragment = new GankFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;type&quot;, type); gankFragment.setArguments(bundle); return gankFragment; } //加载布局 @Override public View getLayout() { type = getArguments().getString(&quot;type&quot;); TextView tv = new TextView(getActivity()); tv.setText(type); tv.setGravity(Gravity.CENTER); return tv; } @Override public void initData() { //初始化一些控件，加载网络数据 } } 3.剩下的就是FragmentPagerAdapter了public class TitleAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragments; private List&lt;String&gt; types; public TitleAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments, List&lt;String&gt; types) { super(fm); this.fragments = fragments; this.types = types; } @Override public Fragment getItem(int position) { return fragments.get(position); } @Override public int getCount() { return fragments.size(); } @Override public CharSequence getPageTitle(int position) { return types.get(position); } } MainActivity.java private List&lt;String&gt; titles = new ArrayList&lt;&gt;(); private List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;(); TitleAdapter titleAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TabLayout tablayout = findViewById(R.id.tablayout); ViewPager viewpager = findViewById(R.id.viewpager); titles.add(&quot;android&quot;); titles.add(&quot;ios&quot;); titles.add(&quot;web&quot;); titles.add(&quot;java&quot;); fragments.add(GankFragment.newInstance(&quot;android&quot;)); fragments.add(GankFragment.newInstance(&quot;ios&quot;)); fragments.add(GankFragment.newInstance(&quot;web&quot;)); fragments.add(GankFragment.newInstance(&quot;java&quot;)); titleAdapter = new TitleAdapter(getSupportFragmentManager(), fragments, titles); viewpager.setAdapter(titleAdapter); tablayout.setTabMode(TabLayout.MODE_FIXED); tablayout.setupWithViewPager(viewpager); } https://github.com/QQabby/LazyFragmentApplication]]></content>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog]]></title>
    <url>%2F2018%2F02%2F28%2FDialog%2F</url>
    <content type="text"><![CDATA[快速初始化materialDialognew MaterialDialog.Builder(mContext) .title(&quot;title&quot;) .content(&quot;I&apos;m a content&quot;) .negativeText(&quot;cancel&quot;) .negativeColorRes(R.color.colorNegative) .positiveText(&quot;ok&quot;) .positiveColorRes(R.color.colorPositive) .onPositive(new MaterialDialog.SingleButtonCallback() { @Override public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) { showMsg(&quot;click dialog ok&quot;); ... } }) .show();]]></content>
      <tags>
        <tag>materialDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序速查笔记]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这个微信小程序也出来好长时间了，一直想做一个属于自己的小程序，这不说动手就动手实现一个吧，比较简易，中间也遇到不少问题，记录一下，方便以后自己查阅。 微信小程序的结构 默认没有这么些文件夹的，只有index ，然后这个标识 app 开头的文件都是一些全局的设置。可以自己查看下，都有注释，就从这个配置开始说。 修改启动页面默认启动页面是index页面，如果要修改，打开app.json配置文件，在顶部你会发现有一个pages的配置，如下： &quot;pages&quot;: [ &quot;pages/home/home&quot; 只需要将我们的想要显示的页面的路径写在 第一个 就可以成为启动页，特别注意路径一定要正确。 当然你会新建很多页面，所有的页面都必须写在这个里面，不然跳转的时候会找不到。 底部tab栏切换就是底部tab栏切换,同样还是在app.json 配置文件中修改如下： &quot;tabBar&quot;: { &quot;color&quot;: &quot;#333333&quot;, &quot;selectedColor&quot;: &quot;#2B91D8&quot;, &quot;backgroundColor&quot;: &quot;#eee&quot;, &quot;borderStyle&quot;: &quot;white&quot;, &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_home_nor.png&quot;, &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_home_pre.png&quot; }, { &quot;pagePath&quot;: &quot;pages/myCenter/myCenter&quot;, &quot;text&quot;: &quot;我的&quot;, &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_center_nor.png&quot;, &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_center_pre.png&quot; } ] }, 这里的 pagePath 就是页面的路径，text文字，iconPath图标，注意图片一定要带后缀，selectedIconPath点击态的图标，各自换成你自己的就行，问题不会太大。 加载中如下： 有标签可以直接显示这个,在wxml文件中编写： &lt;loading hidden=&quot;{{hidden}}&quot; bindchange=&quot;loadingChange&quot;&gt; 加载中... &lt;/loading&gt; 可以控制显示还是隐藏，在.js文件中可以控制： data: { hidden: false, } 可以在data 底下配置默认值，hidden: false 默认不显示，赋值的时候必须在这里面写： that.setData({ hidden: true }) 网络请求 wx.request({ //网络请求地址url url: &apos;https://xx&apos;, header: { // &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &apos;content-type&apos;: &apos;application/json&apos; // &apos;content-type&apos;: &apos;text/xml&apos; }, //请求头参数配置 data: { page: pageNo, timestamp: timeStamps }, method: &quot;POST&quot;, success: function (res) { //xmlstring2json 是我使用第三方xml转json的一个库 var xml2json = require(&apos;..//lib/xmlstring2json/dist/xml2json&apos;); var json = JSON.stringify(xml2json(res.data), null, 4); var jsonObject = xml2json(res.data); var jokeObject = jsonObject.root.joke //timestamp if(pageNo == 0){ timeStamps = jsonObject.root.timestamp.text } // console.log(&apos;json::&apos; + jsonObject.root.timestamp.text) // var data = new Array(); // for (var i = 0; i &lt; jokeObject.length;i++){ // var text = JSON.stringify(jokeObject[i].text).replace(&quot;#&quot;, &quot;&quot;) // //JSON.parse(text).text // var value = JSON.parse(text).text; // data.push(value) // } // console.log(&apos;data::：&apos; + jokeObject[0].text.text ); // var l = jokeObject; var l; if(pageNo == 0){ l = jokeObject }else{ var l = that.data.list; for (var i = 0; i &lt; jokeObject.length; i++) { l.push(jokeObject[i]) } } //页面绑定的数据赋值 that.setData({ list: l }) pageNo++ that.setData({ hidden: true }) }, fail : function(s){ wx.showModal({ title: &apos;提示&apos;, content: &apos;请求接口失败&apos; + JSON.stringify(s) }) } 要进行网络请求，首先测试阶段可以将开发工具里的： 最后一个选项勾选上，不校验…,同时管理员还需在后台配置网络请求的域名，两个缺一不可。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给TextView上的drawable上的图片添加动画？]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%A6%82%E4%BD%95%E7%BB%99TextView%E4%B8%8A%E7%9A%84drawableEnd%E7%AD%89%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[可能你遇到过这样的场景，就是在 xml 里，给TextView添加了一个drawableLeft或者drawableRight等，你想给这个图片添加一个动画，然而你会发现当你给这个TextView加动画吧并不是我们想要的，我们只想要那个图片做动画，文字不需要做任何动画，目前可以有两种做法。 第一种做法 也是比较通俗的方法，说这个drawable 单独弄成ImageView不就好了，在xml里新增一个ImageView 是吧，干嘛非要加在一个标签里面，要相信布局都是很强大的，肯定可以实现效果。 第二种做法 你说真的没办法，必须写在一个里面，也是有办法的，那就不能在xml里设置drawableLeft了，代码设置，如下： 123AnimationDrawable d = (AnimationDrawable) getResources().getDrawable(R.drawable.animation_draw); d.setBounds(0,0,d.getIntrinsicWidth(),d.getIntrinsicHeight()); messageText.setCompoundDrawables(d, null, null, null); 这个具体的动画在这个animation_draw里，如下： 12345678&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot; android:duration=&quot;500&quot; /&gt;&lt;/animation-list&gt; 这是一个帧动画，里面可以放很多的item,从而形成动画,碰到了这种情况记录下，方便以后查阅。]]></content>
      <tags>
        <tag>add animation to drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O 新特性 AutoSizing]]></title>
    <url>%2F2018%2F01%2F16%2FAndroid-O-%E6%96%B0%E7%89%B9%E6%80%A7-AutoSizing%2F</url>
    <content type="text"><![CDATA[自动调整TextView的大小的使用autoSizing Android 8.0允许根据TextView的大小自动设置文本展开或收缩的大小,这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。 在之前看 文字太多？控件太小？试试 TextView 的新特性 Autosizing 吧！ 作者写到关于这个属性的所有用法，在这里我就不多说什么了，用法其实挺简单，关键是我在用的时候遇到了一些小问题，导致一直出不来。 官方文档 点击即可查看，可以看别人讲解的同时也可自行查阅文档，双方对比着看，感觉会好一点。 如下图可以简单明了的说明该特性： 具体最简单的使用有两种： 1.一种就是api &gt;= api 26的可以直接在xml里面该属性：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; /&gt; 在此需要注意的是：使用这个autoSizeTextType的时候，控件的layout_width layout_height 不能使用这个wrap_content否则看不出什么效果，要使用具体可衡量的。这个也不难理解，因为它要计算，你设置一个模糊的宽和高，就算不出来了。 2. api&lt;26 的低设备 的兼容写法 官方文档里也明确说明了兼容低版本The library provides support to Android 4.0 (API level 14) and higher. 也就是兼容到4.0以上，写法有些不同，如下：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; tools:ignore=&quot;MissingPrefix&quot; app:autoSizeTextType=&quot;uniform&quot; /&gt;&lt;/LinearLayout&gt; 这个app是这个xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 我们在自定义控件的时候经常遇到它，tools是这个xmlns:tools=&quot;http://schemas.android.com/tools&quot; 当然以上写法都支持动态编码，具体可查阅文档 敲黑板重点你会发现你写完之后编译是报错的，错误类似是这样的： 找不到！！！ 在写那篇文章作者的帮助下，发现首先要兼容低版本，module 的 build.gradle 文件添加依赖时候 就是这个com.android.support:appcompat-v7:xx 后面的版本号要26以上，你看看你自己项目里有哪个版本你就写上哪个，还要在project 的 build.gradle 文件里添加：maven{ url &#39;https://maven.google.com&#39; }添加到对应的位置123456789allprojects &#123; repositories &#123; jcenter() //添加如下内容 maven&#123; url &apos;https://maven.google.com&apos; &#125; &#125;&#125; 至此我发现我的项目终于不报错了，可以运行起来并进行下一步的实践操作了，大家如果在项目中也遇到这样的问题，按我那样改应该没啥问题了，顺便把我写的代码上传到github 上了，又需要的可以下载看看：demo 另外在查看 Android O新特性中发现一个比较好玩的东西：现在，findViewById() 函数的全部实例均返回 T，而不是 View。以后就可以这么写啦：1EditText et = findViewById(R.id.et); 就是那样，无需强转了，当然了使用了Kotlin的话就忽略吧，因为Kotlin连findViewById也不用写，哈哈。更多好玩特性可查看 文档。]]></content>
      <tags>
        <tag>Android O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改自动生成get/set方法模板代码]]></title>
    <url>%2F2018%2F01%2F11%2F%E4%BF%AE%E6%94%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get-set%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天看到面对接口脏数据你还在V层if str==null else setText? 一文，觉着写得挺好，开发过程中多思考多动手，会带来意想不到的效果。底下评论大家也都说了各自的方法和见解，文中有一些问题作者后来也解决了，看到评论里有人说： 说到配置as,就可以实现在创建bean时自动生成return xx==null?&quot;&quot;:xx; 觉着很好，因为我觉着这是一种挺简单的方法，但是就如同底下人问了怎么配置呀，我也不知道，于是我就在自己as工具里新建了一个bean对象，按住alt+insert添加get/set方法，发现了解决办法。如下图： 平时手快也没注意，今天仔细看了看，那上面的意思不就是，get 方法模块，set方法模板吗，后面跟着 IntelliJ Default大概就是默认的生成模板吧，点击后面的三个点按钮进去看看，如下： 这是set的，get方法也类似是这样的，大概也能看懂，想着是不是可以直接模板就好了，发现无法修改，后来又发现左上角的+号，原来是自己可以新建一个模板，然后再生成的时候选择自己的模板就好了，如我们在get模板中新建一个自己的模板： 我们知道我们只需要改一下最后get方法return那个地方的代码，也就是这儿： 不确定是不是，我们可以在后面跟着一个“#”号试试：123$&#123;name&#125;() &#123; return $field.name+&quot;#&quot;;&#125; 在生成的时候选择我们自定义的模板： 发现最后生成的代码：1234567public String getAge() &#123; return age + &quot;#&quot;;&#125;public void setAge(String age) &#123; this.age = age;&#125; 这样证明确定是这样的，那么我么可以继续进行真正的判断了：我们先把这个默认里的get方法代码拷贝到 MyGetter中，我们再根据我们自己的需要修改模板代码,其它地方不变，就修改需要修改的地方：我们想要实现这样的：return xx==null?&quot;&quot;:xx,Ok ，那么我认为大概是这么写的，首先判断是否是字符串：12345678$&#123;name&#125;() &#123; #if(field.String)&#123; return $field.name == null ? &quot;&quot; : $field.name; &#125; #else return $field.name; #end &#125; 我们对比一个default的写法：123$&#123;name&#125;() &#123; return $field.name;&#125; 好的，我们再继续生成一下：1234567public String getAge() &#123; return age == null ? &quot;&quot; : age; &#125; public void setAge(String age) &#123; this.age = age; &#125; 好的，达成效果，耶，居然还可以这么玩，以后可根据自己需求自行修改，谢谢大家。]]></content>
      <tags>
        <tag>get/set.template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2018%2F01%2F09%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[● standard 标准模式 简述：对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。例如：A启动A，A再接着启动A,A再接着启动A,，然后再分别出栈，如图所示： ● singleTop简述：当活动的启动模式指定为 singleTop ,在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。例如：如果快速点击一个按钮，进入Activity，要保证启动的Activity不为多个，可以使用将Activity的启动模式改为 singleTop，就不会启动多个了。如图所示： ● singleTask简述：当活动的启动模式指定为singleTask，每次启动该活动时候，它会先在系统中查找属性值taskaffinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，他就会这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了“singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。 如果设置了“singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 当栈底部的 A 重新被启动打开时，会执行onNewIntent() 方法。 ● singleInstance（单独任务栈）简述：使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都会共用同一个返回栈，也就解决了共享活动实例的问题。 返回的页面顺序是：C-B-A]]></content>
      <tags>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL实例]]></title>
    <url>%2F2018%2F01%2F08%2FAIDL%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[说到进程间通信，一般首先就会想到AIDL，也看了很多文章，做下笔记，记录一下，方便以后查阅。 对于 AIDL 我是这样理解的，首先进程间是无法通信的，那要通信就得有一个媒介或者说两个进程有统一对外的接口可以相互识别，从这个 AIDL全程的名字Android Interface Definition Language (android 接口定义语言) 来看不难看出它就是我们进程间通信的媒介，它可以实现我们想要的通信。 在翻阅网上各类文章的讲解后，我认为一个比较好的实例可以更好理解这个东西，具体如下： 第一步我们新创建两个module，代表我们两个进程，进程名称默认就是我们程序的包名： 第二步我们先编写service这个module里的代码，先定义一个 Person的一个bean对象，记住一定要implements Parcelable 接口，大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Person implements Parcelable &#123; private String mName; public Person(String name) &#123; mName = name; &#125; protected Person(Parcel in) &#123; mName = in.readString(); &#125; public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel in) &#123; return new Person(in); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(mName); &#125; @Override public String toString() &#123; return "\nPerson&#123;" + "mName='" + mName + '\'' + '&#125;'; &#125;&#125; 然后我们再新建一个文件夹：aidl,新建一个包名和Person类一模一样的包名和与之对应的aidl,还有一个我们对外提供获取person集合的一个aidl: 在Person.aidl里，我们序列化我们java里的 Person 类： 12345package com.example.service.bean;//还要和声明的实体类在一个包里，同时注意不要新建aidl文件，因为你会发现，新建不了，//提示你名称唯一，此时你新建一个file,名字为Person.aidl就可以，需要特别注意下parcelable Person; IMyAidl.aidl 文件提供对外方法：12345678910111213141516// IMyAidl.aidlpackage com.example.service.bean;//特别注意一定要手动导包，不会自动导包import com.example.service.bean.Person;// Declare any non-default types here with import statements//可以理解为通信媒介interface IMyAidl &#123; /** * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出) */ void addPerson(in Person person); List&lt;Person&gt; getPersonList();&#125; 然后在我们的java文件里，新建一个MyAidlService,123456789101112131415161718192021222324252627282930313233343536373839public class MyAidlService extends Service &#123; private final String TAG = this.getClass().getSimpleName(); private ArrayList&lt;Person&gt; mPersons; /** * 创建生成本地的binder ,实现AIDL的方法 */ private IBinder mIBinder = new IMyAidl.Stub()&#123; @Override public void addPerson(Person person) throws RemoteException &#123; mPersons.add(person); &#125; @Override public List&lt;Person&gt; getPersonList() throws RemoteException &#123; return mPersons; &#125; &#125;; /** * 客户端与服务端绑定时的回调，返回IBinder对象后客户端就可以通过它远程调用服务端的方法，即实现了通讯 * @param intent * @return */ @Nullable @Override public IBinder onBind(Intent intent) &#123; mPersons = new ArrayList&lt;&gt;(); return mIBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; 最后别忘了在清单文件中注册MyAidlService1234&lt;service android:name="com.example.service.MyAidlService" android:enabled="true" android:exported="true" /&gt; 到此，我们完成了service端的工作： 第三步将我们刚才创建好的aidl文件夹拷贝到 app module下main文件夹下，在MainActivity中绑定服务，123Intent intent = new Intent(); intent.setComponent(new ComponentName("com.example.service","com.example.service.MyAidlService")); bindService(intent,mConnection,BIND_AUTO_CREATE); 其中这个mConnection可以让我们拿到IMyAidl对象的代理123456789101112private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mAidl = IMyAidl.Stub.asInterface(iBinder); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mAidl = null; &#125; &#125;; 通过返回的IBinder 拿到这个IMyAidl，此时我们就可以通信了，例如我们调用IMyAidl中的addPerson方法，再调用getPersonList看看：1234567891011Random random = new Random(); Person person = new Person("qian"+random.nextInt(20)); try&#123; mAidl.addPerson(person); List&lt;Person&gt; mPersons = mAidl.getPersonList(); tvName.setText(mPersons.toString()); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; 打印发现list 返回了我们添加的Person，完成了app与service两个进程间的通信。demo地址：https://github.com/QQabby/AIDLDemo]]></content>
      <tags>
        <tag>AIDL实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文件相关]]></title>
    <url>%2F2017%2F12%2F28%2F%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[向sd卡根目录中写入文件123456789101112//首先判断是否存在sd卡if(Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED))&#123; //获取外部设备 File file=new File(Environment.getExternalStorageDirectory(),"qianqian.txt"); FileOutputStream outStream=new FileOutputStream(file); //写入文件 outStream.write(content.getBytes()); outStream.close(); &#125; 读取assets下的文件路径123//格式如下file:///android_asset/myVideo.htmlfile:///android_asset/xx(文件名称) 读取assets下的文件转化为String123456789101112131415public String getFromAssets(String fileName) &#123; try &#123; InputStreamReader inputReader = new InputStreamReader( getResources().getAssets().open(fileName)); BufferedReader bufReader = new BufferedReader(inputReader); String line = ""; String Result = ""; while ((line = bufReader.readLine()) != null) Result += line; return Result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125;]]></content>
      <tags>
        <tag>向sd卡写入文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU算法还一知半解？]]></title>
    <url>%2F2017%2F12%2F19%2Flru%2F</url>
    <content type="text"><![CDATA[某年某月某日，糖葫芦同学在掘金app上看了几篇文章，偶然看到了一篇熟悉的词LRU算法，脑海里就想这不是经常说的嘛，就那么回事，当天晚上睡觉，LRU算法是啥来着，好像是什么最近最少使用的，白天在地铁上看的文章也不少，但是到晚上想想好像啥也没记住，就记得LRU算法，我发现人大多数是这样的啊，对于自己熟悉的部分呢还能记着点，不熟悉或者不会的可能真的是看过就忘啊~既然这样还不如先把熟悉的弄明白。 第二天来到公司，我觉着还是有必要看一下这个LRU的源码，到底是怎么回事，嗯，糖葫芦同学刷刷得看，下面我们将进入正题，请戴眼镜的同学把眼镜擦一擦，哈哈哈 First先看源码，再用具体的demo加以验证，我们先看一下这个LruCache这个类的大致结构和方法，如下图所示： 这又是 get(K)，put(K,V), remove(K) 的方法的 给人的感觉就像是一个Map的集合嘛，又有Key ，又有value 的，再看下具体的代码： 12345678910111213141516171819202122232425public class LruCache&lt;K, V&gt; &#123; private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 看到开头，我们就明白了，哦原来这个LruCache类中维护一个LinkedHashMap的一个集合，缓存我们这个对象，而且构造方法里需要我们传入一个maxSize的一个值，根据上面的注释我们就明白了这个就是我们LruCache缓存对象的最大数目。 有什么用呢？根据惯性思维，我们可以认为，在put新的缓存对象的时候，根据我们设定的最大值remove集合里的某些缓存对象，进而添加新的缓存对象。 Second根据我们的分析，我们有必要去看一下这个put方法的源码：12345678910111213141516171819202122232425262728/** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous;&#125; 代码量也不是特别多，我们看下这个，在这个synchronized同步代码块里，我们看到这个 size,是对put进来缓存对象个数的累加，然后调用集合的map.put方法，返回一个对象 previous ，就是判断这个集合中是否添加了这个缓存对象，如果不为null,就对size减回去。 最后又调用一个 trimToSize(maxSize)方法，上面都是对添加一些逻辑的处理，那么不可能无限制添加啊，肯定有移除操作，那么我们推测这个逻辑可能在这个trimToSize(maxSize) 里处理。 源码如下：123456789101112131415161718192021222324252627282930313233/** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //只要当前size&lt;= maxSize 就结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; // 获取这个对象，然后从map中移除掉，保证size&lt;=maxSize Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 注释：Remove the eldest entries until the total of remaining entries is at or below the requested size 大概意思是说：清除时间最久的对象直到剩余缓存对象的大小小于设置的大小。没错是我们想找的。 这里说明一下：maxSize就是我们在构造方法里传入的，自己设置的1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这样LruCache的核心方法 trimToSize方法我们就说完了，接下来我将通过实例再次验证下： 设置场景 假设我们设置maxSize 为2，布局里显示3个imageView,分别代表3张我们要显示的图片，我们添加3张图片，看看会不会显示3张？ xml布局显示如下（代码就不贴了，很简单）： activity代码如下：12345678910111213141516171819202122232425262728public final int MAX_SIZE = 2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_lru); ImageView iv1 = (ImageView) findViewById(R.id.iv1); ImageView iv2 = (ImageView) findViewById(R.id.iv2); ImageView iv3 = (ImageView) findViewById(R.id.iv3); Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),R.drawable.bg); Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(),R.drawable.header_img); Bitmap bitmap3 = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); LruCache&lt;String,Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE); lruCache.put("1",bitmap1); lruCache.put("2",bitmap2); lruCache.put("3",bitmap3); Bitmap bitmap = lruCache.get("1"); iv1.setImageBitmap(bitmap); Bitmap b2 = lruCache.get("2"); iv2.setImageBitmap(b2); Bitmap b3 = lruCache.get("3"); iv3.setImageBitmap(b3); &#125; 图： 我们可以先尝试分析一下：因为我们设置的MaxSize 是2 ，那么在put第三个Bitmap的时候，在trimToSize方法中，发现这个size是3 ，maxSize 是2，会继续向下执行,不会break,结合下面代码看下12345678910111213141516171819202122232425262728public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //第一次循环：此时 size 是3，maxSize 是 2 //第二次循环，此时 size 是 2 ，maxSize 是 2 ，满足条件，break,结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; //获取最先添加的第一个元素 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); //移除掉第一个缓存对象 map.remove(key); // size = 2,减去移除的元素 size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 这个 safeSizeOf 是调用sizeOf方法。 那么也就是说，我们在put第三个bitmap的时候，LruCache 会自动帮我们移除掉第一个缓存对象，因为第一个最先添加进去，时间也最长，当然后添加的bitmap就是新的，最近的，那么我们推断这个iv1是显示不出图片的，因为被移除掉了，其它剩余两个可以显示，分析就到这里，看下运行结果是不是跟我们分析的一样： 哇！真的跟我们想的一样耶，证明我们想的是对的。这里我们思考一下就是为什么LruCache使用了这个LinkedHashMap,为什么LinkedHashMap的创造方法跟我们平时创建的不太一样，源码是这样的：1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这里说一下在掘金发布的评论里 藏地情人评论是：new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true)这句代码表示，初始容量为零，0.75是加载因子，表示容量达到最大容量的75%的时候会把内存增加一半。最后这个参数至关重要。表示访问元素的排序方式，true表示按照访问顺序排序，false表示按照插入的顺序排序。这个设置为true的时候，如果对一个元素进行了操作(put、get)，就会把那个元素放到集合的最后。 确实也是这样的，我们看下LinkedHashMap的源码：1234567891011121314151617/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; 里面这个assessOrder 注释里也说的很明白：the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order -&gt; true 呢就表示会排序，false 就代表按照插入的顺序。默认不传就是 false ,而且我们每次 get(K) put(K,V) 的时候 会根据这个变量调整元素在集合里的位置。而这么做的目的也只有一个：保留最近使用的缓存对象，举个例子说明一下： 我们向这个集合里添加了三种元素 LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE);(MAX_SIZE=2) lruCache.put(&quot;1&quot;, bitmap1); lruCache.put(&quot;2&quot;, bitmap2); lruCache.put(&quot;3&quot;, bitmap3); 此时它们在集合里的顺序是这样的： 那比如说我们在put 3 元素之前，使用了1元素，就是调用了get(&quot;1&quot;)方法，我们知道LinkedHashMap就会改变链表里元素的存储顺序，代码是这样的：1234lruCache.put("1", bitmap1);lruCache.put("2", bitmap2);lruCache.get("1");lruCache.put("3", bitmap3); 那么此时对应链表里的顺序就是： 当我们再调用显示的时候，循环遍历就会优先把第一个位置的key = &quot;2&quot; 的缓存对象移除掉，保证了最近使用的原则，当然了因为把这个max_size = 2所以在我们执行lruCache.put(&quot;3&quot;, bitmap3); 时，集合最终会变成这样： 集合里只剩下 1 ,3对应的缓存对象。 至此，LruCache就说完了，如果看完的你有不明白的地方可以留言，一起讨论下~]]></content>
      <tags>
        <tag>Lru</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
