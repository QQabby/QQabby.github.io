<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[https]]></title>
    <url>%2F2019%2F01%2F23%2Fhttps%2F</url>
    <content type="text"><![CDATA[本文参考阅读理解：https://showme.codes/2017-02-20/understand-https/ https://baijiahao.baidu.com/s?id=1590626703682162118&amp;wfr=spider&amp;for=pc 对称加密 于是客户端和服务端都需要保存的加密算法和对应的密钥 非对称加密 即服务端将公钥下（数字签名过）发给客户端，客户端利用公钥进行信息加密，服务端收到信息利用私钥解密。 总结HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然后直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务端不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务端之间的通信安全问题。]]></content>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[描述一次完整的网络请求过程]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%8F%8F%E8%BF%B0%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[DNS 解析 TCP建立连接，三次握手，四次挥手 客户端发送http 请求 服务端响应客户端请求，返回数据 客户端拿到数据，解析xml,显示到浏览器上。]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据存储的方式]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[回忆Android中数据的存储方式有哪些，简单列举下。 1. SharedPreferences Android 自带的数据存储，以 xml 的形式存储在 /data/data/packageName/shared_prefs 这里提一下提交的两种方式： commit 和 apply**** commit 1234567891011121314151617181920/** * Commit your preferences changes back from this Editor to the * &#123;@link SharedPreferences&#125; object it is editing. This atomically * performs the requested modifications, replacing whatever is currently * in the SharedPreferences. * *如果两个都在修改提交，那么以最后一个为主。也就是后面会覆盖前面的 * &lt;p&gt;Note that when two editors are modifying preferences at the same * time, the last one to call commit wins. * * 如果你不关心返回结果在主线程中，考虑使用apply代替 * &lt;p&gt;If you don't care about the return value and you're * using this from your application's main thread, consider * using &#123;@link #apply&#125; instead. * * 返回true 表示成功 * @return Returns true if the new values were successfully written * to persistent storage. */ boolean commit(); apply 1234567891011121314151617181920212223242526272829303132333435/** *先立即提交到内存中，然后异步提交到数据库中 * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out * to persistent storage synchronously, &#123;@link #apply&#125; * commits its changes to the in-memory * &#123;@link SharedPreferences&#125; immediately but starts an * asynchronous commit to disk and you won't be notified of * any failures. * * 如果这个&#123;@link SharedPreferences&#125;上的editor执行常规的&#123;@link #commit&#125;，而 *&#123;@link #apply&#125;仍然未完成，那么&#123;@link #commit&#125;将阻塞，直到所有异步提交以及提交本身都 * 完成。 * If another editor on this * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125; * while a &#123;@link #apply&#125; is still outstanding, the * &#123;@link #commit&#125; will block until all async commits are * completed as well as the commit itself. * * sharedPreferences在一个进程中是单例的，它是安全的apply ,如果你不需要返回值的话 * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within * a process, it's safe to replace any instance of &#123;@link #commit&#125; with * &#123;@link #apply&#125; if you were already ignoring the return value. * * 不需要担心Android的生命周期，它会确保写入硬盘中再切换状态 * &lt;p&gt;You don't need to worry about Android component * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt; * writing to disk. The framework makes sure in-flight disk * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching * states. * * &lt;p class='note'&gt;The SharedPreferences.Editor interface * isn't expected to be implemented directly. However, if you * previously did implement it and are now getting errors * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;. */ void apply(); 结论 在不考虑跨进程通信和返回值的情况下，可以优先选择 apply ，可以快速读取更新后的值。 2. 文件存储（SD卡）3. Sqlite4. ContentProvider5. 网络存储]]></content>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View的构造方法]]></title>
    <url>%2F2019%2F01%2F21%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[例如： 12345678910111213141516public class MyView extends View &#123; //在代码中直接new MyView()实例的时候，会调用第一个构造方法 public MyView(Context context) &#123; super(context); &#125; //在xml中布局文件中使用MyView的时候，会调用第二个构造函数； //在xml中布局文件中使用了MyView,并且还有自定义属性的时候，也是第二个构造函数。 //当我们自定义属性了，通过obtainStyledAttributes，也是最终调用参数为3个的构造函数 public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 其中 int defStyleAttr : 这是当前 Theme 中包含的一个指向 style 的引用，当我们自定义属性时，默认从这个集合里面查找布局文件中配置属性值，传入0表示不向该 defStyleAttr 中查找值。 属性赋值优先级次序表： 1在xml中直接定义 &gt; 在xml中通过Style定义 &gt; 自定义view所在Activity的 Theme中指定Style引用 &gt; 构造函数中defStyleRes指定的默认值。]]></content>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发中的onTouch 和onTouchEvent 有什么区别?]]></title>
    <url>%2F2019%2F01%2F21%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%AD%E7%9A%84onTouch-%E5%92%8ConTouchEvent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当看到这两个方法时，我们大概就应该直到 onTouchEvent 是触摸反馈的事件， onTouch 为一个方法。 像这种写法，我们经常看到: 123456789101112131415161718//onTouch 方法layout.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; //返回值尤为重要，如果父控件设置了此方法并返回true，就不会再继续向下传递 return false; &#125; &#125;);//onTouchEvent 方法public class MyView extends View &#123; .... @Override public boolean onTouchEvent(MotionEvent event) &#123; //分别处理事件的按下，移动，抬起等操作 return super.onTouchEvent(event); &#125;&#125; 我们直到事件的传递分发从 diapatchTouchEvent() 方法开始，可以看下该方法： 12345678910111213141516public boolean dispatchTouchEvent(MotionEvent event) &#123; ... //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; //这里判断是否设置了onTouchListener,控件是否可用，onTouch的返回值 if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //判断onTouchEvent 的返回值 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ... &#125; 可以看到，程序优先判断了设置了 onTouchListener ，然后再判断 onTouchEvent, 即判断的先后顺序不同。 在前面我们说到，如果设置了 onTouchListener 并且在重写 onTouch 方法中返回了 true ,表明消费这个控件的触摸事件，那么该控件的点击事件将无法收到，因为点击事件 performOnClick 是在 onTouchEvent() 方法中执行的，如下： 1234567891011public boolean onTouchEvent(MotionEvent event) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ... if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClickInternal(); &#125;&#125;]]></content>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的刷新机制]]></title>
    <url>%2F2019%2F01%2F18%2FView%E7%9A%84%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在Android 布局体系种，父 View 负责刷新，子 View 负责布局展示。子View 如果要刷新，需要通知父View 来完成。 123456789101112131415161718//invalidate 最终调用到这里void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; .... //这里特殊注意下这个 AttachInfo final AttachInfo ai = mAttachInfo; //得到父控件 final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; //将attachInfo 信息保存在damage 中 final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); //父 View--&gt; p 调用自身invalidateChild 方法刷新 p.invalidateChild(this, damage); &#125; .... &#125; &#125; 在 invalidate 中，调用父 View 的 invalidateChild , 这是一个由低向上回溯的过程，每一层的父 View 都将自己的显示区域与传入的刷新 Rect 做交集，一直向上追溯直到 ViewRoot 那里结束，由 ViewRoot 对这个最终的刷新区域做刷新。 123public void invalidateChild(View child, Rect dirty) &#123; scheduleTraversals();&#125;]]></content>
      <tags>
        <tag>View的刷新机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View相关]]></title>
    <url>%2F2019%2F01%2F18%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[setContentView的过程 View 的绘制流程 首先 WindowManager 负责这个 DecorView 和 ViewRoot 相关联 每一个应用程序的窗口 DecorView 都有一个与之相对应得 ViewRoot对象 整体流程如下：]]></content>
      <tags>
        <tag>View 绘制流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment相关]]></title>
    <url>%2F2019%2F01%2F17%2FFragment%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Fragment 的概念 关于 Fragment 如何用浅显的语言来描述它呢，我认为就是：Activity 就像是一个大屋子，大屋子里有很多房间，而这里的每个房间就是 fragment ,称为模块化的 Activity. 并且 fragment 不能单独存在，必须依附于 Activity; fragment 的生命周期受到外部 Activity 的影响； fragment 有自己的生命周期； Fragment 优点 Fragment 可以将 Activity 分离成多个可重用的组件，每个都有各自的生命周期和UI 灵活的UI设计，可以适用于不同的屏幕尺寸，手机，平板 Fragment 做为一个独立的模块可以轻松被 Activity 控制，添加，移除和替换 Fragment 切换流畅，比Activity 之间切换要好 Fragment与Activity的通信方式 可以选择第三方的 EventBus 等 setArugments 方法（Activity 向 Fragment 传递参数） 自定义接口回调 当然也可以强制类型转化，例如：((MainActivity)getActivity()).text; fragment 中获取宿主 MainActivity 里的一个 public 字段。 在SDK26 的API 引入了 Activity.onAttachFragment(Fragment fragment), 可以将 Activity 的数据传递给 Fragment. Fragment 生命周期放上一张官网 Fragment 的生命周期图： 挺清晰的，感觉和 Activity 的生命周期很像； 程序启动： onAttach()---&gt; onCreate()----&gt;onCreateView()----onActivityCreate()---&gt;onStart()----&gt; onResume() 上图显示 Fragment 已经处于运行 Active 状态 后台状态： onPause()---onStop() 切换到其他Fragment :onPause() ---&gt; onStop() ---&gt; onDestroyView(), 当再次切换回来的时候就不执行 onCreate() 了，直接从 onCreateView() 开始执行 锁屏： onPause() ---&gt; onStop() 点亮屏幕： onStart() ---&gt; onResume() 退出应用： onPause() ---&gt; onStop() ----&gt; onDestroyView() -- &gt; onDestroy() ----onDetach() Home 键： onPause() ---&gt; onStop() Fragment的add与replace的区别1234getSupportFragmentManager().beginTransaction() .add(R.id.fragment_container, mainSpaceFragment)//这是add .show(mFragment).commit();//replace add 方式添加的 Fragment ,在切换 Fragment 的时候不会刷新 Fragment,但是 replace 方式在切换 Fragment 的时候会重新创建，它会销毁之前的那个，add 方式只是隐藏了而不是销毁了, 一般开发使用的是 add 方式。 用Fragment可能会遇到的问题 getActivity() 为空 我碰见这个问题的几率还挺大的，网上说是因为内存重启，重启的时候调用 getActivity() 的地方返回null. 产生的原因：当调用了 getActivity() 时，当前 Fragment 已经 onDetach() 脱离了宿主 Activity. 解决的办法：当时在 stackoverflow 上看到过就是在使用之前先判断下 isAdd() 类似的方法 Fragment 重叠异常 正确使用 hide, show 的姿势。在类 onCreate() 的方法加载 Fragment, 并没有判断 saveInstanceState == null , 导致重复加载了同一个 Fragment 导致重叠。 12345678@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123;// 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ; if(saveInstanceState == null)&#123; // 或者 if(findFragmentByTag(mFragmentTag) == null) // 正常情况下去 加载根Fragment &#125; &#125; getFragmentManager，getSupportFragmentManager ，getChildFragmentManager三者之间的区别 getSupportFragmentManager() : 主要用于支持3.0以下的Android系统API版本，3.0以上系统可以直接使用 getFragmentManager() . 因为 fragment 是3.0以后才出现的组件，所以在3.0以下的设备使用v4 包中的 getSupportFragment() ； getFragmentManager() : 得到所在fragment的父容器的管理器； getChildFragmentManager() : 得到fragment里面子容器的管理器。 一般的使用场景 当 Fragment 嵌套 Fragment 时，需要使用 getChildFragmentManager() FragmentPagerAdapter与FragmentStatePagerAdapter的区别与使用场景 对于经常使用 viewpager 的应该大概都知道就是： 当 viewpager 中的 fragment 数量多的时候用 FragmentStatePagerAdapter ,同样当fragment 比较少的时候，则使用 FragmentPagerAdapter. 在 FragmentPagerAdapter 中的 destroyItem 中： 12345678public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; if (this.mCurTransaction == null) &#123; this.mCurTransaction = this.mFragmentManager.beginTransaction(); &#125; //这里只是detach Fragment ,并没有做释放内存的操作， //这样当fragment 比较多的时候，内存就会不够用，越用越多 this.mCurTransaction.detach((Fragment)object); &#125; 然后在看下 FragmentStatePagerAdapter 中的 destroyItem : 1234567891011121314151617public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; Fragment fragment = (Fragment)object; if (this.mCurTransaction == null) &#123; this.mCurTransaction = this.mFragmentManager.beginTransaction(); &#125; while(this.mSavedState.size() &lt;= position) &#123; this.mSavedState.add((Object)null); &#125; //判断是否add this.mSavedState.set(position, fragment.isAdded() ? this.mFragmentManager.saveFragmentInstanceState(fragment) : null); //将该位置的fragment 设置为null this.mFragments.set(position, (Object)null); //这里进行了移除的操作,释放 fragment,减少内存 //所以当 fragment 比较多的时候使用FragmentStatePagerAdapter this.mCurTransaction.remove(fragment); &#125;]]></content>
      <tags>
        <tag>fragment 相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation动画相关知识点]]></title>
    <url>%2F2019%2F01%2F15%2FAnimation%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[关于 Animation 的一些回顾和总结 关于Animation 和 Animator Animation 是我们经常用到的一些动画，包括帧动画和补间动画，而 Animator 是Android 3.0 的时候推出的动画框架，也称为属性动画 版本兼容 实现效率 适用性 是否产生内存泄漏 使用效果 Animation 可兼容Android3.0以下的版本 直接通过代码对矩阵进行处理 仅对View对象有用 不会 假的移动 Animator 无法兼容，也没有向下兼容的support包 通过设置对象的setter,getter方法，来达到动画目的，使用了java反射机制，可用于任意对象，效率低于Animation 任意对象(但是需要有get/set方法) 可能会，当设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏。 真的位置变换 关于动画的基本使用 Animation 相关动画的使用 帧动画 一般我们使用帧动画都是采取xml定义的方式 12345678910111213141516171819202122232425// yun_anim.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@mipmap/app_loading0" android:duration="150" /&gt; &lt;item android:drawable="@mipmap/app_loading1" android:duration="150" /&gt; &lt;item android:drawable="@mipmap/app_loading2" android:duration="150" /&gt; &lt;item android:drawable="@mipmap/app_loading3" android:duration="150" /&gt;&lt;/animation-list&gt; //将它定义成一个drawable,这样引用&lt;ImageView android:id="@+id/img_progress" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/yun_anim" /&gt; 补间动画 包括一些平移(Translate)，旋转(Rotate)，透明度(Alpha)，缩放动画(Scale)，使用都差不多,可以在xml中创建使用也可以动态创建使用。 xml 中类似于这样： 123456789101112//这是一个动画集合&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;translate android:duration="200" android:fromYDelta="100%p" android:toYDelta="0" /&gt;&lt;/set&gt;//使用xx布局文件的名称Animation translateAnimation = AnimationUtils.loadAnimation(this, R.anim.xx);iv.startAnimation(translateAnimation); java 代码设置： 1234//位移动画，相应还有旋转其它类似Animation animation = new TranslateAnimation(0,100,0,100)translateAnimation.setDuration(3000);iv.startAnimation(translateAnimation); 属性动画 ValueAnimator 是属性动画的一个核心类 12345678910ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f); anim.setDuration(300); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float currentValue = (float) animation.getAnimatedValue(); Log.d("TAG", "cuurent value is " + currentValue); &#125; &#125;); anim.start() ObjectAnimator 12345678//透明度的变化，还可以位移啥的ObjectAnimator animator = ObjectAnimator.ofFloat(iv, "alpha", 1f, 0f, 1f); animator.setDuration(5000); animator.start(); ------------------------------ObjectAnimator animator = ObjectAnimator.ofFloat(iv, "rotation", 0f, 180f); animator.setDuration(5000); animator.start(); 官方一张图： ValueAnimator 是属性动画很重要的一个类，其中 ObjectAnimator 继承于 ValueAnimator .. 问题：那 ValueAnimator 到底是怎样实现初始值平滑过渡到结束值的呢？ 这个是由 TypeEvaluator 和 TimeInterpolator 共同决定的。 具体来说：TypeEvaluator 决定了从初始值过度到结束值过度的方式。TimeInterpolator 决定了动画从初始值过渡到结束值的节奏。 有个例子很恰当：你每天上班去公司，是选择地铁出行还是公交，还是骑行，选择从出发地到目的地的一种抵达方式，这个是 TypeEvaluator, 假如你选择骑行，是均速骑行到目的地还是先加速后减速，还是一开始慢后来快，这个就是 TimeInterpolator 决定的。 用TypeEvaluator 确定运动轨迹 一般来说，要定义运动轨迹，需要实现 TypeEvaluator 12345678910111213141516171819202122public class PointEvaluator implements TypeEvaluator &#123; /** * This function returns the result of linearly interpolating the start and end values, with * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (x1 - x0)&lt;/code&gt;, * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;, * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;. * * @param fraction The fraction from the starting to the ending values 动画当前进行的进度 * @param startValue The start value.开始值 * @param endValue The end value.结束值 * @return A linear interpolation between the start and end values, given the * &lt;code&gt;fraction&lt;/code&gt; parameter.线性 */ @Override public Point evaluate(float fraction, Point startValue, Point endValue) &#123; //自定义轨迹路线，假如我们做一个线性运动 return new Point((int)(startValue.getX()+endValue.getX()*fraction), (int)(startValue.getY()+endValue.getY()*fraction)); &#125;&#125; 使用的时候： 1234567891011121314151617181920Point startP = new Point(0,0); Point endP = new Point(500,500); ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointEvaluator(), startP, endP); valueAnimator.setDuration(5000); valueAnimator.setRepeatCount(10); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Point currentPoint = (Point) animation.getAnimatedValue(); iv.setX(currentPoint.getX()); iv.setY(currentPoint.getY()); current.setX(130+currentPoint.getX()); current.setY(currentPoint.getY()); current.setText(""); current.setText("x="+currentPoint.getX()+" y="+currentPoint.getY()); &#125; &#125;); valueAnimator.start(); 这样我们就完成了动画轨迹的定义。 例如我们来一个最简单的线性运动： TimeInterpolator 前面说过，这个是用来控制动画从开始到结束的节奏的。Android 自己提供了几个自带的 Interpolator,当然同时也可以自定义实现。]]></content>
      <tags>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[断点续传了解]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[所谓断点续传，也就是要从文件已经下载的地方开始继续下载。所以在客户端浏览器传给 wen 服务器的时候要多加一条信息即：从哪里开始的问题。 假设：我们从服务器下载一个文件，需要从 2000070 这个字节后开始下载，之前已经下载过了，注意查看以下代码： 1234567get /down.zip http/1.0user-agent: netfoxrange: bytes=2000070-//新增加字段，range,这一行的意思就是告诉服务器我这个文件从2000070字节开始传输，前面的字节就不用传了。accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 服务器收到这条信息，就开始返回信息： 123456789101112131415206 //注意此时服务器的返回码不再是200而是206content-length=106786028content-range=bytes 2000070-106786027/106786028 //这行也是服务器新增加字段，返回的字节是从2000070-106786027 之间的字节，之前的字节就不传了。date=mon, 30 apr 2001 12:55:20 gmtetag=w/"02ca57e173c11:95b"content-type=application/octet-streamserver=microsoft-iis/5.0last-modified=mon, 30 apr 2001 12:55:20 gmt 以上差不多就是断点续传需要知道的知识和大致的原理。 问题 用什么方法实现提交 range:bytes=2000070- ？ 使用最原始的 socket 肯定可以完成，不过很费事，用java的net包中提供了设置的方法，如下： 123456789101112131415try &#123; URL url = new URL("http://www.baidu.com"); try &#123; HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); //通过设置requestProperty httpURLConnection.setRequestProperty("rande","bytes=2000070"); //这样获取的输入流就是从2000070这个字节后开始的 InputStream input = httpURLConnection.getInputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; 接下来：获取到流了，那么如何从流保存到文件中去呢？ 保存文件的方法，采用的是 io 包中的 randomacessfile 类。如下代码： 1234567//上面文件已经获取到 inputStream--inputRandomAccessFile saveFile = new RandomAccessFile("down.zip","rw");//down.zip下载文件名称saveFile.seek(2000070);//定位文件指针到这个 2000070 位置byte[] b= new byte[1024];int read;while((read = input.read(b,0,1024))&gt;0)&#123;saveFile.write(b,0,read); 基本大概就是这样。]]></content>
      <tags>
        <tag>断点续传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serializable与 Parcelable 的区别]]></title>
    <url>%2F2019%2F01%2F10%2FSerializable%E4%B8%8EParcable%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[序列化的两种方式，一种是 java 提供的 Serilizable 和 Android 自身提供的 Parcelable. 基本使用12345678910111213141516171819202122232425262728293031323334 public class Person implements Serializable &#123; //默认方式最好设置为1L,因为 java sdk 会自动进行hash计算，并生成唯一的 //UID值。手动设置serialVersionUID的好处是当前class如果改变了成员变量， //比如增加或删除之后，这个UID是不改变的，反序列化不会失效。 private static final long serialVersionUID = 1L; .... &#125;//Parcable 类似public class UserInfo implements Parcelable &#123; private String name; private String lastName; ... public static final Creator&lt;UserInfo&gt; CREATOR = new Creator&lt;UserInfo&gt;() &#123; @Override public UserInfo createFromParcel(Parcel in) &#123; return new UserInfo(in); &#125; @Override public UserInfo[] newArray(int size) &#123; return new UserInfo[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeString(lastName); &#125;&#125; 区别 存储媒介的不同 存储媒介 特点 Serializable 使用的IO读写存储在硬盘上，序列化过程使用了反射技术，并且期间产生临时对象（？）,从而引起频繁的GC。 代码少 Parcelable 使用的IO读写在内存中，内存的读写速度肯定优于硬盘读写速度，所以Parcelable的性能上优于Serializable. 代码写起来比较多 具体到开发中用哪个，个人觉着要考虑要传递对象的大小，如果对象比较大，手机内存比较小，可能会报出 TransactionTooLargeException: The Binder transaction failed because it was too large . 此时就要考虑使用 Parcelable 了，如果对象不是特别大，使用 Serializable 还是挺合适的，毕竟实现比较简单。]]></content>
      <tags>
        <tag>Serializable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService理解总结]]></title>
    <url>%2F2019%2F01%2F09%2FIntentService%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[平常用的不是特别多，但是要知道内部原理，看看源码总结一下 首先为什么会有这个东西？ 我们知道服务中 service 中的代码是运行在主线程中的，不能做耗时的操作，于是那如果想做耗时操作怎么做呢？就出来 IntentService 这么个东西，用来处理后台服务中的耗时操作并且可以在任务完成之后，自动停止服务。 基本使用12345678910111213141516171819202122public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService"); &#125; //处理异步任务 @Override protected void onHandleIntent(Intent intent) &#123; // 打印当前线程的id Log.d("MyIntentService", "Thread id is " + Thread.currentThread(). getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService", "onDestroy executed"); &#125;&#125;//开启服务Intent intentService = new Intent(this, MyIntentService.class);startService(intentService); 通过打印当前线程的 id 我们可以知道当前线程不是在主线程中，执行完成后，会自动执行 onDestroy() 方法。以上属于 IntentService 的基本用法。 有什么好处呢？ 省去在 Service 中手动开线程的麻烦 当操作任务完成后自动停止服务 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/** * IntentService is a base class for &#123;@link Service&#125;s that handle asynchronous * requests (expressed as &#123;@link Intent&#125;s) on demand. Clients send requests * through &#123;@link android.content.Context#startService(Intent)&#125; calls; the * service is started as needed, handles each Intent in turn using a worker * thread, and stops itself when it runs out of work. * * &lt;p&gt;This "work queue processor" pattern is commonly used to offload tasks * from an application's main thread. The IntentService class exists to * simplify this pattern and take care of the mechanics. To use it, extend * IntentService and implement &#123;@link #onHandleIntent(Intent)&#125;. IntentService * will receive the Intents, launch a worker thread, and stop the service as * appropriate. 使用它，需要继承IntentService,并且实现 onHandleIntent方法，IntentService会收到这些Intent,开启一个工作线程，在合适的时间会自动停止服务 * * &lt;p&gt;All requests are handled on a single worker thread -- they may take as * long as necessary (and will not block the application's main loop), but * only one request will be processed at a time. 所有的请求被处理在一个单一的工作线程中，不会阻塞主线程，但是在同一时间指挥处理一个请求 * * &lt;div class="special reference"&gt; * &lt;h3&gt;Developer Guides&lt;/h3&gt; * &lt;p&gt;For a detailed discussion about how to create services, read the * &lt;a href="&#123;@docRoot&#125;guide/components/services.html"&gt;Services&lt;/a&gt; developer * guide.&lt;/p&gt; * &lt;/div&gt; *官网文档链接 * @see android.os.AsyncTask */public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; //异步处理任务 onHandleIntent((Intent)msg.obj); //停止自身服务 //stopSelf()： 会立马结束服务 //stopSelf(int startId)： 等待所有消息都处理完后才终止服务 stopSelf(msg.arg1); &#125; &#125; /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) &#123; super(); mName = name; &#125; /** * Sets intent redelivery preferences. Usually called from the constructor * with your preferred semantics. * * &lt;p&gt;If enabled is true, * &#123;@link #onStartCommand(Intent, int, int)&#125; will return * &#123;@link Service#START_REDELIVER_INTENT&#125;, so if this process dies before * &#123;@link #onHandleIntent(Intent)&#125; returns, the process will be restarted * and the intent redelivered. If multiple Intents have been sent, only * the most recent one is guaranteed to be redelivered. * * &lt;p&gt;If enabled is false (the default), * &#123;@link #onStartCommand(Intent, int, int)&#125; will return * &#123;@link Service#START_NOT_STICKY&#125;, and if the process dies, the Intent * dies along with it. */ public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); //创建了一个HandlerThread HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); //取出HandlerThread线程的 looper ,由于 `HandlerThread` 又是一个异步线程，当我们把 //Looper 传递给 ServiceHandler时，使得 ServiceHandler也变成了一个异步执行的线程 mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; /** * You should not override this method for your IntentService. Instead, * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; /** * Unless you provide binding for your service, you don't need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call &#123;@link #stopSelf&#125;. * * @param intent The value passed to &#123;@link * android.content.Context#startService(Intent)&#125;. * This may be null if the service is being restarted after * its process has gone away; see * &#123;@link android.app.Service#onStartCommand&#125; * for details. */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 总结IntentService.java 总结来说就是：一个 HandlerThread + ServiceHandler , 以队列的形式处理异步操作的类。 IntentService 是继承与 Service 的，在 onCreate() 时，创建了 HandlerThread 实例（ HandlerThread 又是啥呢，它是 Thread 子类，内部拿到一个当前线程的 Looper, Looper 一直轮询消息，获得消息，处理消息），而 IntentService 内部有一个ServiceHandler,ServiceHandler 的创建的 Looper 是拿的是 HandlerThread 的 Looper , IntentService 在 onStart() 通过发送 Message, 在处理 Message 调用的是 onHandleIntent() 方法。]]></content>
      <tags>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC]]></title>
    <url>%2F2019%2F01%2F04%2FIOC%2F</url>
    <content type="text"><![CDATA[以下内容是我最近在学习 Spring Boot Spring MVC 过程中，针对 ioc 控制反转所了解到的内容。 实践步骤 使用 Spring Boot, Spring 如何实现 IOC 使用 maven java oop : 每次都是自己 new 对象，不够方便，核心原因是产生了代码的偶合。 目标：希望容器给我对象，直接获得对象； IOC: 控制反转，表示把对象的控制权交给容器 示例： 123456789101112131415161718 @Bean public Student getStudent()&#123; Student stu = new Student(); stu.setName("糖葫芦"); stu.setAge("18"); return stu; &#125;在另外一个类 SpringBootIocApplicationTests.java 中：@Autowired Student student; @Test public void contextLoads() &#123; //这里可以直接拿到 System.out.println("student:"+student.getName()); //student:糖葫芦 &#125; Maven 项目如果不用 Spring Boot ,创建 Maven 项目进行实现： 使用 ide 创建 maven 项目 注意勾选 create from.. 要实现控制反转，需要我们导入 Spring Context 配置，在 maven 官网： 搜索 Spring, 底下有很多版本，导入你想导入的版本，点击进去，看到： 将红色框部分，拷贝到 项目的 pom.xml 文件中，如下： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project ...... &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.20.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 然后我们还需要手动设置配置文件：在 resources 文件夹下，创建一个 xml ,我们可以这么创建 xml,可以帮助我们自带一些配置，如下： applicationContext.xml : 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="student" class="Student"&gt;&lt;!--将这个bean加入到spring的ioc容器--&gt; &lt;property name="name" value="糖葫芦"&gt;&lt;/property&gt;&lt;!--给bean的pname属性赋值--&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 最后，如何获取呢？通过 ApplicationContext 获取： 123456789public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml"); //传入xml 中定义的bean 的 id Student student = (Student) context.getBean("student"); System.out.println("student::"+student.getName()+ "::::age::"+student.getAge()); &#125; 这样我们就可以拿到我们在 xml 中定义的 bean 的内容了。]]></content>
      <tags>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化随笔]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[随着技术越来越发展，代码越来越臃肿，经常会牵一发而动全身，发生bug的概率也比较高，组件化一定程度上成了我们必不可少的一个部分，使用组件化能够： 提高代码的复用性 降低组件之间的耦合性，一定程度上减少bug的产生 设计组件化： 分层设计，app壳工程，业务组件，功能组件，基础组件。 业务组件为了防止相互引用出现死循环，每一个业务组件设计成两个module, 一个 export module,一个 implement module. 互相依赖 export modult 即可。]]></content>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Context]]></title>
    <url>%2F2018%2F12%2F25%2FContext%2F</url>
    <content type="text"><![CDATA[Context1public abstract class Context &#123; 之间的继承关系： Context 作用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//可以点击studio旁边的 Structure 结构示意图/*** Interface to global information about an application environment. This is* an abstract class whose implementation is provided by* the Android system. It* allows access to application-specific resources and classes, as well as* up-calls for application-level operations such as launching activities,* broadcasting and receiving intents, etc.*/public abstract class Context &#123; // 四大组件相关 public abstract void startActivity(@RequiresPermission Intent intent); public abstract void sendBroadcast(@RequiresPermission Intent intent); public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver, IntentFilter filter); public abstract void unregisterReceiver(BroadcastReceiver receiver); public abstract ComponentName startService(Intent service); public abstract boolean stopService(Intent service); public abstract boolean bindService(@RequiresPermission Intent service, @NonNull ServiceConnection conn, @BindServiceFlags int flags); public abstract void unbindService(@NonNull ServiceConnection conn); public abstract ContentResolver getContentResolver(); // 获取系统/应用资源 public abstract AssetManager getAssets(); public abstract Resources getResources(); public abstract PackageManager getPackageManager(); public abstract Context getApplicationContext(); public abstract ClassLoader getClassLoader(); public final @Nullable &lt;T&gt; T getSystemService(@NonNull Class&lt;T&gt; serviceClass) &#123; ... &#125; public final String getString(@StringRes int resId) &#123; ... &#125; public final int getColor(@ColorRes int id) &#123; ... &#125; public final Drawable getDrawable(@DrawableRes int id) &#123; ... &#125; public abstract Resources.Theme getTheme(); public abstract void setTheme(@StyleRes int resid); public final TypedArray obtainStyledAttributes(@StyleableRes int[] attrs) &#123; ... &#125; // 获取应用相关信息 public abstract ApplicationInfo getApplicationInfo(); public abstract String getPackageName(); public abstract Looper getMainLooper(); public abstract int checkPermission(@NonNull String permission, int pid, int uid); // 文件相关 public abstract File getSharedPreferencesPath(String name); public abstract File getDataDir(); public abstract boolean deleteFile(String name); public abstract File getExternalFilesDir(@Nullable String type); public abstract File getCacheDir(); ... public abstract SharedPreferences getSharedPreferences(String name, @PreferencesMode int mode); public abstract boolean deleteSharedPreferences(String name); // 数据库相关 public abstract SQLiteDatabase openOrCreateDatabase(...); public abstract boolean deleteDatabase(String name); public abstract File getDatabasePath(String name); ... // 其它 public void registerComponentCallbacks(ComponentCallbacks callback) &#123; ... &#125; public void unregisterComponentCallbacks(ComponentCallbacks callback) &#123; ... &#125; ...&#125;public interface ComponentCallbacks &#123; void onConfigurationChanged(Configuration newConfig); void onLowMemory();&#125; Context 就相当于 Application 的大管家，主要负责： 四大组件，启动 Activity , 广播，服务等 获取系统资源 文件操作相关 数据库操作相关 ContextWrapper123456789101112131415161718192021222324252627282930313233/** * Proxying implementation of Context that simply delegates all of its calls to * another Context. Can be subclassed to modify behavior without changing * the original Context. */public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; /** * Set the base context for this ContextWrapper. All calls will then be * delegated to the base context. Throws * IllegalStateException if a base context has already been set. * * @param base The new base context for this wrapper. */ protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException("Base context already set"); &#125; mBase = base; &#125; /** * @return the base context as set by the constructor or setBaseContext */ public Context getBaseContext() &#123; return mBase; &#125; &#125; ContextWrapper 实际上就是 Context 的代理类，所有的操作都是 mBase 完成。另外，Activity, Service 的 getBaseContext 返回的就是这个 mBase. ContextThemeWrapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175/** * A context wrapper that allows you to modify or replace the theme of the * wrapped context. */public class ContextThemeWrapper extends ContextWrapper &#123; private int mThemeResource; private Resources.Theme mTheme; private LayoutInflater mInflater; private Configuration mOverrideConfiguration; private Resources mResources; /** * Creates a new context wrapper with no theme and no base context. * &lt;p class="note"&gt; * &lt;strong&gt;Note:&lt;/strong&gt; A base context &lt;strong&gt;must&lt;/strong&gt; be attached * using &#123;@link #attachBaseContext(Context)&#125; before calling any other * method on the newly constructed context wrapper. */ public ContextThemeWrapper() &#123; super(null); &#125; /** * Creates a new context wrapper with the specified theme. * &lt;p&gt; * The specified theme will be applied on top of the base context's theme. * Any attributes not explicitly defined in the theme identified by * &lt;var&gt;themeResId&lt;/var&gt; will retain their original values. * * @param base the base context * @param themeResId the resource ID of the theme to be applied on top of * the base context's theme */ public ContextThemeWrapper(Context base, @StyleRes int themeResId) &#123; super(base); mThemeResource = themeResId; &#125; /** * Creates a new context wrapper with the specified theme. * &lt;p&gt; * Unlike &#123;@link #ContextThemeWrapper(Context, int)&#125;, the theme passed to * this constructor will completely replace the base context's theme. * * @param base the base context * @param theme the theme against which resources should be inflated */ public ContextThemeWrapper(Context base, Resources.Theme theme) &#123; super(base); mTheme = theme; &#125; @Override protected void attachBaseContext(Context newBase) &#123; super.attachBaseContext(newBase); &#125; /** * Call to set an "override configuration" on this context -- this is * a configuration that replies one or more values of the standard * configuration that is applied to the context. See * &#123;@link Context#createConfigurationContext(Configuration)&#125; for more * information. * * &lt;p&gt;This method can only be called once, and must be called before any * calls to &#123;@link #getResources()&#125; or &#123;@link #getAssets()&#125; are made. */ public void applyOverrideConfiguration(Configuration overrideConfiguration) &#123; if (mResources != null) &#123; throw new IllegalStateException( "getResources() or getAssets() has already been called"); &#125; if (mOverrideConfiguration != null) &#123; throw new IllegalStateException("Override configuration has already been set"); &#125; mOverrideConfiguration = new Configuration(overrideConfiguration); &#125; /** * Used by ActivityThread to apply the overridden configuration to onConfigurationChange * callbacks. * @hide */ public Configuration getOverrideConfiguration() &#123; return mOverrideConfiguration; &#125; @Override public AssetManager getAssets() &#123; // Ensure we're returning assets with the correct configuration. return getResourcesInternal().getAssets(); &#125; @Override public Resources getResources() &#123; return getResourcesInternal(); &#125; private Resources getResourcesInternal() &#123; if (mResources == null) &#123; if (mOverrideConfiguration == null) &#123; mResources = super.getResources(); &#125; else &#123; final Context resContext = createConfigurationContext(mOverrideConfiguration); mResources = resContext.getResources(); &#125; &#125; return mResources; &#125; @Override public void setTheme(int resid) &#123; if (mThemeResource != resid) &#123; mThemeResource = resid; initializeTheme(); &#125; &#125; /** @hide */ @Override public int getThemeResId() &#123; return mThemeResource; &#125; @Override public Resources.Theme getTheme() &#123; if (mTheme != null) &#123; return mTheme; &#125; mThemeResource = Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion); initializeTheme(); return mTheme; &#125; @Override public Object getSystemService(String name) &#123; if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123; if (mInflater == null) &#123; mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this); &#125; return mInflater; &#125; return getBaseContext().getSystemService(name); &#125; /** * Called by &#123;@link #setTheme&#125; and &#123;@link #getTheme&#125; to apply a theme * resource to the current Theme object. May be overridden to change the * default (simple) behavior. This method will not be called in multiple * threads simultaneously. * * @param theme the theme being modified * @param resId the style resource being applied to &lt;var&gt;theme&lt;/var&gt; * @param first &#123;@code true&#125; if this is the first time a style is being * applied to &lt;var&gt;theme&lt;/var&gt; */ protected void onApplyThemeResource(Resources.Theme theme, int resId, boolean first) &#123; theme.applyStyle(resId, true); &#125; private void initializeTheme() &#123; final boolean first = mTheme == null; if (first) &#123; mTheme = getResources().newTheme(); final Resources.Theme theme = getBaseContext().getTheme(); if (theme != null) &#123; mTheme.setTo(theme); &#125; &#125; onApplyThemeResource(mTheme, mThemeResource, first); &#125;&#125; 结合注释及源码，可以发现，相比 ContextWrapper, ContextThemeWrapper 有自己的另外的Resource以及 Theme 成员，并且可以传入配置信息以初始化自己的 Resource 及 Theme. ContextThemeWrapper 和它的mBase 成员在 Resource 以及 Theme 相关的行为上是不同的。 ContextImplContextImpl 和 ContextThemeWrapper 最大的区别就是没有一个 Configuration. 其它的行为大致一样。 另外 ContextImpl 可以用于创建 Activity Service 的 mBase 成员，这个 mBase context 除了参数不同，它们的 Resource 也不同， 需要注意的是， createActivityContext等方法中 setResource 是 mBase 自己调用的， Activity, service 以及 Application 本身并没有执行 setResource. 总结 ContextWrapper, ContextThemeWrapper 都是 Context 的代理类，二者的区别在于 ContextThemeWrapper 有自己的 Theme 以及 Resource,并且 Resource 可以传入自己配置初始化 ContextImpl 是 Context 主要实现类， Activity, Service 和 Application 的 Base contex都是由他创建的，即 ContextWrapper 代理的就是 ContextImpl 对象本身]]></content>
      <tags>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView刷新机制]]></title>
    <url>%2F2018%2F12%2F24%2FRecyclerView%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[掘金博客记录 adapter.notifyDataSetChanaged() 引起的刷新 我们假设 recycleView 的初始状态是没有数据的，然后往数据源中加入数据后，调用 adapter.notifyDataSetChanged() 来引起RecyclerView 的刷新： 12data.addAll(data)adapter.notifyDataSetChanged() adapter.notifyDataSetChanged() 时，会引起 recycleView 重新布局（requestLayout）.因此从 onLayout() 方法开始： 1234567@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true; &#125; 这个方法直接调用了 dispatchLayout(): 12345678910111213141516171819202122232425262728void dispatchLayout() &#123; if (mAdapter == null) &#123; Log.e(TAG, "No adapter attached; skipping layout"); // leave the state in START return; &#125; if (mLayout == null) &#123; Log.e(TAG, "No layout manager attached; skipping layout"); // leave the state in START return; &#125; mState.mIsMeasuring = false; if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; // First 2 steps are done in onMeasure but looks like we have to run again due to // changed size. mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3(); &#125; 缩写为： 12345678910void dispatchLayout() &#123; ... if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); dispatchLayoutStep2(); &#125; else if (数据变化 || 布局变化) &#123; dispatchLayoutStep2(); &#125; dispatchLayoutStep3();&#125; 上面是裁掉了一些代码，可以看到整个布局过程总共分为3步，下面3步对应的方法： 123STEP_START----&gt;dispatchLayoutStep1()STEP_LAYOUT----&gt;dispatchLayoutStep2()STEP_ANIMATIONS----&gt;dispatchLayoutStep2(),dispatchLayoutStep3() 第一步：STEP_START 12345678910/** * The first step of a layout where we; * - process adapter updates 更新adapter * - decide which animation should run 确定哪个动画应该运行 * - save information about current views 保存当前views的信息 * - If necessary, run predictive layout and save its information */ private void dispatchLayoutStep1() &#123; ..... &#125; 第二步： 12345678910111213141516171819202122232425262728/**确定view的真正状态 * The second layout step where we do the actual layout of the views for the final state. 这步可能会执行多次如果necessary * This step might be run multiple times if necessary (e.g. measure). */ private void dispatchLayoutStep2() &#123; startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); //设置好初始状态 mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; // Step 2: Run layout 调用布局管理器布局 mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; mPendingSavedState = null; // onLayoutChildren may have caused client code to disable item animations; re-check mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; mState.mLayoutStep = State.STEP_ANIMATIONS;//接下来执行布局的第三步 onExitLayoutOrScroll(); stopInterceptRequestLayout(false); &#125; 这里有一个 mState, 它是 一个 RecyclerView.State 对象。顾名思义它是用来保存 RecyclerView 状态的一个对象，主要是用在 LayoutManager Adapter 组件之间共享 recyclerView 状态的。可以看到这个方法将布局交给了 mLayout. 就是指的是 LineaLayoutManager. 因此接下来看下：LinearLayoutManager.onLayoutChildren(): LinearLayoutManager.onLayoutChildren() 这个方法比较长，就不展示具体源码。 12345678910111213@Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; // layout algorithm: 布局算法 1.检查children 和其它变量，找到锚坐标和锚 // 1) by checking children and other variables, find an anchor coordinate and an anchor // item position. item位置 2.开始填充，从底部开始 // 2) fill towards start, stacking from bottom 3.填充 // 3) fill towards end, stacking from top 4.滚动满足要求像从底部填充一样 // 4) scroll to fulfill requirements like stack from bottom. // create layout state 确定锚点View 锚点View的确定通过： updateAnchorInfoForLayout 123456789101112// calculate anchor position and coordinate updateAnchorInfoForLayout(recycler, state, mAnchorInfo);private boolean updateAnchorFromChildren(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorInfo) &#123; .... View referenceChild = anchorInfo.mLayoutFromEnd //如果是从end(尾部)位置开始布局，那就找最接近end的那个位置的view作为锚点View ? findReferenceChildClosestToEnd(recycler, state) ////如果是从start(尾部)位置开始布局，那就找最接近start的那个位置的view作为锚点View : findReferenceChildClosestToStart(recycler, state);&#125; AnchorInfo 最重要的两个属性是; mCoordinate 和 mPosition. 找到锚点 View 后就会通过anchorInfo.assignFromView() 方法来设置这两个属性： 12345678910public void assignFromView(View child, int position) &#123; if (mLayoutFromEnd) &#123; mCoordinate = mOrientationHelper.getDecoratedEnd(child) + mOrientationHelper.getTotalSpaceChange(); &#125; else &#123; mCoordinate = mOrientationHelper.getDecoratedStart(child); &#125; mPosition = position; &#125; 12mCoordinate: 就是锚点View的 Y(x) 坐标去掉 RecycleView 的 padding.mPosition: 其实就是 锚点View的位置 当确定好 AnchorInfo 后，需要根据 AnchorInfo 来确定 RecycleView 当前可用于布局的空间，然后来摆放子View。以布局方向为 start to end 正常方向为例，这里的锚点View其实就是 RecyclerView最顶部的 View： 12345678910// fill towards end (1) updateLayoutStateToFillEnd(mAnchorInfo); //确定AnchorView到RecyclerView的底部的布局可用空间 ... fill(recycler, mLayoutState, state, false); //填充view, 从 AnchorView 到RecyclerView的底部 endOffset = mLayoutState.mOffset; // fill towards start (2) updateLayoutStateToFillStart(mAnchorInfo); //确定AnchorView到RecyclerView的顶部的布局可用空间 ... fill(recycler, mLayoutState, state, false); //填充view,从 AnchorView 到RecyclerView的顶部 上面我标注了（1）（2），1次布局是由这两部分组成的，具体如下图： fill towards end 确定可用布局空间 在 fill 之前，需要先确定 从锚点View 到 RecyclerView 底部有多少可用空间。是通过 updateLayoutStateToFillEnd 方法： 12345678910updateLayoutStateToFillEnd(anchorInfo.mPosition, anchorInfo.mCoordinate);void updateLayoutStateToFillEnd(int itemPosition, int offset) &#123; mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - offset; ... mLayoutState.mCurrentPosition = itemPosition; mLayoutState.mLayoutDirection = LayoutState.LAYOUT_END; mLayoutState.mOffset = offset; mLayoutState.mScrollingOffset = LayoutState.SCROLLING_OFFSET_NaN;&#125; mLayoutState 是 LinearLayoutmanager 用来保存布局状态的一个对象。 mLayoutState.mAvailable 就是用来表示 有多少空间可用布局。mOrientationHelper.getEndAfterPadding() - offset 其实大致可以理解为RecycleView 的高度。所以这里可用布局空间 mLayoutState.mAvailable 就是 ReycleView 的高度。 摆放子View 接下来继续看 LinearLayoutManager.fill() 方法，这个方法是布局的核心方法，是用来向 RecycleView 中添加子View的方法： 12345678910111213141516171819202122232425262728293031323334353637383940int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; // max offset we should set is mFastScroll + available final int start = layoutState.mAvailable;//可用高度就是RecyclerView的高度 if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123; // TODO ugly bug fix. should not happen if (layoutState.mAvailable &lt; 0) &#123; layoutState.mScrollingOffset += layoutState.mAvailable; &#125; recycleByLayoutState(recycler, layoutState); &#125; int remainingSpace = layoutState.mAvailable + layoutState.mExtra; //保存布局一个child view后的结果 LayoutChunkResult layoutChunkResult = mLayoutChunkResult; while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; //有剩余空间的话，就一直添加 childView layoutChunkResult.resetInternal(); if (VERBOSE_TRACING) &#123; TraceCompat.beginSection("LLM LayoutChunk"); &#125; //布局子View的核心方法 layoutChunk(recycler, state, layoutState, layoutChunkResult); if (VERBOSE_TRACING) &#123; TraceCompat.endSection(); &#125; if (layoutChunkResult.mFinished) &#123; break; &#125; //一次layoutchunk 消耗了多少空间 layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; /** * Consume the available space if: * * layoutChunk did not request to be ignored * * OR we are laying out scrap children * * OR we are not doing pre-layout */ 回收可用空间.... return start - layoutState.mAvailable; &#125; 这个方法的核心就是调用 layoutChunk() 来不断消耗layoutState.mAvailable 直到消耗完毕，继续看下 layoutChunk() 方法： 123456789101112131415void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); //这个方法会向 recycler view 要一个holder ... if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; //根据布局方向，添加到不同的位置 addView(view); //添加到 RecyclerView 中 &#125; else &#123; addView(view, 0); &#125; measureChildWithMargins(view, 0, 0); //调用view的measure ...measure后确定布局参数 left/top/right/bottom layoutDecoratedWithMargins(view, left, top, right, bottom); //调用view的layout ... &#125; 到这里其实就完成了上面的 fill towards end: 123updateLayoutStateToFillEnd(mAnchorInfo)// 确定布局可用空间fill(recycler,mLayoutState,state,false)// 填充View fill towards start 就是从 锚点View 向 RecycleView 顶部来摆放子View，具体逻辑类似 fill towards end. RecyclerView 滑动时的刷新逻辑 在不加载新的数据情况下， RecycleView 在滑动时是如何展示 子View的，即下面这种状态： 下面就来分析一个 3，4 和 12，13是如何展示的。 RecycleView 在 OnTouchEvent 对滑动事件做了监听，然后派发到 scrollStep() 方法：]]></content>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread源码]]></title>
    <url>%2F2018%2F12%2F20%2FHandlerThread%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425/** * Handy class for starting a new thread that has a looper. The looper can then be * used to create handler classes. Note that start() must still be called. */开启一个线程内部有一个looper, 这个looper可以用来创建handler. 切记一定要调用start方法.public class HandlerThread extends Thread &#123; .....&#125;public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125;@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 其实我们初始化和启动了一个线程，既然是线程那就看 run 方法， run 方法中创建了 Looper 对象，然后设置线程等级，开启循环 loop() .]]></content>
      <tags>
        <tag>handlerThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程保活大法]]></title>
    <url>%2F2018%2F12%2F19%2F%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%A4%A7%E6%B3%95%2F</url>
    <content type="text"><![CDATA[收集整理android 进程保活方法 1像素Activity 注册监听屏幕开启和屏幕关闭时的广播，当屏幕关闭时，开启1像素的 Activity, 当屏幕开启时，关闭1像素的 Activity. 查看进程等级 可以在studio 终端进行命令行, pid 进程id 123adb shellsucat proc/&#123;pid&#125;/oom_adj OnePxActivity 1234567891011121314151617181920212223242526272829303132public class OnePxActivity extends AppCompatActivity &#123; public static void launch(Context context)&#123; Intent intent = new Intent(context,OnePxActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.i("qq","OnPxActivity onCreate........."); Window window = getWindow(); window.setGravity(Gravity.START | Gravity.TOP); WindowManager.LayoutParams params = window.getAttributes(); params.x = 0; params.y = 0; params.width = 1; params.height = 1; window.setAttributes(params); KeepAliveManager.getInstance().setKeepAliveManager(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.i("qq","OnPxActivity onDestroy........."); &#125;&#125; 广播 ： 监听开启/关闭的广播 1234567891011121314151617public class KeepAliveReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals(Intent.ACTION_SCREEN_ON))&#123; //屏幕点亮 Log.i("qq","收到屏幕开启广播"); KeepAliveManager.getInstance().finishOnePxActivity(context); &#125;else if(intent.getAction().equals(Intent.ACTION_SCREEN_OFF))&#123; //屏幕熄灭, 启动activity Log.i("qq","收到屏幕关闭广播"); KeepAliveManager.getInstance().startOnePxActivity(context); &#125; &#125;&#125; 辅助类：KeepAliveManager 1234567891011121314151617181920212223242526272829303132333435363738public class KeepAliveManager &#123; private KeepAliveManager()&#123;&#125; private static KeepAliveManager mInstance = new KeepAliveManager(); private WeakReference&lt;OnePxActivity&gt; mReference; public void setKeepAliveManager(OnePxActivity activity)&#123; this.mReference = new WeakReference&lt;&gt;(activity); &#125; public static KeepAliveManager getInstance()&#123; return mInstance; &#125; public void startOnePxActivity(Context context)&#123; OnePxActivity.launch(context); &#125; public void finishOnePxActivity(Context context)&#123; if(null != mReference &amp;&amp; mReference.get() != null)&#123; mReference.get().finish(); &#125; &#125; private KeepAliveReceiver mReceiver; public void registerReceiver(Context context)&#123; this.mReceiver = new KeepAliveReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_SCREEN_ON); context.registerReceiver(mReceiver,filter); &#125; public void unregisterReceiver(Context context)&#123; if(null != mReceiver)&#123; context.unregisterReceiver(mReceiver); &#125; &#125;&#125; MainActivity 使用： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //第一种方式 KeepAliveManager.getInstance().registerReceiver(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); KeepAliveManager.getInstance().unregisterReceiver(this); &#125;&#125; 亲身实践了，发现确实oom_adj 变小，被杀死的概率比较低了，当屏幕变暗的时候。 前台服务ForegroundService.java : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ForgroundService extends Service &#123; private final int SERVICE_ID = 1; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if(Build.VERSION.SDK_INT &lt; 18)&#123; //设置成前台服务，并且不显示通知栏消息 startForeground(SERVICE_ID,new Notification()); &#125;else if(Build.VERSION.SDK_INT &lt; 26)&#123; startForeground(SERVICE_ID,new Notification()); startService(new Intent(this,InnerService.class)); &#125;else&#123;//android 8.0 NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); if(manager != null)&#123; NotificationChannel channel = new NotificationChannel("channel","name",NotificationManager.IMPORTANCE_NONE); manager.createNotificationChannel(channel); NotificationCompat.Builder builder = new NotificationCompat.Builder(this,"channel"); //设置成前台服务，Android9.0 会有通知栏消息，需要添加新的权限 //&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE"/&gt; startForeground(SERVICE_ID,builder.build()); &#125; &#125; return super.onStartCommand(intent, flags, startId); &#125; class InnerService extends Service&#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startForeground(SERVICE_ID,new Notification()); stopForeground(true); stopSelf(); return super.onStartCommand(intent, flags, startId); &#125; &#125;&#125; 双进程守护 后续补上…]]></content>
      <tags>
        <tag>进程保活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[INSTALL_FAILED_TEST_ONLY]]></title>
    <url>%2F2018%2F12%2F17%2FINSTALL-FAILED-TEST-ONLY%2F</url>
    <content type="text"><![CDATA[莫名其妙更新了 studio的配置，然后打包签名，利用adb install xx.apk 安装就出现了 INSTALL_FAILED_TEST_ONLY,安装失败。心想也没干什么啊，查阅相关资料后，原因是：Android Studio 3.0会在debug apk的manifest文件application标签里自动添加 android:testOnly=&quot;true&quot;属性 网上有说：将这个android:testOnly=&quot;false&quot; 添加到 Application 标签中，但是还是没有成功。 解决办法一： 1adb install -t xx.apk 需要加上-t. 问题是解决了，可以安装成功了，但是对于以前qq 发送文件还是不能安装成功。 解决办法二：还是点击普通的绿色按钮安装，此时生成一个apk,我们再点击 Build---&gt; Build Apk 此时拿出 output--&gt;apk--&gt;xx.apk 可以正常安装了。]]></content>
      <tags>
        <tag>studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moved Permanently]]></title>
    <url>%2F2018%2F12%2F14%2FMoved-Permanently%2F</url>
    <content type="text"><![CDATA[关于下载文件中包含重定向问题的解决方案。之前下载文件没问题，但是今天遇到一个下载文件里包含重定向，还是用之前的下载文件的方法就不行了，默认浏览器打开下载，是自动重定向的。 这是我以前的下载文件的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class DownloadTask extends AsyncTask&lt;String, Integer, String&gt; &#123; @Override protected String doInBackground(String... params) &#123; String result = ""; OutputStream output = null; try &#123; URL url = new URL(params[0]); // 创建一个HttpURLConnection连接 URLConnection urlConn = (URLConnection ) url .openConnection(); InputStream input = urlConn.getInputStream(); // 文件夹 File dir = new File(Constant.K0_VOICE_DIR); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 本地文件 File file = new File(Constant.K0_VOICE_DIR + params[1]); if (!file.exists()) &#123; file.createNewFile(); // 写入本地 output = new FileOutputStream(file); result = file.getAbsolutePath(); byte buffer[] = new byte[4*1024]; int inputSize = -1; while ((inputSize = input.read(buffer)) != -1) &#123; output.write(buffer, 0, inputSize); &#125; output.flush(); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; output.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected void onPostExecute(String result) &#123; //下载完成..... super.onPostExecute(result); &#125; &#125; 按照这个下载，你会发现下载的例如mp3 会无法播放，点开查看：1&lt; a href=&quot;https:xxxx&quot;&gt;Moved Permanently&lt;/ a&gt;. href 里包含一个新的链接。需要添加如下代码，获取新的链接地址下载：1234567 URLConnection urlConn = (URLConnection ) url .openConnection();//下载的文件中含有重定向链接 String redirect = urlConn.getHeaderField(&quot;Location&quot;); if (redirect != null)&#123; urlConn = new URL(redirect).openConnection(); &#125; 奉上我在 stackoverflow 上找到的答案：]]></content>
      <tags>
        <tag>Moved Permanently</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp初探]]></title>
    <url>%2F2018%2F12%2F12%2Fokhttp%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[使用依赖最新的版本 implementation(&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;) 网站：https://square.github.io/okhttp/ get 请求1234567891011public String getRequests() throws IOException &#123; OkHttpClient client = new OkHttpClient(); String url = "http://www.baidu.com"; Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); &#125; put 请求123456789101112131415final MediaType JSON = MediaType.parse("application/json; charset=utf-8"); String json = "http://www.roundsapp.com/post"; String url = bowlingJson("Jesse","Jake");//json字符串 OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(JSON,json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string(); 总结 1.创建 OkHttpClient 对象 2.创建 Request 3.同步或者异步发出请求 4.得到 Response 同步执行： 12345678910111213141516171819202122232425@Override public Response execute() throws IOException &#123; //1.判断是否执行过，每个Call请求只能请求一次，如果需要重复执行可以使用clone 方法 synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; //2.获取分发器 dispatcher, 执行 execute client.dispatcher().executed(this); //3.获取网络请求的结果 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; //4.最后通知 dispatcher 执行完毕 client.dispatcher().finished(this); &#125; &#125; clone 方法： 123@Override public RealCall clone() &#123; return RealCall.newRealCall(client, originalRequest, forWebSocket); &#125; Dispatcher.java 12//当异步线程执行时，会依照不同的策略执行* Policy on when async requests are executed. 拦截器OkHttpClinet 拿到返回结果，是通过 getResponseWithInterceptorChain() 方法，从名字上我们可以大概猜测方法的语义，通过一系列的拦截器链得到结果，我们可以看下这个方法： 1234567891011121314151617181920212223242526Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors.一个集合存储所有的拦截器啊 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //用户自定义的拦截器，能拦截所有的请求 interceptors.addAll(client.interceptors()); //猜测是重试机制 interceptors.add(retryAndFollowUpInterceptor); //请求的头信息，cookie,gzip interceptors.add(new BridgeInterceptor(client.cookieJar())); //猜测是缓存 interceptors.add(new CacheInterceptor(client.internalCache())); //开始与目标服务器建立连接，获得RealConnection interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; //用户自定义的 interceptor, 仅在生产网络请求时生效 interceptors.addAll(client.networkInterceptors());//猜测是网络请求 &#125; //向服务器发出一次网络请求的地方 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125; Interceptor 是 OkHttp 最核心的一个东西，采用了责任链的设计模式，除了日常负责拦截请求进行一些额外处理，例如 cookie, 实际上它把网络请求，缓存，透明压缩等功能都统一在一起，每个功能都是一个 Interceptor , 它们再连接称为 Intercepteor.Chain 拦截链条，环环相扣，最终完成一次网络请求。 RealInterceptorChain.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * A concrete interceptor chain that carries the entire interceptor chain: all application * interceptors, the OkHttp core, all network interceptors, and finally the network caller. */public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors;//所有的拦截器集合 private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private final Call call; private final EventListener eventListener; private final int connectTimeout; private final int readTimeout; private final int writeTimeout; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call, EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; this.call = call; this.eventListener = eventListener; this.connectTimeout = connectTimeout; this.readTimeout = readTimeout; this.writeTimeout = writeTimeout; &#125; @Override public Connection connection() &#123; return connection; &#125; @Override public int connectTimeoutMillis() &#123; return connectTimeout; &#125; @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration("timeout", timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, millis, readTimeout, writeTimeout); &#125; @Override public int readTimeoutMillis() &#123; return readTimeout; &#125; @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration("timeout", timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, millis, writeTimeout); &#125; @Override public int writeTimeoutMillis() &#123; return writeTimeout; &#125; @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration("timeout", timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, readTimeout, millis); &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Call call() &#123; return call; &#125; public EventListener eventListener() &#123; return eventListener; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must retain the same host and port"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must call proceed() exactly once"); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException("network interceptor " + interceptor + " must call proceed() exactly once"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException("interceptor " + interceptor + " returned null"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( "interceptor " + interceptor + " returned a response with no body"); &#125; return response; &#125;&#125; 这个方法我没看懂，网上说是传递参数和执行拦截器，并且设定条件，每个拦截器都会执行 proceed 方法。 拦截器：RetryAndFollowUpInterceptor.java 1234567891011121314151617181920212223242526/** * This interceptor recovers from failures and follows redirects as necessary. It may throw an * &#123;@link IOException&#125; if the call was canceled. 这个拦截器必要时会重试和重定向，可能会抛出异常在call被取消的时候 */public final class RetryAndFollowUpInterceptor implements Interceptor &#123;.... @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123;//被取消 streamAllocation.release(); throw new IOException("Canceled"); &#125;&#125; BridgeInterceptor.java 基本上请求的头信息，Cookie 压缩: gzip 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Bridges from application code to network code. First it builds a network request from a user * request. Then it proceeds to call the network. Finally it builds a user response from the network * response. */public final class BridgeInterceptor implements Interceptor &#123; private final CookieJar cookieJar; @Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header("Content-Type", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header("Content-Length", Long.toString(contentLength)); requestBuilder.removeHeader("Transfer-Encoding"); &#125; else &#123; requestBuilder.header("Transfer-Encoding", "chunked"); requestBuilder.removeHeader("Content-Length"); &#125; &#125; if (userRequest.header("Host") == null) &#123; requestBuilder.header("Host", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header("Connection") == null) &#123; requestBuilder.header("Connection", "Keep-Alive"); &#125; // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header("Accept-Encoding") == null &amp;&amp; userRequest.header("Range") == null) &#123; transparentGzip = true; requestBuilder.header("Accept-Encoding", "gzip"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header("Cookie", cookieHeader(cookies)); &#125; if (userRequest.header("User-Agent") == null) &#123; requestBuilder.header("User-Agent", Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll("Content-Encoding") .removeAll("Content-Length") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header("Content-Type"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; CacheInterceptor.java 缓存信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** Serves requests from the cache and writes responses to the cache. */public final class CacheInterceptor implements Interceptor &#123; final InternalCache cache; public CacheInterceptor(InternalCache cache) &#123; this.cache = cache; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; //从缓存中获取 response Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; ..... 连接池 okHttp 利用连接池来复用连接，避免反复握手建立连接，并且具备在合适的时候挥手连接的能力。]]></content>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS机制]]></title>
    <url>%2F2018%2F12%2F11%2FCAS%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[背景介绍：CAS 完整名称为 ： “Compare and Swap” 比较并替换。 里面涉及三个基本操作数，内存地址值：V；旧的预期值：A；新的预期值：B。 规则：当更新变量时，只有当内存地址里的值V = 旧的预期值A，才能被成功的更新为B。 举个例子: 在内存地址V中，存在一个变量值为10的值： 此时线程一，线程二 ，同时去操作这个变量，例如都想+1； 对于线程一来说： A：10； B: 11； V: 10 但是由于线程二比线程一执行的更快，此时线程二已经把内存地址V中的10更新为11. ​ 那么当线程一再次执行更新操作，发现 V = 11,A = 10, V≠A，更新失败。 ​ 此时线程一需要重新读取内存中的值，并重新计算要更新的新值，计算后得出： ​ A= 11，B= 12. 重新提交请求，这个过程称为自旋。 ​ 首先Compare V== A， 然后进行swap , V = 12，被更新为12. 从思想上来说，syncronized 属于悲观锁，认为并发情况非常严重，CAS 机制属于乐观锁，认为并发情况并不是一种特别严重的情况，发生问题，不断尝试更新即可。 使用场景：Atomic系列类，以及Lock系列类的底层实现；不适合高并发的场景，高并发还是 syncronized 缺点 CPU消耗大 如果在多个线程并发去更新一个变量，多个线程同时去重复尝试更新某一个变量，却又一直不成功，循环往复就会给CPU造成很大的压力。 不能保证代码块的原子性 CAS 可以保证一个变量的原子性，却无法保证整个代码块的原子性。 ABA问题—–最大的问题 ABA 问题举例说明： 假设有三个线程都要对内存地址V 中的 A 进行操作， 线程一：旧的预期值：A；新的预期值：B 线程二：旧的预期值：A；新的预期值：B 线程三：还未开始工作 线程一首先进行了操作，顺利将A更新为B： 此时线程三上来了，它是：旧的预期值：B；新的预期值：A，此时发现： ​ V(B) == B(B)，更新成功，变为图下： 此时线程二开始工作，线程二的目标是：旧的预期值：A；新的预期值：B，同样一比对，相同，于是也更新成功，变为如下： 虽然从结果上来看，A 成功的变为 B，然后在实际涉及钱的时候，问题就大了。 再次举例： 小明银行卡里有200块钱，想取出100块钱，但是由于设备故障，提交了两次扣款申请。 扣款申请1：旧的预估值：200，新的预估值：100 扣款申请2：旧的预估值：200，新的预估值：100 此时，扣款申请1提前进行了操作，扣款成功，小明银行卡里为100块钱； 扣款申请2假设还在等待。//block 此时小明的妈妈给小明存储100元，ok, 现在小明银行卡里就是200块钱。 扣款申请2恢复正常，开始必对，旧的预估值：200，卡里余额200，成功，替换更新为100. 更新成功，那么此时小明银行卡里剩余金额：100块。 哈哈！！！这显然是不对的，虽然值相同，但是中间操作改变了最终的结果。那如何解决这个问题呢？可以利用版本号，每修改成功一次V，都要设置一个版本号。每次更新的时候，不但要比对值还要比对版本号，就可以避免这种错误。 好，就上面的例子说明下： 当扣款申请1完成更新操作时，我们设置内存地址V中的值的版本号为：：01 第二次操作：妈妈成功向卡里存入了100块 扣款申请2开始工作： 旧的预估值：200，新的预估值：100；版本号为00 而此时：V（200）= 旧的预估值（200）成立 ​ 版本号（00） ≠ version（02） 不成立]]></content>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap 高并发导致的死循环]]></title>
    <url>%2F2018%2F12%2F07%2FHashMap-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j];//src 表示原table while(null != e) &#123; //此处表示取出下一个位置的Entry(键值对) Entry&lt;K&lt;V&gt; next = e.next; //计算得出在扩容后新数组table中的下标，因为扩容后要重新计算下标 //未扩容前下标:index = hash(key) &amp; (length-1) int i= indexFor(e.hash,newCapacity); //根据下标取出在新表newTable中的Entry&lt;K,V&gt; e.next = newTable[i]; //将当前e 赋值给newTable[i](Entry&lt;K,V&gt;) newTable[i] = e; //将下一个next.Entry 赋值给当前的e e = next; &#125;&#125; 举例说明下： 原 table的信息排列是： 再次添加新元素的时候就需要扩容了，此时我们来类比下上述的代码： 12345678910111213141516171819for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j];//src 表示原table while(null != e) &#123; //next = Entry2 Entry&lt;K&lt;V&gt; next = e.next; //假设计算结果为3；循环第二次：假设Entry2计算的位置也是3 int i= indexFor(e.hash,newCapacity); //第一次Entry1.next = newTable[3]，此时newTable[3]还为null；所以是Entry1.next地址指向null //循环第二次：Entry2.next = Entry1 e.next = newTable[i]; //newTable[3] = Entry1, 此时e是 Entry1; //循环第二次： newTable[3] = Entry2 newTable[i] = e; //Entry1 = Entry2,e 指向了Entry2,好再次循环; //循环第二次：e = null,跳出循环 e = next; &#125;&#125; 变成如下： 上述是属于正常情况的那种，假设我们现在有两个线程同时去 put 元素，二者均发现需要做扩容处理，那么又会出现什么情况呢？ 参考阅读网上的博客+自己理解记录 当线程一 和 线程二 同时进行插入的时候刚好达到扩容的条件，然后同时开始进行 Resize 操作。 1234567891011for (int j = 0; j &lt; src.length; ++j) &#123; //src 表示原table Entry&lt;K,V&gt; e = src[j]; while(null != e) &#123; Entry&lt;K&lt;V&gt; next = e.next;//假设线程一执行到这里就被调度挂起了 int i= indexFor(e.hash,newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125;&#125; 线程一挂起，线程二继续操作，变成如下： 线程二是 rehash 之后的样子，如上图： 当前线程一来说： e 是: key(3) next 是： key(7) 线程一来了，被调度回来了，该人家执行了： 123456789101112131415161718while(null != e) &#123;//再次循环，e:key(7) next:key(3) //假设线程一执行到这里就被调度挂起了,开始继续执行 //第二次循环：next = key(3),next 指向key(3) //e:key(3) next:null Entry&lt;K&lt;V&gt; next = e.next; int i= indexFor(e.hash,newCapacity);//根据线程二的计算不难推出线程一计算的i = 3 //key(7).next 指向 key(3) //key(3).next 指向 key(7) e.next = newTable[i]; //first : newTable[3] = key(3) //second ： newTable[3] = key(7) //third : newTable[3] = key(3) newTable[i] = e; //e 指向key(7) //e = key(3) //e = null//退出循环 e = next 这样就产生死循环了。 12key(7).next 指向 key(3)key(3).next 指向 key(7) 当我们取出一个key(5) 的一个值时，恰巧也是 int i = 3 , 这样去取，就陷入key(3),key(7) 的死循环中去了。 为了更清晰的展示每一次循环，我决定分开来展示： 第一次：要从这个线程一恢复运行开始说起吧： e: key(3) ; next: key(7) 123456789101112while(null != e) &#123; Entry&lt;K&lt;V&gt; next = e.next;//第一次的时候，线程一被卡住在这里，当时状态是：e:key(3),next:key(7) 这应该都没什么问题 //根据线程二的计算，这个值也应该是int i = 3 int i= indexFor(e.hash,newCapacity); //key(3).next = newTable[3], 此时newTable[3]为null, key(3).next指向null e.next = newTable[i]; //newTable[3] = key(3) newTable[i] = e; //e = key(7),e指向key(7) e = next&#125; OK, 由于e = key(7) 不为null ,循环继续： 第二次循环：经过上述循环，此时 e: key(7),next: key(3) 由于线程二已经改变了这个整体table 的结构，当遍历到key(7) 时， next: key(3) 123456789101112while(null != e) &#123;//e:key(7) //next = key(3) Entry&lt;K&lt;V&gt; next = e.next; //int i = 3 int i= indexFor(e.hash,newCapacity); //key(7).next = key(3) , key(7).next指向key(3) e.next = newTable[i]; //newTable[3] = key(7) newTable[i] = e; //e = key(3) e指向key(3),不为null,循环继续 e = next&#125; 第三次循环：e : key(3) next:null 123456789101112while(null != e) &#123;//e:key(3) //next = null next指向null Entry&lt;K&lt;V&gt; next = e.next; //int i = 3 int i= indexFor(e.hash,newCapacity); //key(3).next = key(7) key(3).next指向key(7) e.next = newTable[i]; //newTable[3] = key(3) newTable[i] = e; //e = null, 循环结束 e = next&#125; 此时 e : null, next:null. 12//key(7).next指向key(3)//key(3).next指向key(7) 这里产生死循环 图就是这样的：最后newTable[3] = key(3) over.]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap基本知识]]></title>
    <url>%2F2018%2F12%2F06%2FHashMap%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[自我总结 什么是 HashMap?首先看下类继承关系： HashMap 是存储键值对的集合，一个 key–value , 这样的键值对也称为 Entry ，这些键值对分散存储于数组当中，组成 HashMap 的主干。 特点 其中 key 可为 null ；非线程安全； 其中 put 方法 和 get 方法比较重要。 put 方法 12345678910111213public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); ..... &#125; 首先根据 key 计算 hash 值 , 如何算出在 Node 数组中具体的下标呢？从上面代码我们可以大概看出： 1i = (n-1) &amp; hash 就是数组的长度 -1 &amp; key 的hash 值。 得到数组下标后，再把这个键值对放入进去，完成了 put 操作。 假设我们： put(“qq”,”糖葫芦”) hash(&quot;qq&quot;) = 2, 下标为2，那么结果如下： Entry1====&gt; [key = &quot;qq&quot;, value= &quot;糖葫芦&quot;] 但是总会有那么一种情况，就是不同 key 计算的 hash 之后是相同的，假如我们新 put(&quot;mi&quot;,value=&quot;milo&quot;) index = hash(&quot;mi&quot;) = 2 也是数组下标为2，那么此时在下标为2的位置就会通过 链表 的形式存储相应的键值对。 HashMap 数组的每一个元素不止是一个Entry 对象，也是一个链表的头节点。每一个Entry对象通过 Next 指针指向它的下个 Entry 节点。当再有新的 Entry 映射到这个冲突位置时，也就是计算出 hash 值也是2，只需要插入到对应的链表当中去即可，注意：新插入的会在之前的前面，称为 头插入， 被新 put 进入的新元素可能被用到的概率大一些。 get 方法 了解了 put 方法，get 好理解些 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; 第一步：同样 根据 key 算出 hash 值； 第二步：根据 hash值和数组的长度 计算数组的下标 index 第三步：假设我们取出我们 get(&quot;qq&quot;) 对应的值，我们知道下标是2，且是一个链表，我们需要循环遍历整个链表，找到 key = &quot;qq&quot; 的Entry。 HashMap的默认长度是多少？为什么要那么定义？ HashMap 默认长度是16，也可以自定义长度必须是2幂次方。之所以选择16，是为了方便于 key 映射 index 的算法。 为了实现一个均匀的 HashMap ,数组的长度必须是 2 的幂次方，将 index = hash(key) &amp; (length-1) 这样做的效率也更高，通过位运算的方式。 举例：book 的 hashcode,结果为十进制的 3029737，二进制：1011100011101011101001；假定 HashMap 长度是默认的16， length-1 = 15,二进制： 1111； index = hash(key) &amp; (length-1) 计算结果如下图： 二进制：1001；十进制：就是index= 9。 那么假设我们自定义长度设置为：10. 那length-1=9, 二进制就是：1001，我们重新计算下index`, 如下图： 二进制为：1001 ；十进制就是： index = 9 然后我们再尝试一个新的 HashCode: 结果还是：1001； 然后我们继续来一个新的 HashCode: 结果还是：1001，index= 9. 也就是说，当 HashMap 长度为 10 的时候，多个 不同的key生成的 index 可能是相同的，相同的概率比较大，这样，显然不符合 Hash 算法均匀分布的原则。 反观长度为16或者2的幂次方，length-1 的值是所有二进制全为1，这种情况下，index 的结果等同于HashCode 的后几位值，只有输入的 HashCode 本身分布均匀，Hash 算法的结果也是均匀的。]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView更清晰地观察缓存]]></title>
    <url>%2F2018%2F11%2F28%2FRecycleView%E6%9B%B4%E6%B8%85%E6%99%B0%E5%9C%B0%E8%A7%82%E5%AF%9F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[为了更清晰的观察 recycleView 缓存复用，在看到有一篇文章是打印缓存相关信息后，觉着确实是一种办法，比打断点更合适查看缓存的变化情况，就尝试自己写了写。 这里我主要利用反射观察的是：mCachedViews 和 recycleViewPool 里面的变化情况。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public void getInfo()&#123; try&#123; Class&lt;?&gt; class1 = Class.forName("android.support.v7.widget.RecyclerView"); Field field = class1.getDeclaredField("mRecycler"); field.setAccessible(true); RecyclerView.Recycler recycler = (RecyclerView.Recycler) field.get(recyclerView); Field field1 = recycler.getClass().getDeclaredField("mCachedViews"); field1.setAccessible(true); ArrayList&lt;RecyclerView.ViewHolder&gt; mCachedViews = (ArrayList&lt;RecyclerView.ViewHolder&gt;) field1.get(recycler); for(int i=0;i&lt;mCachedViews.size();i++)&#123; Log.i("xx","mCachedViews::"+mCachedViews.get(i)); &#125; RecyclerView.RecycledViewPool viewPool = recyclerView.getRecycledViewPool(); //这里之所以能获取到 RecycledViewPool中的mScrpa，需要新建一个android.support.v7.widget包，将该类放入该包下即可访问到。 SparseArray&lt;RecyclerView.RecycledViewPool.ScrapData&gt; list = viewPool.mScrap; //这里传入的类型type 是我在adapter中定义的，如下： //@Override //public int getItemViewType(int position) &#123; //return 666; //&#125; RecyclerView.RecycledViewPool.ScrapData spra = list.get(666); Field field2 = spra.getClass().getDeclaredField("mScrapHeap"); ArrayList&lt;RecyclerView.ViewHolder&gt; mScrapHeap= (ArrayList&lt;RecyclerView.ViewHolder&gt;) field2.get(spra); for(int i=0;i&lt;mScrapHeap.size();i++)&#123; Log.i("xx","mScrapHeapInfo::"+mScrapHeap.get(i)); &#125; Log.i("xx","================================================="); &#125;catch (Exception e) &#123; Log.i("xx", "error"); e.printStackTrace(); &#125; &#125; 需要注意的是：反射获取 然后在 recycleView 滚动的时候，显示信息： 12345678910recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy);// int recycleCount = recyclerView.getRecycledViewPool().getRecycledViewCount(666);// Log.i("xx","recyclePoolCount::"+recycleCount); getInfo(); &#125; &#125;); 还有可以在 adapter 重写方法： onViewRecycled(ViewHOlder holder) 方法，可以查看最新被回收的位置ViewHolder ： 12345@Override public void onViewRecycled(ViewHolder holder) &#123; Log.i("xx","holder被回收了"+holder);//可以拿到被回收holder的相关信息 super.onViewRecycled(holder); &#125; 这样我们就可以通过日志的方式来近距离查看 recyclerView 复用回收。 我们假设这样一个场景：总共假设有20个item ,使用 GrideLayoutManager 每行显示5个，一个屏幕差不多显示两行，如下图所示： 我们在 adapter 的 onCreateViewHolder 和 onBindViewHolder 方法的地方都打印日志，并且重写 onViewRecycled 方法，查看 View 的回收情况。 当我们向下滑动，将第一行的数据滑出屏幕后，我们发现打印日志如下： 我们发现 2，3，4卡位的 ViewHolder 被回收了。这里的被回收是指添加到 RecycleViewPool 当中了。此时 mCachedViews 中的缓存信息如下： 从日志上来看，它缓存了：1，0，15，16，17，18，19共7个卡位的数据。 这里补充一下：mCachedViews 的大小在源码定义中默认是:static final int DEFAULT_CACHE_SIZE = 2;（当然也可以自己设置，通过 RecyclerView #setItemViewCacheSize，一般不设置）经过我的多次实验观察，当每行设置为5列时，mCachedViews.size == 2+ 5 = 7,当每行是4时，mCachedViews.size == 2+ 4 = 6，所以此时就是mCachedView.size 是7。 问题1：为什么mCachedViews 缓存的卡位是1，0，15，16，17，18，19？要回答这个问题，首先应该明白当我们在滑动第三行展示的时候，此时 RecyclerView 创建了第四行的 ViewHolder,即 15，16，17，18，19因为它们未曾展示到屏幕上，所以被 mCachedViews 缓存，继续滑动，第一行数据移出屏幕之外，也要回收了，0，1，2，3，4，5 这5个是将要被缓存，但是mCachedVIews 已经缓存了5个，势必只能再添加两个，两外三个卡位的 ViewHolder 将要被回收，GrideLayoutManager 默认从右往左回收： 第一次回收4，3卡位如图： 第二次回收2卡位如图： 因为此时缓存数量已到最大值7了，所以再次添加时，会移除第一个。代码如下： 12345int cachedViewSize = mCachedViews.size(); if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; 日志： 新缓存的2卡位被插入index = 1 的位置。如此，我们就可以知道当1卡位会回收时，mCachedViews 中缓存的信息应该是，先移除第0个，也就是position= 3 的 ViewHolder,插入到 index = 1 的位置，顺序应该是：2，1，15，16，17，18，19，好我们看下日志： 是的，不出我们所料，至此到最后我们就知道了，当0卡位被回收时，mCachedViews 的缓存信息就是：1，0，15，16，17，18，19. 被移除的ViewHolder 被添加到了 RecycleViewPool 当中了，从 RecycleViewPool 当中取出的 ViewHolder 类似于全新的，但是不会重新调用 onCreateViewHolder,会重新调用 onBindViewHolder 重新绑定数据。]]></content>
      <tags>
        <tag>recycleView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap 原理]]></title>
    <url>%2F2018%2F11%2F22%2FConcurrentHashMap-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景知识：我们知道 HashMap 是线程不安全的，多线程情况下，进行put 操作会引起死循环，导致CPU 利用率比较高，所以在并发情况下不能使用 HashMap ; 而 Hashtable 是线程安全的，其实就是在 put 操作的时候加了 syncronized, 但是当一个线程在进行put 操作时，其它的线程连 get 操作也不能进行，导致阻塞或者轮询状态，所以竞争越来越激烈，效率低下。 目录结构： 1234public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123; ..... &#125; 锁分段技术 Hashtable 在多并发的情况下效率低下，是因为很多线程争夺同一把锁，而假如容器内有多把锁，每一把锁用于锁容器内的一部分数据，当多线程访问容器内不同段的数据时，线程间就不会存在锁竞争，从而有效的提高并发访问效率。 Segment 英文翻译：” 段“ 内部结构是：二级的哈希表，如下图： 多个Segment 保存在一个名为segments 数组当中，每个 Segment 高度自治，各个 Segment 之前读写互不影响。 读写操作 get 想要获取里面的元素，按照结构，我们大概也能猜测出如何获取。 首先根据 key 计算的 hash 值； 计算得出 在 segments 数组中的下标，根据下标得出相对应的 Segment； 再根据key 的 hash 值，找到Segment 数组中的位置 put put 元素 1.首先根据 key 计算hash 值 2.通过 hash 值，定位到具体的 Segment 对象 3.获取可重入锁 4.再次通过 hash 值，定位到 Segment 数组中的具体位置 5.插入或覆盖原 HashEntry 对象 6.释放锁 统计Size大小jdk 1.7: 123456789101112131415161718192021222324252627282930313233343536373839public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try &#123; for (;;) &#123; if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 遍历所有的 Segment 把 Segment 元素数量累加起来 把 Segment 修改次数累加起来 判断所有的Segment 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程有修改，尝试统计，统计次数+1；反之，统计结束。 如果统计次数超过阀值，则对每个 Segment 加锁，重新统计 再次判断总修改次数是否大于上一次的总修改次数， 释放锁，统计结束。]]></content>
      <tags>
        <tag>concurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合随笔]]></title>
    <url>%2F2018%2F11%2F21%2F%E9%9B%86%E5%90%88%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[1. ArrayList 和 HashMap 是否线程安全？ Collection ArrayList HashMap HashSet 都是非同步的，线程是不安全的 集合中：Vector 和 HashTable 是线程安全的 Collection —-&gt; 线程安全：Collections.synchronizedCollection() ArrayList —–&gt; Collections.synchronizedList() HashMap ——&gt; Collections.synchronizedMap() HashSet ——-&gt; Collections.synchronizedSet()]]></content>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler 相关总结]]></title>
    <url>%2F2018%2F11%2F21%2FHandler-%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先一个线程中是可以创建多个 Handler 的，互不影响，默认在 ActivityThread 当中也创建了一个 Handler H ,我们还是可以在 MainActivity 中创建我们自己的 Handler, 互不影响； 一个线程 对应一个 Looper ,一个 Looper 对应一个 MessageQueue ;]]></content>
      <tags>
        <tag>handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化]]></title>
    <url>%2F2018%2F11%2F21%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化 减少布局层次，单一可以用LinearLayout 解决的页面不用 RelativeLayout,如果布局复杂，则用RelativeLayout 更好，毕竟比起布局嵌套，这种会好些 &lt;include&gt; 标签使用，主要用于布局重用 需要注意的是：此标签内，如果外面指定了 id 里面跟布局也定义id 以外部定义为准。同时如果里面定义了 类似于 android:layout_width=&quot;wrap_content&quot; 的属性，需配套 android:layout_height=&quot;wrap_content&quot; 同时使用。 &lt;merge&gt; 标签一般和 &lt;include&gt; 标签配合使用。一般如果当前根布局例如是：LinearLayout ,include 的布局也是 LinearLayout ,那么 include 的根布局就可以使用 &lt;merge&gt; 标签代替LinearLayout. &lt;ViewStub&gt; 标签，意义为按需加载，轻量级，宽和高都是0，在实际开发中，有很多布局在正常情况下不会显示，比如网络异常的布局，这个时候没有必要在布局加载时就加载进来，通过&lt;ViewStub&gt; 就可以在需要用到的时候再加载，提高程序初始化的性能。 绘制优化 在 onDraw() 中不要创建新的局部对象，这是因为 onDraw() 可能会频繁的调用，这样就会在一瞬间产生大量的临时对象，这不仅占用过多的内存而且会导致系统频繁的gc, 降低程序的执行效率; 另外也不能做一些耗时的任务。 内存泄漏优化 静态变量导致的内存泄漏 例如： 123456789private static Context mContext; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_combine); mContext = this; &#125; 单例模式导致的内存泄漏 属性动画导致的内存泄漏 Android 3.0 之后，提供了属性动画，如果开启无限循环动画，隐藏后，未调用 animator,cancel() 来停止动画，也会发生内存泄漏，因为这个时候 Activity 的 View 被动画所持有，而 View 又持有 Activity, 最终Activity 无法释放。0- 响应速度优化和ANR日志 响应速度优化的核心是避免在主线程做耗时操作， Activity 5s 未做出响应， Service 10s未做出响应，就会出现 ANR ,查看 \data\anr 目录下的 trace,txt 文件分析产生 ANR 的原因 线程优化 线程优化一般都是采用线程池，避免程序中存在大量的 Thread, 线程池可重用内部的线程，从而避免线程的创建和销毁所带来的性能开销。]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效使用RxJava]]></title>
    <url>%2F2018%2F11%2F20%2F%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8RxJava%2F</url>
    <content type="text"><![CDATA[Question 场景一：在页面保存时，需要对页面所填写的一些列信息进行判断，确定正确无误后方可保存。 例如：页面上中需要填写：姓名，性别，职业，年薪，住址等信息。 按照常规做法,我们有可能会这么写： 12345678910if(Util.checkempty(mUserName))&#123;//判断用户名是否为空 return;&#125;if(Util.checkempty(mSex))&#123;//判断性别是否为空 return;&#125;.....if(Util.checkempty(mAddress))&#123;//判断住址是否为空 return;&#125; 而用 Rxjava.combineLatest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//构建被观察者Observable userNameObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; subscriber) &#123; tv.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subscriber.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;); Observable sexObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; subscriber) &#123; sex.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subscriber.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;); Observable.combineLatest(userNameObservable, sexObservable, new Func2&lt;String,String,Boolean&gt;() &#123; @Override public Boolean call(String userName, String sex) &#123; //判断用户名 boolean isUserInvalid = !TextUtils.isEmpty(userName); //判断性别 boolean isSexInvalid = !TextUtils.isEmpty(sex); return isUserInvalid &amp;&amp; isSexInvalid; &#125; &#125;).subscribe(new Action1() &#123; @Override public void call(Object o) &#123;//只有都满足条件后才会执行到这里 Log.i("xx","信息："+o);//可以保存信息了 &#125; &#125;); 场景二：搜索输入，避免多次调用搜索接口，搜索优化 12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; subscriber) &#123; tv.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subscriber.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;).filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; return !TextUtils.isEmpty(s);//过滤为空的 &#125; &#125;).debounce(1,TimeUnit.SECONDS) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i("xx","搜索字符串：："+s); &#125; &#125;);]]></content>
      <tags>
        <tag>rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2F2018%2F11%2F19%2FRxJava%2F</url>
    <content type="text"><![CDATA[1. 变换 map() 它是一对一的 123456789101112Observable.just("image/logo.png")//输入类型String,图片地址 .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; return getBitmap(filePath);//转换为bitmap &#125; &#125;).subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; showBitmap(bitmap);//显示bitmap &#125; &#125;); flatMap() 多对多转换 假如有这样一个场景，我们需要打印每个学生所修的课程，学生是一个集合，课程也是一个集合，如果按照map() 的做法如下： 这里我选用我项目里随意一个bean 对象，意思不变 12345678910111213141516UserInfo[] userInfos = new UserInfo[3];Observable.from(userInfos) .map(new Func1&lt;UserInfo, List&lt;AppInfo&gt;&gt;() &#123; @Override public List&lt;AppInfo&gt; call(UserInfo userInfo) &#123; return userInfo.getAppInfos(); &#125; &#125;).subscribe(new Action1&lt;List&lt;AppInfo&gt;&gt;() &#123; @Override public void call(List&lt;AppInfo&gt; appInfos) &#123; for(AppInfo info : appInfos)&#123; Log.i("xx",info.getAppName()); &#125; &#125; &#125;); 有种情况就是假如我不想要循环遍历呢，而是直接拿到 AppInfo 对象，显然 map() 是无法实现的，map() 我们前面也说过是 一对一的转换，而现在是一对多，那此时就应该用 flatMap(). 使用flatMap() 的话，如下： 12345678910111213141516171819202122Observable.from(userInfos) .flatMap(new Func1&lt;UserInfo, Observable&lt;AppInfo&gt;&gt;() &#123; @Override public Observable&lt;AppInfo&gt; call(UserInfo userInfo) &#123; return Observable.from(userInfo.getAppInfos()); &#125; &#125;).subscribe(new Subscriber&lt;AppInfo&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(AppInfo appInfo) &#123; Log.i("xx","appInfo.name::"+appInfo.getAppName()); &#125; &#125;); 上述是用 flatMap() 编写的，去除了 for 循环，flatMap() 和 map() 有一个相同点：它们都是把传入的参数转化之后返回另一个对象。但需要注意的是，和map() 不同的是，flatMap() 中返回的是 Observable 对象。 flatMap() 原理如下： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable 对象，而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable,而这个 Observale 负责将这些事件统一交给 Subscriber 的回调方法。]]></content>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[衡量代码的好坏，包括两个非常重要的指标： 运行时间 占用空间 由于运行环境和输入规模的影响，代码的绝对执行时间是无法估计的，但是我们却可以预估代码的基本执行次数。我可以通俗的理解为：通过执行次数可以大概推算这个时间复杂度。 示例： 一个有序排列好的数组 1int[] arry = &#123;-5,-1,0,5,9,11,13,15,22,35,46&#125;,输入一个x，int x = 31 在数组中找出和为 x 的两个数，例如： 9 +22 = 31。要求时间复杂度为O(n). 好，当我们看到这个问题的时候，我们认为这很容易嘛(先不考虑时间复杂度)，于是写了如下代码： 第一种写法： 123456789101112131415161718192021int[] array = &#123;-5,-1,0,5,9,11,13,15,22,35,46&#125;; int sum = 31;public void getIndex(int[] array,int sum)&#123; //sum 在数据中找出和为sum的两个数 int x = 0; int y = 0; for(int i=0;i&lt;array.length;i++)&#123; for(int j=i+1;j&lt;array.length;j++)&#123; //判断是否相加=sum if(array[i] + array[j] == sum)&#123; x = i; y = j; break; &#125; &#125; &#125; System.out.println("第一个数的为："+array[x]); System.out.println("第二个数的为："+array[y]); &#125; 根据我们上面对时间复杂度的了解，我们知道改算法的时间复杂度是 O(n^2)， 是最低的一种，可以说，那么我们如何把时间复杂度设置为O(n) ,线性复杂度，其实就是需要一遍for 循环； 第二种算法： 1234567891011121314151617181920int[] array = &#123;-5,-1,0,5,9,11,13,15,22,35,46&#125;;int sum = 31;public void getSimpleIndex(int[] array,int target)&#123; int x = 0; int y = 0; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; array.length; i++) &#123;//第一次遍历数组，将元素和下标以K-V方式存入hm中 hm.put(array[i], i);//key 为数组里面的值，value是下标 &#125; for(int i=0;i&lt;array.length;i++) &#123;//第二次遍历数组，查找是否有和为target的元素对 if (hm.containsKey(target - array[i]) &amp;&amp; (i != hm.get(target - array[i]))) &#123; //保证两个元素不是同一个，否则如果target恰好是某个元素的2倍时就不符合题意 x = i; y = hm.get(target - array[i]); break; &#125; &#125; System.out.print(array[x]+" "+array[y]); &#125; 这是一种典型以空间换时间的解法。 总结常见的时间复杂度有如下： T(n) = O(n) T(n) = O(logn) T(n) = O(1) T(n) = O(n²) 这四种时间复杂度谁用时更长，更节省时间呢？ O(1) &lt; O(logn) &lt; O(n) &lt; O(n²)]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生产者消费者模式]]></title>
    <url>%2F2018%2F11%2F19%2Fjava%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Producter.java 生产者： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 生产者 */public class Producter extends Thread &#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; int i = 0; public Producter(String name,Queue&lt;Integer&gt; queue,int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true)&#123; synchronized (queue)&#123; while(queue.size() == maxSize)&#123; try&#123; System.out.println("Queue is full,Productr["+name+" ]thread waiting for"); //等待 queue.wait(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; System.out.println("["+name+"] producting value:+"+i ); queue.offer(i++); queue.notifyAll(); try&#123; Thread.sleep(new Random().nextInt(1000)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Consumer.java 12345678910111213141516171819202122232425262728293031323334353637383940public class Consumer extends Thread &#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; public Consumer(String name,Queue&lt;Integer&gt; queue,int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true)&#123; synchronized (queue)&#123; while (queue.isEmpty())&#123; try&#123; System.out.println("Queue is empty,Consumer ["+name+"] thread is waiting for Producer"); //如果为空，就等待 queue.wait(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; int x = queue.poll(); System.out.println("["+name+" Consumer value : "+x); queue.notifyAll(); try&#123; Thread.sleep(new Random().nextInt(1000)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; main.java: 123456789101112131415161718public static void main(String args[])&#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Thread product1 = new Producter("p-1",queue,5); Thread product2 = new Producter("p-2",queue,5); Thread consumer1 = new Consumer("C1",queue,5); Thread consumer2 = new Consumer("C2",queue,5); Thread consumer3 = new Consumer("C3",queue,5); product1.start(); product2.start(); consumer1.start(); consumer2.start(); consumer3.start(); &#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点三]]></title>
    <url>%2F2018%2F11%2F15%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1. RecycleView 如何设置分割线的？ 它是读取系统自带的属性 R.attr.listDivider 属性，来设置分割线的，支持横向和纵向。 2. RecycleView 分割线的样式如何修改？ 第一种办法：因为 R.attr.listDivider 定义在系统样式中，那么我们可以重写这个属性修改，如下： 在styles.xml 中添加该属性： 12345&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; .... &lt;item name="android:listDivider"&gt;@drawable/drawable_bg&lt;/item&gt; &lt;/style&gt; 其中 drawable_bg 为自定义分割线的drawable. 第二种办法：可以通过自带的 setDrawable() 改变，如下： 1234DividerItemDecoration itemDecoration = new DividerItemDecoration(this,DividerItemDecoration.VERTICAL); Drawable drawable = getResources().getDrawable(R.drawable.drawable_bg); itemDecoration.setDrawable(drawable); recyclerView.addItemDecoration(itemDecoration); 3. RecycleView 缓存 缓存涉及三个类，分别是： Recycler RecycledViewPool ViewCachedExtension Recycler : 用于管理已经废弃或者与 RecyclerView 分离的 ViewHolder mChangedScrap : 与 RecyclerView 分离的 ViewHolder 列表 mAttachedScrap : 未与 RecyclerView 分离的 ViewHolder 列表 mCachedViews : ViewHolder 缓存列表 RecycledViewPool : ViewHolder 缓存池 ViewCachedExtension : 开发者可以控制的 ViewHolder 缓存的帮助类 获取缓存里的 ViewHolder 的关键方法是： tryGetViewHolderForPositionByDeadline 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Nullable ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123; throw new IndexOutOfBoundsException("Invalid item position " + position + "(" + position + "). Item count:" + mState.getItemCount() + exceptionLabel()); &#125; boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there // 0) 如果需要改变废弃的view，从这里查找 if (mState.isPreLayout()) &#123; //这里是 mChangedScrap 集合中取出 holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; // 1) Find by position from scrap/hidden list/cache // 1） 这是从 mAttachedScrap 集合中查找 if (holder == null) &#123; holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) &#123; if (!validateViewHolderForOffsetPosition(holder)) &#123; // recycle holder (and unscrap if relevant) since it can't be used if (!dryRun) &#123; // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; recycleViewHolderInternal(holder); &#125; holder = null; &#125; else &#123; fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123; throw new IndexOutOfBoundsException("Inconsistency detected. Invalid item " + "position " + position + "(offset:" + offsetPosition + ")." + "state:" + mState.getItemCount() + exceptionLabel()); &#125; final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap/cache via stable ids, if exists // 2）从 mCachedViews 集合中查找缓存 if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; // We are NOT sending the offsetPosition because LayoutManager does not // know it. // 3 从mViewCacheExtension 获取 final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); if (holder == null) &#123; throw new IllegalArgumentException("getViewForPositionAndType returned" + " a view which does not have a ViewHolder" + exceptionLabel()); &#125; else if (holder.shouldIgnore()) &#123; throw new IllegalArgumentException("getViewForPositionAndType returned" + " a view that is ignored. You must call stopIgnoring before" + " returning this view." + exceptionLabel()); &#125; &#125; &#125; if (holder == null) &#123; // fallback to pool if (DEBUG) &#123; Log.d(TAG, "tryGetViewHolderForPositionByDeadline(" + position + ") fetching from shared pool"); &#125; // 4）从缓存池中获取 recycledViewPool holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123; // abort - we have a deadline we can't meet return null; &#125; //如果都没有 就重新创建 createViewHolder holder = mAdapter.createViewHolder(RecyclerView.this, type); ..... &#125; &#125; &#125; 总结缓存的机制如下： 1.从 mChangedScrap 或 mAttachScrap 中获取 2.从 mCacheViews 3.从 mRecycledViewPool 缓存池中获取 4. RecycleView 刷新闪屏一般刷新： 1adapter.notifyItemChanged(0); 参数：position 实际上会全部刷新，局部刷新应使用： 1adapter.notifyItemChanged(0,"q"); 参数： position,payload 并且在 adapter 中重写方法： `onBindViewHolder(RecyclerView.ViewHolder holder, int position, List payloads)方法` payloads 的 size 始终为1. 123456789@Overridepublic void onBindViewHolder(ViewHolder holder, int position, List&lt;Object&gt; payloads) &#123; if(payloads.isEmpty())&#123; onBindViewHolder(holder,position); &#125;else&#123; String type = payloads.get(0);//获取为 q holder.name.setText(list.get(position)); &#125; &#125; 5. RecycleView 和 listView//https://zhuanlan.zhihu.com/p/23339185 缓存层级不同 recycleView 比 listView 多两级缓存，支持开发者自定义缓存处理，支持多个recycleView共用同一个 recycleViewPool(缓存池) listView 缓存（两级缓存）： 是否需要回调createView 是否需要回调bindVIew 生命周期 备注 mActiveViews 否 否 onLayout函数周期内 用于屏幕内itemView快速重用 mScrapViews 否 是 与mAdapter一致，当Adapter被更换时，mScrapViews即被清空 RecycrleView 缓存( 四级缓存)： 是否回调createView 回调bindVIew 生命周期 备注 mAttachedScrap 否 否 onLayout 用于屏幕内itemView快速重用 mCacheViews 否 否 与mAdapter一致，当Adapter被更换时,mCacheVIews被缓存到mRecyclerPool 默认缓存大小是2 mViewCacheExtension 用户自定义实现 mRecyclerPool 否 是 与自身生命周期一致，不再引用时被释放 默认大小是5 ListView 和 RecyclerView 缓存机制： mActiveViews 和 mAttachedScrap 功能相似，意义在于快速重用屏幕上可见的列表项 itemView,而不需要重新createView 和 bindView mScrapView 和 mCachedViews + mRecyclerViewPool 功能相似，意义在于缓存离开屏幕的itemView,目的是让即将进入屏幕的 itemView 重用 RecycleView 的优势在于 mCacheVIews 的使用，可以做到屏幕外的列表项itemView 进入屏幕内时也无须bindView 快速重用； mRecycleViewPool 可以供多个recycleView 共同使用，在特定场景下，如viewpager 加多个列表页有优势。 6. RecycleView 的回收复用机制的内部实现都是哪个类完成的？ RecycleView 的回收复用机制都是由内部类 Recycler 类，核心方法：tryGetViewHolderForPositionByDeadline() 方法中完成的。 随笔源码记录： 复用机制1234567891011121314151617public View getViewForPosition(int position) &#123; return getViewForPosition(position, false); &#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125;@NullableViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //复用机制的原理 - 1.mCacheView - 2.recyclerViewPool - 3.扩展 - 4.都没有，重新创建一个ViewHolder(createViewHolder) ...&#125; 回收机制 也是 Recycler 类中的，核心方法：recycleViewHolderInternal(holder) 123456789101112131415public void recycleView(View view) &#123; // This public recycle method tries to make view recycle-able since layout manager // intended to recycle this view (e.g. even if it is in scrap or change cache) ViewHolder holder = getChildViewHolderInt(view); if (holder.isTmpDetached()) &#123; removeDetachedView(view, false); &#125; if (holder.isScrap()) &#123; holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; //回收的内部实现 recycleViewHolderInternal(holder); &#125; 回收的逻辑：由 LayoutManager 来遍历移出屏幕的卡位，然后对每个卡位进行回收操作，回收时，都是把 viewHolder 放在 mCachedViews 里面，如果mCachedViews 满了，那就在mCachedViews 里拿一个ViewHolder 扔到 ViewPool 缓存里，然后mCachedViews 就可以空出位置来放新回收的ViewHolder 了。 mCachedViews 里存放的 ViewHolder 只有原本位置的卡位才能复用 参考链接：https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/79946425 =================================================================================== updateViewCacheSize() 12345void updateViewCacheSize() &#123; int extraCache = mLayout != null ? mLayout.mPrefetchMaxCountObserved : 0; mViewCacheMax = mRequestedCacheMax + extraCache; .... &#125; 在第一次向上滑动]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点总结二]]></title>
    <url>%2F2018%2F11%2F14%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1. Canvas.save() 跟 Canvas.restore()的调用时机 save: 用来保存 Canvas 的状态。save 之后，可以调用Canvas 的平移，放缩，旋转等操作。 restore: 用来恢复canvas 之前保存的状态。防止save 后对Canvas 执行的操作对后续的绘制有影响。 2. Android P(9.0) 的新特性 支持WiFi室内定位 适配刘海屏 通知栏改进：可以显示对话，附加照片和表情等 多摄像头api 对于非 http 连接，将直接拦截，推荐使用https Android 8.0 PHONE 权限组新增加两个权限 ANSWER_PHONE_CALLS:允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 assceptRingingCall() 函数 READ_PHONE_NUMBERS: 权限允许您的应用读取设备中存储的电话号码 通知适配 为了更好的管理通知的提醒，不想一些不重要的通知打扰用户，新增加用户渠道，用户可根据渠道屏蔽一些不重要的通知 安装apk 在 AndroidManifest 文件中添加未知来源应用的权限： &lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt; 这样系统会自动询问用户完成授权。 也可以通过 canRequestPackageInstalls 查询是否有此权限，如果没有的话就使用 Settings.ACTION_MANAGE_UNKNOW_APP_SOURCE 引导用户安装未知应用权限去授权。 123456789101112131415161718if(Build,VERSION&gt;SDK_INT &gt;= 26)&#123; Boolean isInstall = getPackageManager().canRequestPackageInstalls();//26以上 if(isInstall)&#123; //有此权限，安装应用 &#125;else&#123; //跳转到 安装未知应用 权限界面，引导用户开启权限 Uri selfPackageUri = Uri.parse("package:" + this.getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri); startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP)&#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123; //如果权限开启，则开始安装应用 &#125; &#125; 静态广播无法正常接受 Android N(7.0) 的新特性 私有文件外部将不能访问，通过FileProvider 可解决 SharedPreferences 进程间通信模式闪退，SecurityException Android 6.0 运行时权限的申请 https 的推荐 3. APK 内容 assets 存放需要打包到 APK 中的静态文件 lib 目录 native库 res 目录 存放应用程序的资源 META-INF 存放应用程序签名和证书的目录 AndroidManifest.xml classes.dex resources.arsc 资源配置文件 4. Binder 机制的优点 Linux 中使用的 IPC 通信机制有：pipe(管道)，signal(信号量)，Socket socket:是一个通用接口，传输效率低，开销比较大； 管道和消息队列：采用存储转发方式，所以至少需要拷贝2次数据，效率低，共享内存虽然在传输时没有拷贝数据，但其控制机制复杂，而 Binder 更好传输性能。 安全性更高，可以建立私有通道，有身份标识（UID/PID） 另外一个优点就是，通过binder 可以很方便的调用server 端的方法，犹如调用本地方法一样。 5. Gradle 的生命周期 1.初始化 初始化主要是读取 settings.gragle 文件，用于确定哪些项目参与构建，并创建Project 实例 2.配置 配置阶段主要是为每个 build.gradle 文件配置 project 对象 3.执行 主要根据 gradle 命令和传入参数创建并执行任务]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔记录Android]]></title>
    <url>%2F2018%2F11%2F13%2F%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95Android%2F</url>
    <content type="text"><![CDATA[1. Android中数据存储的方式 FIle SharedPreference Sqlite 网络 ContentProvider FileProvider : 继承于 ContentProvider 的子类，可以用于解决Android7.0中禁止我们的应用对外部公开file://的问题。 2. SharedPreference 是进程同步的吗 sharedPreference 默认不是线程同步的，可以设置模式为：MODE_MULTI_PROCESS 做到进程同步，系统默认也是有缓存的，有很多问题，在Android N（7.0）以上废弃不能使用了，会抛出异常。推荐使用 ContentProvider sharedPreference 四种模式： MODE_PRIVATE MODE_MULTI_PROCESS MODE_WORLD_READABLE MODE_WORLD_WRITEABLE 3.Shareferences commit 和 apply 的区别 在很早的sdk当中，一般都使用 commit 方法，同步，直接写入磁盘，并且有返回结果 boolean 类型，而 apply 是异步, 先写入内存，然后异步写入磁盘。 如果操作频繁的话，apply 的性能优于 commit. 在阿里巴巴开发手册中也记录到： SharedPreference 提 交 数 据 时 ， 尽 量 使 用 Editor#apply()，而非Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使用 Editor#commit()。 4. View 的 measureSpec 由谁决定的 View的MeasureSpec 由这个父控件的MeasureSpec 和自身的 LayoutParams 决定 顶级 DecorView 由窗口尺寸和自身的 LayoutParams 共同确定 5.ACTION_CANCEL 事件 一般来说，如果一个子视图接受了父视图分发给它的 ACTION_DOWN 事件，那么与ACTION_DOWN 事件相关的事件都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL 事件。 6. View的invalidate postInvalidate requestLayout区别 invalidate 会调用 onDraw 进行重绘，只能在主线程 postIncalidate 可以在其它线程，如子线程 requestLayout 会调用 onLayout 和 onMeasure ,不一定会调用 onDraw 7. View 的生命周期 Creation 创建（从xml中加载或者layout 文件中定义加载） onFinishInflate() 从xml中加载完成 Layout 布局 onMeasure() onLayout() Drawing 绘制 onDraw() Event processing 事件处理 Focus 聚焦 onFocusChanged() onWindowFocusChanged() Attaching 附上 onAttachingToWindow() onDetachedFromWindow() onVisibiltyChanged() onWindowVisibiltyChanged()]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础二]]></title>
    <url>%2F2018%2F11%2F13%2Fjava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1. HashMap1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; .....&#125; 未完待续….仍需要查阅大量资料学习…. 2.Java 内存分配 栈区：方法区内的局部变量，对象的引用等 优点：速度快，缺点：大小和生命周期必须是确定的。 堆区：new出来的对象，垃圾回收器回收的是堆区的内存 方法区（静态区）：静态变量，常量，保存类信息 3.垃圾 什么是垃圾？要通过科学的方法才能判断是否是为垃圾，有两种方法 引用计数法：可能会导致内部循环 可达性分析：是否可达 借助一个图快速理解 引用计数法： 代码： 123456789101112/**循环问题*/public class Demo&#123; public Demo instance; public static void main(String[] args) &#123; Demo a=new Demo(); Demo b=new Demo(); a.instance=b; b.instance=a; a=null; b=null; &#125;&#125; 再看下这个 可达性分析 ： ObjD 和 ObjE 虽然内部存在引用，但是定点不可达，所以也是垃圾回收的对象。 4.垃圾回收的方法 标记-清除：减少停顿时间，但会造成内存碎片 标记-整理：可以解决内存碎片，但是会增加停顿时间 复制清除：从一个地方拷贝到另一个地方，适合有大量回收的场景，比如：新生代回收 优点：效率高于标记清除，活着的对象是整齐排列的，没有内存碎片 缺点： 浪费空间，毕竟如果按照1：1比例划分空间的话，那么将会有50%的空间被浪费。不过在jvm中，新生代空间并不是按照1：1来划分的，而是按照8：1：1的比例分为一个eden 区 和两个survivor(survivor0,survivor1) 区，然后一个eden 区，两个survivor 区。大部分对象在Eden 区中生成。回收时先将eden 区存活对象复制到一个survicor0 区，然后清空eden 区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1 区，然后清空eden 区和survivor0 区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，这样的过程也叫做Minor GC,每进行Minor GC 一次，存活着的对象的年龄就会+1，当存活着的对象的年龄到达15岁时，就会被送进年老代。 当然，当整个survivor1区不足以存放Eden和survivor0的存活对象时，也会将存活对象直接放到年老代。若是年老代也满了就会触发一次Full GC，也就是新生代，老年代都进行回收。 分代收集：把内存区域分成不同代，根据年代不同采取不同的策略； 新生代：存放新创建的对象，采用复制回收方法 年老代：这些对象垃圾回收的频率较低，采取标记整理法 永久代：存放Java本身的一些数据，当类不再使用时，也会被回收 手稿： 5. Full GC 触发的条件 调用 System.gc 时，系统建议执行Full GC 但是不必然执行 年老代或者永久代空间不足 6. 线程调度 wait() : object 方法，必须在同步代码块中使用，使当前线程处于等待状态，释放锁 notify() ： 和 wait 联合使用，通知一个线程，具体通知哪个由jvm 决定，使用不当可能发生死锁 notifyAll() ： 和wait 方法联合使用，通知所有线程，具体哪个线程获得运行权 jvm 决定 sleep() ： 睡眠状态 7.线程同步 Synchronzied 修饰 ThreadLocal : 每个线程都有一个局部变量的副本，互不干扰。一种以空间换时间的方式。 线程安全的容器和方法，可以实现线程同步，如： Collections.SynchronizedList() 将 List 转为线程同步；用ConurrentHashMap 实现hashmap 线程同步。 volatile 修饰的变量不会缓存在寄存器中，每次使用都会从主存器中读取；保证可见性，不保证原子性]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识]]></title>
    <url>%2F2018%2F11%2F12%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 如何实现对象克隆？有两种方式： 实现Cloneable 接口并重写 clone 方法（浅拷贝）； 实现Serializable ，通过对象的序列化和反序列化实现真正的深度克隆（深拷贝），代码如下： 12345678910111213141516171819202122232425262728public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static &lt;T&gt; T clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型界定，可以检查出要克隆对象是否支持序列化，这项检查是编译器完成的，不是运行时抛出异常，这种方案明显优于使用object类的clone方法克隆对象。让问题在编译的时候暴漏出来总是优于把问题留在运行时。 2. 内部类访问局部变量的时候，为什么加final? 内部类和局部变量的生命周期不同，方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类生命周期&gt;=局部变量 Java会在编译时在内部类的构造方法里边，将局部变量以参数形式传递给内部类 而如果局部变量发生改变，内部类不知情的场景，所以要加fianl ，保证引用不可改变 注意：在Java8中，可以不适用final关键字，但是如果我们修改了局部变量还是会发生错误，从而保证局部变量的引用不变。 3. transient 关键字 如果使用transient 修饰变量，当对象存储时，它的值不需要维持。换句话来说就是用transient 修饰的变量不参与序列化的过程。 4. String 和 StringBuild,StringBuffer的区别 String 是只读字符串,创建完成之后是不能修改，如果修改也是创建一个新对象，回收旧对象的过程，所以执行效率比较低，StringBuild 和 StringBuffer 可以改变，StringBuild 线程不安全，但是效率比较高，StringBuffter 线程安全 效率快慢：Stringbuilder&gt; StringBuffer&gt; String 5. String 为什么设计成不可变 安全性 本身是final 类不可修改，不可变极为安全 String 常被用来作为 HashMap 的key 如果可变会引来安全问题，例如两个key 相同 效率高 通过字符串池可以节省很多空间 每一个String 对应一个 hashcode ,再次使用不用重新计算 6. java 中的四种引用及应用场景 强引用 弱引用—-引用到达，不可达就会被回收，即便是内存充足，可用于图片Bitmap 缓存，当不再使用Bitmap 时，就会被回收 软引用—–内存不足时被回收，也可用于Bitmap回收，当内存不足时，可回收 虚引用—-它指向的对象回收时，它本身会被加入到引用队列中，这样我们就知道它指向的对象何时被销毁]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeakCannary原理分析]]></title>
    <url>%2F2018%2F11%2F07%2FLeakCannary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[上篇写到 leakcanary 的使用,这篇主要是了解LeakCannary 大概是如何工作的。 1.首先它是如何监听Activity 销毁的？因为我们知道只有当activity 销毁（onDestroy()）的时候，我们才能对这个activity 进行分析查看哪些对象可能存在内存泄漏。 发现了如下代码：12345public static RefWatcher install(Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall(); &#125; 在buildAndInstall() 中：1234567891011121314public RefWatcher buildAndInstall() &#123; .... if (refWatcher != DISABLED) &#123; if (watchActivities) &#123; //这是观察activity的 ActivityRefWatcher.install(context, refWatcher); &#125; if (watchFragments) &#123; FragmentRefWatcher.Helper.install(context, refWatcher); &#125; &#125; LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher; &#125; 12345678public final class ActivityRefWatcher &#123; .... public static void install(Context context, RefWatcher refWatcher) &#123; Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); //拿到application，注册activity的生命周期回调 application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks); &#125; 其中这个：lifecycleCallbacks 就是回调监听123456private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123;//监听activity销毁 @Override public void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity); &#125; &#125;; 那么我们也可以通过application 注册获取activity 的生命周期监听回调，如下是我写的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LifeCircleActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.life_layout); final Application application = (Application) getApplicationContext(); application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; Log.i("xx","activity is onActivityCreated..."); &#125; @Override public void onActivityStarted(Activity activity) &#123; Log.i("xx","activity is onActivityStarted..."); &#125; @Override public void onActivityResumed(Activity activity) &#123; Log.i("xx","activity is onActivityResumed..."); &#125; @Override public void onActivityPaused(Activity activity) &#123; Log.i("xx","activity is onActivityPaused..."); &#125; @Override public void onActivityStopped(Activity activity) &#123; Log.i("xx","activity is onActivityStopped..."); &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; Log.i("xx","activity is onActivitySaveInstanceState..."); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; application.unregisterActivityLifecycleCallbacks(this); Log.i("xx","activity is onDestroy..."); &#125; &#125;);&#125; 这样我们就可以监听我们当前这个类的生命周期了，可以运行打印日志就知道了。 2.内存泄漏的对象的引用路径这块使用到了 square 的另一个开源库 haha ,获取当前内存中的heap堆信息的snapshot]]></content>
      <tags>
        <tag>leakcannary</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F07%2F%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80-leakcannary%2F</url>
    <content type="text"><![CDATA[build gradle配置 1234debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.1'releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1'// Optional, if you use support library fragments:debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.1' 配置 application 12345678private RefWatcher refWatcher; public static RefWatcher getRefWatcher(Context context)&#123; HealthApplication application = (HealthApplication) context.getApplicationContext(); return application.refWatcher; &#125; 监测 12RefWatcher refWatcher = MyApplication.getRefWatcher(this);//1 refWatcher.watch(this); 例如：我们写一个泄漏的代码1234567891011121314151617181920212223242526@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_event_bus); RefWatcher refWatcher = MyApplication.getRefWatcher(this);//1 refWatcher.watch(this); Message message = Message.obtain(); message.obj = "qianqian"; message.what = 666; handler.sendMessageDelayed(message,600000); &#125; Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i("xx","handle message"); &#125; &#125;; public void sendMessage(View view)&#123; finish(); &#125; 界面上一个按钮，点击按钮退出程序，在程序 onCreate 方法中我们发送了一个延时的消息，按照我们的分析，肯定会发生泄漏的。来我们看下leakcannary 给我们的提示： 我们知道当我们退出程序的时候 MessageQueue 中的消息还没执行完毕，MessageQueue.mMessages 这个变量持有的是Message 这个对象，而 Message.target中的 target持有的该Activity的 handler引用，所以此时finish 掉的 activity 并不会被回收，导致LeakActivity 发生内存泄漏。 其中一种解决办法呢，就是我们可以通过在点击或activity 退出时，removeMessage，例如：1234public void sendMessage(View view)&#123; handler.removeMessages(666); finish(); &#125; 这样就不会有警告了。 也可以通过静态内部类+弱引用的方式：123456789101112131415161718192021222324252627private static class MyHandler extends Handler &#123; private final WeakReference&lt;LeakActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;LeakActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; LeakActivityactivity = mActivity.get(); if (activity != null) &#123; ... &#125; &#125; &#125;private final MyHandler handler= new MyHandler(this); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_event_bus); Message message = Message.obtain(); message.obj = "qianqian"; message.what = 666; handler.sendMessageDelayed(message,600000); &#125;&#125; 在实际项目中，可以用这个工具筛查一遍。]]></content>
      <tags>
        <tag>leakcannary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus 源码分析（下篇）]]></title>
    <url>%2F2018%2F10%2F08%2FEventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上篇 EventBus 源码分析（上篇） 说到注册订阅的前半部分，此篇用来分析发送事件到接收事件这个过程。 1. 发送事件示例：1EventBus.getDefault().post(new RemindBean(&quot;2018-02-12&quot;,&quot;happy&quot;)); post:1234567891011121314151617181920212223242526272829/** Posts the given event to the event bus. */ public void post(Object event) &#123; - 1.获取当前线程的postingThreadState 对象 PostingThreadState postingState = currentPostingThreadState.get(); - 2. 获取里面那个事件队列 List&lt;Object&gt; eventQueue = postingState.eventQueue; - 3. 将事件添加到队列中去 eventQueue.add(event); - 4. 判断当前的event 是否在 posting if (!postingState.isPosting) &#123; - 5. 是否是主线程 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; - 6. 判断是否取消 if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; while (!eventQueue.isEmpty()) &#123;//不为空，进入循环 - 7.按照顺序，post一个 remove一个 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; PostingThreadState 大概看一眼12345678final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled; &#125; 再就是 postSingleEvent(eventQueue.remove(0), postingState); 方法：12345678910111213141516171819202122232425262728private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; - 1. 获取event的字节码（例如就是：RemindBean.class） Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123;//默认为true - 2. 根据eventClass 的字节码查找 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); - 3.循环遍历 for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); - 4.根据事件，字节码查找订阅者 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; postSingleEventForEventType:12345678910111213141516171819202122232425262728293031private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; - 1.根据字节码取出subscriptions,还记得我们之前在subscribe这个方法的时候，把subscrber,subscriberMethod 封装成一个subscription 对象。 subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; - 2. 取出每一个subscription 对象 postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; - 3. post到相应的线程中回调 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; postToSubscription: 根据定义的不同线程，调用相应的方法1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING://一般没定义的，这个就是post在哪个线程，响应就在哪个线程执行 invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125; &#125; invokeSubscriber:12345678910void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; - 反射拿到字节码clazz 反射调用方法，就收到消息了 subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(&quot;Unexpected exception&quot;, e); &#125; &#125; end.]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eventbus 源码分析（上篇）]]></title>
    <url>%2F2018%2F10%2F08%2FEventbus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[可用于应用内的消息事件传递，方便快捷，耦合性低 1.基本用法1234567891011121314151617181920212223242526272829public class EventBusMain extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.content_main); EventBus.getDefault().register(this); &#125; - 订阅的事件 onEvent1 @Subscribe public void onEvent1(RemindBean bean)&#123; &#125;- 订阅的事件 onEvent2 @Subscribe public void onEvent2(UserInfo bean)&#123; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125;&#125; 需要发送消息传递的时候：1EventBus.getDefault().post(new RemindBean()) 2.源码解读放上官网的一张原理图，感觉挺清晰的： 发布消息的一方(Publisher)，只需要 post 一个 event 之后就不用管了，EventBus 内部会将event逐一分发给订阅此 event 的订阅者（Subscriber）. 不错就是这样一个东西。 还记得以往我要实现两个不同的activity 之间要传递一些数据的时候，我都是通过定义一个interface的形式完成，时间一长，定义的接口一堆，在回顾查看代码也确实不够美观。好了话不多说，看下大家都在用的Eventbus. 3.首先1EventBus.getDefault().register(this); getDefault():123456789101112EventBus 是一个单例模式，懒汉式，双重判断 /** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; register 是什么意思呢，就是就跟你订阅报纸一样，报社需要确定几个重要的问题： 订阅者是谁（Subscriber）？ 订阅的什么报纸(Event) ？ 就是我认为比较重要的，那么register 这一步就是Subscriber 告诉 报社，订阅的event1234567891011121314public void register(Object subscriber) &#123; - 1.先拿到这个订阅者(subscriber)类的字节码 Class&lt;?&gt; subscriberClass = subscriber.getClass(); - 2. 通过这个类的字节码，拿到所有的订阅的 event,存放在List中 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; - 3. 循环遍历所有的订阅的方法，完成subscriber 和 subscriberMethod 的关联 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 我们看下这个如何根据subscriberClass 找到这个订阅的 method的，findSubscriberMethods: 1234567891011121314151617181920212223242526List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; - 1.先从缓存中取 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); - 2. 第一次肯定 null if (subscriberMethods != null) &#123; return subscriberMethods; &#125; - 3. 查找默认也是false，感兴趣的可以看下 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; - 4. 所以是走这里 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; - 5. 找到之后添加到缓存中，key是 subscriber ;value 是：methods METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 看下：findUsingInfo(subscriberClass)123456789101112131415161718192021222324252627282930private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; - 1. 我认为就是准备一个查找结果得存储对象 FindState findState = prepareFindState(); - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass 同时赋值给clazz变量中,以下代码能够看出// void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; // this.subscriberClass = clazz = subscriberClass;//&#125; findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123;进入循环中 //获取subscriberInfo 信息，返回null findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; - 3. 进入到这里了 findUsingReflectionInSingleClass(findState); &#125; - 4. 查找父类中的方法 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; findUsingReflectionInSingleClass 如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities - 1. 通过订阅者的字节码查找当前类中所有生命的方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; - 2. 循环遍历所有的方法 for (Method method : methods) &#123; - 3. 获取方法的修饰符 int modifiers = method.getModifiers(); - 4.判断修饰符，订阅方法的修饰符不能是private，static if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; - 5. 获取方法的所有的参数 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); - 6.判断参数的个数，只能有1个参数，订阅方法中 if (parameterTypes.length == 1) &#123; - 7.获取方法上具有subscribe 注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); - 8.含有subscribe注解的方法，就是该类订阅的方法，其它不符合的可能就是普通的方法 if (subscribeAnnotation != null) &#123; - 9. 获取第一个参数eventType Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; - 10. 获取注解的mode，就是我们在注解上标识的， 有mainThread,Posting,background,async ThreadMode threadMode = subscribeAnnotation.threadMode(); - 11. 将订阅方法的一系列信息（方法名称，threadMode,优先级，是否是粘性等）添加到集合subscriberMethods中去 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; - 12. 参数是多个的时候抛出异常 String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; - 13. 方法的修饰符不是public的，抛出异常 String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; 这样我们将所有信息都保存到findState 类中去了。再回头看我们原先那个方法,到第三步了：123456789101112131415161718192021222324252627282930private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; - 1. 我认为就是准备一个查找结果得存储对象 FindState findState = prepareFindState(); - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass 同时赋值给clazz变量中,以下代码能够看出// void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; // this.subscriberClass = clazz = subscriberClass;//&#125; findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123;进入循环中 //获取subscriberInfo 信息，返回null findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; - 3. 进入到这里了，上面已经分析所有信息保存到findState中 findUsingReflectionInSingleClass(findState); &#125; - 4. 查找父类中的方法 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 在这个getMethodsAndRelease(findState):123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; - 1. 取出里面的subscriberMethods List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; - 2. 返回集合 return subscriberMethods; &#125; 至此，我们知道了根据订阅者（subscriber）的clazz 找到了所有订阅的方法事件 methods 回到最初的第一步register:1234567891011public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); - 2. 完成 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; - 3.循环遍历所有的订阅方法和订阅者之间建立关联 subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; subscribe(subscriber, subscriberMethod) 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; - 1. 订阅方法的eventType的字节码 Class&lt;?&gt; eventType = subscriberMethod.eventType; - 2. 订阅者和订阅方法封装成一个Subscription 对象 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); - 3. subscriptionsByEventType 第一次也是null ,根据eventType CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); - 4. 第一次肯定为null if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); - 5. key 为 eventType, value 是subscriptions对象 subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; - 抛出异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; - 6. 获取所有添加的subscriptions int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; - 7. 会判断每个订阅方法的优先级，添加到这个 subscriptions中，按照优先级 if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; - 8.获取订阅的方法集合 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); - 9. 为空添加到 typesBySubscriber typesBySubscriber.put(subscriber, subscribedEvents); &#125; - 10. 订阅事件添加到subscribedEvents集合中去 subscribedEvents.add(eventType); - 11. 判断是否是粘性事件的关联 if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 到此，如果你跟着我一步步看到这里，应该大概明白一些了，还有一部分没完，就是register 前半部分完成订阅，存储等工作；剩下post(event) 方法就是将event 分发给相应订阅过此事件的订阅者了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask源码解读]]></title>
    <url>%2F2018%2F09%2F19%2FAsyncTask%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[屡思路 1. 初始 AsyncTaskAsyncTask 这个类的声明如下：1234public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; .....&#125; 是一个抽象类Params 表示输入参数的类型Progress 表示后台任务的执行进度Result 表示返回结果的类型 2.使用 在 AsyncTask 这个类的顶部有一些代码注释，里面讲述了如何使用一个 AsyncTask,如下：123456789101112131415161718192021222324252627282930* &lt;p&gt;Here is an example of subclassing:&lt;/p&gt; * &lt;pre class=&quot;prettyprint&quot;&gt; * private class DownloadFilesTask extends AsyncTask&amp;lt;URL, Integer, Long&amp;gt; &#123; * protected Long doInBackground(URL... urls) &#123; * int count = urls.length; * long totalSize = 0; * for (int i = 0; i &lt; count; i++) &#123; * totalSize += Downloader.downloadFile(urls[i]); * publishProgress((int) ((i / (float) count) * 100)); * // Escape early if cancel() is called * if (isCancelled()) break; * &#125; * return totalSize; * &#125; * * protected void onProgressUpdate(Integer... progress) &#123; * setProgressPercent(progress[0]); * &#125; * * protected void onPostExecute(Long result) &#123; * showDialog(&quot;Downloaded &quot; + result + &quot; bytes&quot;); * &#125; * &#125; * &lt;/pre&gt;//user&lt;p&gt;Once created, a task is executed very simply:&lt;/p&gt; * &lt;pre class=&quot;prettyprint&quot;&gt; * new DownloadFilesTask().execute(url1, url2, url3); * &lt;/pre&gt; 3. 内部重要方法 onPreExecute()123@MainThread protected void onPreExecute() &#123; &#125; 在主线程中运行，异步任务之前会被调用，一般用于做一些准备工作； doInBackground()12@WorkerThread protected abstract Result doInBackground(Params... params); 在线程池中运行，此方法一般用于执行异步任务，通过publishProgress 方法来更新进度； onProgressUpdate()123@MainThread protected void onProgressUpdate(Progress... values) &#123; &#125; 主线程中运行，当通过publishProgress 方法调用后，onProgressUpdate() 方法会被调用； onPostExecute()123@MainThread protected void onPostExecute(Result result) &#123; &#125; 主线程中运行，将返回的结果展示。 4.源码分析从它的 execute 方法开始：12345678 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; //sDefaultExecutor 定义如下，线程池 return executeOnExecutor(sDefaultExecutor, params); &#125;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 1234567891011121314151617181920212223242526@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; //首先判断是不是 PENDING if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; //将状态设置为 RUNNING 状态 mStatus = Status.RUNNING; //1.调用了 onPreExecute() 方法 onPreExecute(); //将参数封装到 mWorker.mParams 中去了 mWorker.mParams = params; //调用execute 将mFuture 传进去了 exec.execute(mFuture); return this; &#125; 为了弄明白整体流程，首页要搞明白上面的 mWorker mFuture 是干嘛的。 mWorker 1234567891011121314151617 private final WorkerRunnable&lt;Params, Result&gt; mWorker;//抽象类 并且实现了Callable 接口private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams; &#125; @SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//在AsyncTask 的构造方法中，分别对 mWorker, mFuture 进行了初始化public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; //实现 了 call 方法 public Result call() throws Exception &#123; //设置调用了为 true mTaskInvoked.set(true); // Result result = null; try &#123; //设置线程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked //将 2. doInBackground的结果存储到 result 中 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; //最后执行postResult postResult(result); &#125; //返回结果 return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; postResult(result) 方法1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 发送一条 MESSAGE_POST_RESULT 的消息，并且将result 存入到了 AsyncTaskResult中的 mData 中去了，其中 AsyncTaskResult12345678910@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125; getHandler 获取一个 Handler ,我们看下 handleMessage 的MESSAGE_POST_RESULT 对这条消息的处理：123456789101112131415161718192021private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: //是他是他 就是他 // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 其中 result 是 AsyncTaskResult 类型，前面我们见到过的，mTask 当时我们传的是 this 也就是当前的 AsyncTask ,调用finish 方法，将mData 返回的结果传入进去，还记得我们前面看过的吗，将返回的结果存入AsyncTaskResult.mData中去了。 下面看下 finish方法：1234567891011private void finish(Result result) &#123; //判断是否取消，如果取消了，就不执行onPostExecute 了 if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; //4. 就执行onPostExecute 方法了 onPostExecute(result); &#125; // 将状态标志为 finish mStatus = Status.FINISHED; &#125; ok ，上述都是 mWorker 工作的，接下来是我们一开始说的 mFuture mFuture123456789101112131415161718private final FutureTask&lt;Result&gt; mFuture;//初始化也是在AsyncTask 构造方法中执行的，在mWorker 之下，并且将mWorder 传入mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; postResultIfNotInvoked(get()); 如下：1234567891011private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); //wasTaskInvoked 为true ,之前在 mWorker 中设置了为true//mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;// public Result call() throws Exception &#123; // mTaskInvoked.set(true); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; FutureTask :123456789101112131415161718192021222324252627282930313233343536373839404142我们知道mWorker implement Callable 接口，传入赋值给了callable 变量 public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125;public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; //callable 变量又赋值给了 c Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; //这里调用c.call 实际上就是调用 mWorker.call 方法//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; ok ，这是 mFuture,还剩下最后一个： exec.execute(mFuture); exec 就是 sDefaultExecutor ,其实 就是 SerialExecutor,如下：123private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); SerialExecutor 如下：123456789101112131415161718192021222324252627private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); //第一次肯定为null ，执行 scheduleNext if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; //给 mActivie 赋值，mTasks.poll 会从第一个开始取 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 上面我们将 mFuture 传入，实际就是 r.mTask 是 ArrayDeque&lt;Runnable&gt; 姑且认为它是这个排队序列的吧。看下offer 方法：12345678910111213/** 插入一个 element 在队尾 * Inserts the specified element at the end of this deque. * * &lt;p&gt;This method is equivalent to &#123;@link #offerLast&#125;. * * @param e the element to add * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;) * @throws NullPointerException if the specified element is null */ public boolean offer(E e) &#123; return offerLast(e); &#125; 看注释，也就是说是每次执行一个任务，都是在当前 deque 的队尾开始排队的。并且执行是串行的，因为当第二个线程过来的时候，判断 mActive 不为 null 将不会执行 scheduleNext.(我这个是8.0)源码，其实在 android 3.0 之后 AsyncTask 都是采用串行执行任务的。 各个版本的不同如下：android 1.6之前 —— 串行android 1.6-3.0 之间 —– 并行android 3.0 之后 —– 串行 尽管如此，我们仍然可以通过 调用 executeOnExecutor 来并行执行任务。 ok ， 回到那个 execute 方法中，我们说调用了 r.run 实际山就是 调用 mFuture.run 方法：上面我们展示过在 mFuture.run 方法中如下： 12345678910try &#123; //这里调用c.call 实际上就是调用 mWorker.call 方法//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; 最终调用mWorker.call 方法，而在 mWorker.call 方法中，我们完成一系列的任务，调用了 doInBackground onPostExecute 完成了整个的调用过程。 有的人可能已经注意到了 还差一个 onProgressUpdate 方法还没被调用，我们知道只有调用那个 publishProgress 方法的时候才能调用 onProgressUpdate ,那下面我们卡夏 publishProgress 方法：12345678@WorkerThread protected final void publishProgress(Progress... values) &#123; //如果没取消 if (!isCancelled()) &#123; //会发送一个 MESSAGE_POST_PROGRESS 的消息 getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; 123456789101112131415161718192021private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS://是他是他 就是他 //3. 调用了 onProgressUpdate 方法了 result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 会调用 AsyncTask 的 onProgressUpdate 方法了。结束。 总结 AsyncTask 实现原理就内部维护了2个线程池+Handlder，2个线程池分别为：任务队列 线程池（SerialExecutor）,执行 线程池（Thread_pool_executor）真正执行具体的线程任务，任务完成最后通过 InternalHandler 发送消息 ，将执行任务的结果post 到主线程中。此线程池中执行任务的顺序，根据不同 api 版本的不同顺序略有不同，在android 1.6之前，是串行执行任务，在 Android 1.6-3.0 之间通过并行执行任务，Android 3.0之后就是默认串行执行任务了，当然我们也可以通过调用executeOnExecuteor 并行执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Service 启动过程]]></title>
    <url>%2F2018%2F09%2F11%2FService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[看完 Activity 的启动过程，发现 Service 的启动过程相对来说就比较简单了。 要说起启动过程，就得从 startService 开始： 1.startService根据源码的跳转，发现跳转到 ContextWrapper 这个类中，代码如下：1234@Override public ComponentName startService(Intent service) &#123; return mBase.startService(service); &#125; 其中 mBase 是类型是：Context 类型，如下：1234public class ContextWrapper extends Context &#123; Context mBase; ......&#125; 而我们又知道 Context 是一个抽象类 ，实现者是 ContextImpl ,所以我们应该是查看ContextImpl 这个类中的 startService(service) 方法。 ContextImpl 中的方法定义如下：12345@Override public ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser); &#125; 在 startService 中又调用了 startServiceCommon(service,(requirForeground:false),mUser) 这个方法，继续跟进： 2.startServiceCommonstartServiceCommon 方法如下：1234567891011121314151617181920212223242526272829private ComponentName startServiceCommon(Intent service, boolean requireForeground, UserHandle user) &#123; try &#123; //校验要启动的service validateServiceIntent(service); service.prepareToLeaveProcess(this); ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(&quot;!&quot;)) &#123; throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123; throw new SecurityException( &quot;Unable to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123; throw new IllegalStateException( &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 这里面有几个需要说明一下： ActivityManager.getService() 点进去查看12345678910111213141516/** * @hide */ public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 首先是返回的类型是 IActivityManager 类型，其中在create 方法中，拿到远程服务的Binder 对象，其中IActivityManager.Stub.asInterface(b) 不知道大家有没有想起AIDL 这就很熟悉了，就是拿到远程服务的代理对象：IActivityManager,通过代理对象调用远程的方法，是应用进程与服务进程通信的媒介，如果没猜错的话就是在ActivityManagerService 中实现了，查看ActivityManagerService 类：1234public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;.....&#125; 果然不出所料，AMS extend IActivityManager.Stub . mMainThread.getApplicationThread() 首先明白 mMainThread 是 ActivityThread 类的实例变量，通过getApplicationThread() 方法拿到一个 ApplicationThread 类的实例：1234public ApplicationThread getApplicationThread() &#123; return mAppThread; &#125; 而ApplicationThread 类定义如下：123private class ApplicationThread extends IApplicationThread.Stub &#123;.....&#125; 发现 ApplicationThread 是 ActivityThread 的一个内部类.并且实现了 IApplicationThread.Stub ,而我们又把这个类型传入给了AMS,相当于远程服务拿到了一个访问应用进程的代理，类型为：IApplicationThread 总结：到目前为止，客户端拿到了远程服务的代理（IActivityManager）, 服务端拿到了客户端的代理（IApplicationThread）,它们互相拿到各自进程的代理类，是它们进行进程间通信的基础。 ok ,我们回到最初那个地方：1234ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); 通过前面的分析我们知道：ActivityManager.getService(). 实际就是 AMS 远程代理，最终在AMS 中完成，我们去 AMS 代码中查看下 startService 代码： 3.ActivityManagerService. startService1234567891011121314151617181920212223242526272829303132@Override public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(&quot;startService&quot;); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;); &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res; try &#123; // 又调用了startServiceLocked 方法 res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return res; &#125; &#125; startServiceLocked 方法很复杂，大概如下：1234567891011ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId) throws TransactionTooLargeException &#123;.....ServiceRecord r = res.record;//启动service的信息保存在 serviceRecord 中.... ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); return cmp;.....&#125; 内部又调用了：startServiceInnerLocked 方法 4.startServiceInnerLocked如下：123456ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;... String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);...&#125; 又调用： bringUpServiceLocked 5.bringUpServiceLocked1234567 private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123;....realStartServiceLocked(r, app, execInFg);&#125; 而后又调用了 realStartServiceLocked(r, app, execInFg); 6.realStartServiceLocked12345678private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; .... app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); ....&#125; 其中 app.thread 是 IApplicationThread 类型，就是远程调用客户端进程里的方法，scheduleCreateService ,而我们又知道 ApplicationThread 实现了 IApplicationThread，所以就查看 ApplicationThread 类中的 scheduleCreateService方法，前面我们说过ApplicationThread 是 ActivityThread 的一个内部类，查看： 7.ApplicationThread.scheduleCreateService12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s); &#125; 发现内部通过发送一个 CREATE_SERVICE 的消息，H 是 Handle,继续查看：handleMessage 方法 12345case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; 到 handleCreateService 中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name); //创建context ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); //创建Application Application app = packageInfo.makeApplication(false, mInstrumentation); //通过attach 方法，将context application ，service 连接起来 service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); //调用service oncreate方法 service.onCreate(); mServices.put(data.token, service); try &#123; ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to create service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125; service.onCreate(); ok ，调用了 onCreate 方法，至此，service的启动过程的就完成了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[TransitionDrawable]]></title>
    <url>%2F2018%2F08%2F16%2FTransitionDrawable%2F</url>
    <content type="text"><![CDATA[1.首先创建一个xml 在 drawable 目录下 transition_image 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/first" /&gt; &lt;item android:drawable="@drawable/two" /&gt;&lt;/transition&gt; 2.在xml中引用 1android:drawable="@drawable/transition_image" 3.在Activity中使用 123ImageView mImageView = (ImageView) findViewById(R.id.iv); TransitionDrawable transitionDrawable = (TransitionDrawable) mImageView.getDrawable(); transitionDrawable.startTransition(3000) 另外一种写法实现多张图片效果123TransitionDrawable transitionDrawable = new TransitionDrawable(new Drawable[]&#123;getResources().getDrawable(R.drawable.first),getResources().getDrawable(R.drawable.two)&#125;);mImageView.setImageDrawable(transitionDrawable);transitionDrawable.startTransition(3000);]]></content>
      <tags>
        <tag>两个Drawable之间淡入淡出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的爬坑之路]]></title>
    <url>%2F2018%2F07%2F05%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[近期由于项目需要，需要编写小程序，遇到一些问题，记录下来，也是给自己开发的一个总结。 1.关于模板 template在看完 官方文档 里的说明之后，我并没有成功使用，按照它那个设置完成后，一直说找不到，最后在知道，原来除了实例那些之外，还要在当前 wxml 中 import 进来。 1.先建一个 template 的文件夹，新建 wxml,根据具体的路径引入进来，例如：1&lt;import src=&quot;../template/line.wxml&quot; /&gt; 还有一个就是如果有相对应的 wxss文件，可在 app.wxss文件中引用，这样整个项目都不需要引用这个样式文件了。 注意：模板拥有自己的作用域，只能使用 data 传入的数据以及模版定义文件中定义的 模块。 2. 关于水平居中，垂直居中一开始感觉这啥玩意，不听话啊，让居中也不居中，就是不动啊，很是郁闷，后来发现了一些规律。 2.1 水平居中 首先如果是行内元素，例如 这样的，如果想水平居中，使用text-align:center 你会发现不好使啊，纹丝不动，原因是因为行内元素长度随内容变化，所以它不能让你在一行的中间，因为它的长度就是文字长度。 解决方案：可以换成view 控件，或者使用：display:block + text-align:center 其它元素可以使用123456======3个一起使用==========text-align:center;align-items:center;justify-content: center;==================margin:auto # 子容器在父容器中居中,单独使用 2.2 垂直居中1234//可使用如下display:flex;align-items:center;justify-content:center; 3.关于几个控件平分整个屏幕宽度问题 一开始我还想着获取屏幕的宽和高，然后再动态给控件设置具体的值，后来发现有更简单的做法 例如：像这样一行排四个 解决方案：设置控件的宽度为 ：25%，这样就自动平分啦。当然还有其它的方式，但是我认为百分比的这种写法感觉很直观。 4. flex 布局熟练掌握 flexbox 布局，可以更轻松的编写任何常见的布局，可以查看相关专业的文章。 未完待续…..]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-可观察属性]]></title>
    <url>%2F2018%2F06%2F27%2FKotlin-%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[类似于观察者模式，当所监测的对象发生改变时，能够收到回调通知。 例如：我们监测一个变量：123456789var str: String by Delegates.observable("qianqian",&#123; property: KProperty&lt;*&gt;, oldValue: String, newValue: String -&gt; Log.i("xx","改变的属性名称：$&#123;property.name&#125; --- $&#123;oldValue&#125; -- $&#123;newValue&#125;" ) &#125;) //点击一个按钮，改变str的值 fun foo(view : View)&#123; str = "haha" &#125; 这时候我们会发现，当改变str 的值的时候，会打印信息，也就是收到回调：1改变的属性名称：str --- qianqian -- haha 再比如：检测对象里的其中一个属性：1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable("&lt;no name&gt;") &#123; prop, old, new -&gt; println("$old -&gt; $new") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "first" user.name = "second"&#125; 打印信息：12&lt;no name&gt; -&gt; firstfirst -&gt; second]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin let with run also apply区分]]></title>
    <url>%2F2018%2F04%2F28%2FKotlin-let-with-run-also-apply%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[apply它与其它特殊之处在于，它返回本省对象： 1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;&#125; 例如： 123456ArrayList&lt;String&gt;().apply &#123; add("qq") add("mi") &#125;.let &#123;//this-&gt;ArrayList本身 Log.i("xx","list==="+it) &#125; 打印结果： 1list===[qq, mi] 这里T 就是 ArrayList&lt;String&gt;() 返回对象本身，也就是ArrayList 内部是 this 还是 it 这个倒没什么，编辑器一般都会有提示，如图： apply 是 this , also 是 it run run: 1public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;&#125; 返回最后一行，传入block 返回 最后一行，例如： 1234567ArrayList&lt;String&gt;().run &#123; add("lala") add("kaka") this.get(1) &#125;.let &#123; Log.i("xx","返回：："+it) &#125; 打印： 1返回：：kaka let1public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;&#125; 也是返回最后一行，但是它内部不能调用对象的方法： 123456fun letGo(): Int&#123; "qianqian".let &#123; Log.i("xx",it) return 1 &#125; &#125; 调用letGO 返回 1 with类似于：apply + let 的结合 1public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;&#125; 例如： 1234567with(ArrayList&lt;String&gt;())&#123; add("haha") add("heihei") this//最后返回ArrayList对象 &#125;.let &#123; Log.i("xx","list==="+it)//打印：[haha,heihei] &#125;]]></content>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取手机屏幕的密度]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AF%86%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[目前有两种方式，一种是根据手机的分辨率计算，另外一种是通过代码获取。 第一种：根据手机分辨率进行计算(计算得出实际的dpi)比如我的手机魅族分辨率是：1920*1080，屏幕尺寸大小是：5.5寸的，那么计算：(宽的平方+高的平方之后开根号，最后除以屏幕的尺寸)dpi = (√1920^2+1080^2 ) / 5.5 ≈ 401 参照下图： ldpi（低240*320）~120dpi density=0.75 mdpi（中320*480）~160dpi density=1 hdpi（高480*800）~240dpi density=1.5 xhdpi（超高720*1080）~320dpi density=2 xxhdpi（超超高1080*1920）~480dpi density=3 xxxhdpi（超超超高）~640dpi density=4 对应图片的目录应该是：xxhdpi 第二种：通过代码方式(系统定义的dpi)12float xdpi = getResources().getDisplayMetrics().xdpi;float ydpi = getResources().getDisplayMetrics().ydpi; 不同手机获取的xdpi ydpi 值有的一模一样，有的有些差异，但是相差不会太大，两者获取的值近乎一样。 两者计算出的结果并不完全相同，因为你们想，实际计算得出的dpi 很容易根据屏幕尺寸的不同，得出不同的dpi ，这样的话得到的值很多，无法适配。我查阅网上相关介绍，就是每个手机初始有一个固定的dpi ，分别是上述的：120，160，240，320，480，640，安卓实际进行缩放的时候按照的是系统定义的这些，而不是实际计算得出的dpi,这一点需要注意。 像素和dp之间的转化12345px = dp * desity// 这里的dpi就是上述第一种的计算方法//dpi = (√1920^2+1080^2 ) / 5.5(屏幕尺寸) ≈ 401desity = dpi / 160所以：px = dp * (dpi/160) DisplayMetrics.java 123DisplayMetrics#density //就是我们熟知的desityDisplayMetrics#densityDpi //dpiDisplayMetrics#scaleDensity //字体缩放因子，正常情况下和density相同，但是我手动调整字体大小后会改变这个值 关于手机的 density 可以在 /system/build.prop 文件中查看的定义值： 1ro.sf.lcd_density=480 // 这个字段 这个定义的数值，可能会跟计算得到的density 不相同。]]></content>
      <tags>
        <tag>dpi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus 为什么订阅的方法必须是public？]]></title>
    <url>%2F2018%2F04%2F08%2FEventBus-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A2%E9%98%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在看了源码之后发现是这样的：12345678910111213141516171819202122232425262728293031323334353637383940private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities //获取所有声明的方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; //获取方法的标识符 int modifiers = method.getModifiers(); //方法的标识符必须是public if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; //否则抛出异常 ，说这个方法必须加上@Subscribe ,并且是public 的，不能是静态的，抽象的 String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125; &#125; 然后就没有然后了，之前怀疑private 修饰的方法，反射后不能被其他类调用，后来查了相关资料，发现可以，后来去网上寻找无果，后来在我微信关注的公众号里，群主伯特说：虽然可以反射调用private 的方法，但是必须通过setAccess来修改访问权限。说是修改，实则破坏了java中的作用域，迫不得已不推荐这么做。EventBus 作为三方库，显然不会在你设置为private 时，好心办坏事，强制访问。 仅此而已，仅此而已。分享给还不知道的童鞋。]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity状态保存与恢复]]></title>
    <url>%2F2018%2F03%2F23%2FActivity%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Activity状态保存与恢复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件是什么与它们的生命周期（及Fragment）]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%8F%8AFragment%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先当我们一开始学习安卓的时候想必就是四大组件了以及它们的生命周期，现在就来复习回想下。 四大组件有：Activity, ContentProvider, BroadcastReceiver, Service Activity 提供与用户交互的界面或者可以说是一个窗口 下面我是从官方文档中关于Activity生命周期 的一张图 正常启动时：onCreate() -&gt; onStart() -&gt; onResume() 而后我们看到当 Another activity comes into the foreground 执行 onPause() 方法当按 home 键的时候： 当前Activity 已经不可见了，所以执行：onPause() -&gt; onStop() 当重新回到app时，分为两种情况就是：①是app还在后台，执行：onRestart() -&gt; onStart() -&gt; onResume(); ②是app被系统杀死了，则执行：onCreate() -&gt; onStart() &gt; onResume() 当在app 里 从 A -&gt; B 此时A隐藏，B显示，当重新返回A 时，执行：onPause() -&gt; onResume(),这种应用场景一般是比如需要返回做刷新操作的，可以将刷新方法写在onResume() 方法中执行。 最后当退出应用程序的时候执行 onDestroy() Service 服务，有前台服务和后台服务，一般提供需在后台长期运行的服务，例如：音乐播放器等 它的生命周期如下图： 因为启动服务的方法有两个：startService() 和 bindService() 两者的生命周期略有不同。 首先来看：startService() 方式启动：onCreate() -&gt; onStartCommand() 调用stopServcie() 停止服务，随后执行 onDestroy() 其次是：bindService() 方式启动：onCreate() -&gt; onBind() 服务启动起来了，调用unbindService() 停止服务，随后执行 onUnbind() -&gt; onDestroy() Broadcastreceiver 广播，可以接受来自应用内或者应用外的广播，分为两个角色：广播发送者，广播接收者 广播的注册方式有两种：一种是代码注册，一种是清单文件注册，代码注册的优先级要比清单文件注册的优先级要高； 广播的发送可以是有序广播也可以是无序广播，有序广播接收到广播的顺序按照优先级的顺序； 注意广播接收器onReceive() 方法运行在 UI 线程中，不可以做耗时操作，否则会导致ANR异常； ContentProvider 内容提供者，应用内数据共享 Fragment 一般和 viewpager 配合使用，不能单独使用，要配合Activity使用，但是有自己的生命周期 一般在onAttach()中获取参数值一些，onCreateView()中创建布局，布局加载完成后在onActivityCreated()中执行一些初始化操作，随后onStart(),onResume().onPause(),onStop(), fragment 销毁，onDestroyView() -&gt; onDestroy() -&gt;onDetach()]]></content>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点总结]]></title>
    <url>%2F2018%2F03%2F22%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[网上别人列出一些来，我把它拿过来了，需要自己一项一项复习查阅，以后有会继续添加新的，特此总结。 四大组件是什么与它们的生命周期（及Fragment）; Acitivty的四种启动模式与特点。 获取手机屏幕的密度 Activity状态保存与恢复。 Service的生命周期，启动方法，有什么区别。 service和activity怎么进行数据交互。 怎么保证service不被杀死。 广播使用的方式和场景以及广播的几种分类。 Intent的使用方法，可以传递哪些数据类型。 ContentProvider使用方法。 ContentProvider、ContentResolver、ContentObserver 之间的关系。 Thread、AsycTask、IntentService的使用场景与特点。 FrameLayout 、 LinearLayout 、 RelativeLayout 各自特点及绘制效率对比。 Android的数据存储形式。 Android两种序列化的区别和作用。 Sqlite的基本操作。 Android中的MVC、MVP模式。 Merge、ViewStub的作用。 动画有哪几类，各有什么特点？ Handler、Loop消息队列模型，各部分的作用。 Android的消息机制，子线程更新UI的方法和原理。 Android怎么加速启动Activity。 App的启动过程。 Android优化方法。 如何防止内存泄漏？ Android中弱引用与软引用的应用场景。 Bitmap的四种属性，如何加载大图（inJustDecodeBounds）。 View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。 View刷新机制和绘制流程。 Activity、Window、View的联系和理解。 invalidate和requestLayout的区别及使用。 Touch事件分发机制和冲突处理。 Android IPC:Binder原理。 Android5.0（UI库）、6.0（权限）、7.0特性、8.0特性。]]></content>
      <tags>
        <tag>Android知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 传递数据]]></title>
    <url>%2F2018%2F03%2F14%2FKotlin-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[今天在掘金看到使用 Kotlin 高阶函数传递Intent 数据很简洁，觉着可以试试，并应用到项目中去，自己再加以理解，记录笔记，方便查阅。掘金原文章地址：https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw 传统的Intent 数据传递我就不介绍了，只介绍Kotlin实现方式：123456789101112131415161718192021//目标 假设叫`KTestActivity4` 定义 object IntentOptions&#123; private const val MSG_KEY = "key for message" var Intent.message: String? get() = getStringExtra(MSG_KEY) set(message) &#123; putExtra(MSG_KEY,message) &#125; &#125;//跳转时 with(KTestActivity4.IntentOptions)&#123; intent = Intent(this@KTestActivity5,KTestActivity4::class.java) intent.message = "I am KTestActivity5" startActivity(intent) &#125;//使用with(IntentOptions)&#123; var message= intent.message Toast.makeText(this@KTestActivity4,"显示信息："+message,Toast.LENGTH_SHORT).show() &#125; 假设有多个数据传递：1234567891011121314151617181920212223object IntentOptions&#123; private const val MSG_KEY = "key for message" private const val MSG_ID = "ID for message" var Intent.message: String? get() = getStringExtra(MSG_KEY) set(message) &#123; putExtra(MSG_KEY,message) &#125; // 再多增加一条即可 var Intent.id: String? get() = getStringExtra(MSG_ID) set(id) &#123; putExtra(MSG_ID,id) &#125; &#125;// 传递时with(KTestActivity4.IntentOptions)&#123; intent = Intent(this@KTestActivity5,KTestActivity4::class.java) intent.message = "I am KTestActivity5" intent.id = "I am id" startActivity(intent) &#125; 还有另外一种传递方式：委托机制，不是特别明白。国外大神封装的github地址：https://github.com/Takhion/android-extras-delegates]]></content>
      <tags>
        <tag>Kotlin#Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴Android开发手册]]></title>
    <url>%2F2018%2F03%2F13%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Android%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[摘自阿里巴巴Android开发手册 强制要求的 1. Activity 间的数据通信，对于数据量比较大的，避免使用 intent + Parcelable 的方式，可以考虑 EventBus等替代方案，以免造成 TransationTooLargeException 2. Activity 间通过隐士 Intent的跳转，在发出 Intent 之前必须通过 resolveActivity 检查，避免找不到合适的调用组件，造成 ActivityNotFoundException 的异常。 12345678910 public void viewUrl(String url, String mimeType) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(Uri.parse(url), mimeType); if (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; startActivity(intent); &#125;else &#123; // 找不到指定的 Activity &#125;&#125; 而不应该：1234567Intent intent = new Intent();intent.setAction("com.example.DemoIntent ");try &#123; startActivity(intent);&#125; catch (ActivityNotFoundException e) &#123; e.printStackTrace();&#125; 3. 避免在Service#onStartCommand/onBind()方法中执行耗时操作，如果确实有需求，应采用IntentService 或采用其他异步机制完成。正例： 12345678910111213141516171819202122232425public class MainActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; public void startIntentService(View source) &#123; Intent intent = new Intent(this, MyIntentService.class); startService(intent); &#125;&#125;public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService"); &#125; @Override protected void onHandleIntent(Intent intent) &#123; synchronized (this) &#123; try &#123;...... &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; 4. 避免在 BroadcastReceive#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService完成，而不应该在BroadcastReceiver 内创建子线程去做。 说明：由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅，可以使用 IntentService,创建 HanlderThread 或者调用 Context#registerReceiver(BroadcastReceiver,IntentFitter,String,Handler) 方法等方式，在其他 Worker 线程执行 onReceive.BroadcastReceiver#onReceive() 方法耗时超过10秒钟，可能会被系统杀死。正例： 1234567891011IntentFilter filter = new IntentFilter();filter.addAction(LOGIN_SUCCESS);this.registerReceiver(mBroadcastReceiver, filter);mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; Intent userHomeIntent = new Intent(); userHomeIntent.setClass(this, UserHomeService.class); this.startService(userHomeIntent); &#125;&#125;; 反例：123456789mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; MyDatabaseHelper myDB = new MyDatabaseHelper(context); myDB.initData(); // have more database operation here &#125;&#125;; 5. 避免使用隐士 Intent 广播敏感信息，信息可能被其他注册了对应 BroadcastReceiver 的App接收。 说明：通过Context#sendBroadcast()发送的隐士广播会被感兴趣的 receiver 接收，恶意应用注册监听该广播的 receiver可能会获取到 Intent 中传递的敏感信息，并进行其他危险操作。如果发送的广播为使用 Context#sendOrderedBroadcast()方法发送的有序广播，优先级较高的恶意 receiver可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。 如果广播仅限于应用内，则可以是iyongLocalBroadcastManager#sendBroadcast()实现，避免敏感信息外泄和intent拦截的风险。 正例：123Intent intent = new Intent("my-sensitive-event");intent.putExtra("event", "this is a test event");LocalBroadcastManager.getInstance(this).sendBroadcast(intent); 反例：1234567891011Intent intent = new Intent();v1.setAction("com.sample.action.server_running");v1.putExtra("local_ip", v0.h);v1.putExtra("port", v0.i);v1.putExtra("code", v0.g);v1.putExtra("connected", v0.s);v1.putExtra("pwd_predefined", v0.r);if (!TextUtils.isEmpty(v0.t)) &#123; v1.putExtra("connected_usr", v0.t);&#125;context.sendBroadcast(v1); 以上广播可能被其他应用的如下 receiver 接收导致敏感信息泄露：12345678910111213final class MyReceiver extends BroadcastReceiver &#123; public final void onReceive(Context context, Intent intent) &#123; if (intent != null &amp;&amp; intent.getAction() != null) &#123; String s = intent.getAction(); if (s.equals("com.sample.action.server_running") &#123; String ip = intent.getStringExtra("local_ip"); String pwd = intent.getStringExtra("code"); String port = intent.getIntExtra("port", 8888); boolean status = intent.getBooleanExtra("connected", false); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>阿里巴巴Android开发手册规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听键盘显示与隐藏]]></title>
    <url>%2F2018%2F03%2F08%2F%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[项目中有时候需要监听keyboard的显示与隐藏，特此备注，方便使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class KeyboardWatcher &#123; private ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener; private View rootView; private int viewSize = -1; private boolean isShowing = false; private OnKeyboardListener onKeyboardListener; public KeyboardWatcher(Activity activity)&#123; rootView = activity.getWindow().getDecorView().getRootView(); &#125; public KeyboardWatcher register(OnKeyboardListener listener)&#123; onKeyboardListener = listener; if(onGlobalLayoutListener == null) &#123; onGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect r = new Rect(); rootView.getWindowVisibleDisplayFrame(r); int viewHeight = r.bottom - r.top; if(viewSize &lt; 0)&#123; viewSize = viewHeight; return; &#125; if(viewHeight != viewSize)&#123; // 大于100dp才算变化 if(Math.abs(viewHeight - viewSize) &gt; dpToPx(rootView.getContext(),100)) &#123; if (viewHeight &lt; viewSize &amp;&amp; !isShowing) &#123; onKeyboardListener.onShow(viewHeight); isShowing = true; &#125; else if(isShowing)&#123; onKeyboardListener.onHide(); isShowing = false; &#125; &#125; viewSize = viewHeight; &#125; &#125; &#125;; &#125; rootView.post(new Runnable() &#123; @Override public void run() &#123; viewSize = rootView.getHeight(); rootView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener); &#125; &#125;); return this; &#125; public void unRegister()&#123; rootView.getViewTreeObserver().removeGlobalOnLayoutListener(onGlobalLayoutListener); rootView = null; &#125; public interface OnKeyboardListener&#123; void onShow(int viewSize); void onHide(); &#125; private int dpToPx(Context context,int dp) &#123; return (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, dp, context.getResources().getDisplayMetrics() ); &#125;&#125; 使用方法1234KeyBoardWatcher keyboardWatcher = new KeyboardWatcher()keyboardWatcher.register(this)//实现KeyboardWatcher.OnKeyboardListener接口//实现方法onShow() , onHide(),对应键盘的显示与隐藏]]></content>
      <tags>
        <tag>keyboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment 懒加载]]></title>
    <url>%2F2018%2F02%2F28%2FFragment-%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[因为项目中经常用到tabLayout + viewpager 结合使用，页面切换时要用到延迟加载的情况，所以单独写出一个demo，方便查看和便于使用 1.首先新建一个BaseLazyFragment/** * Created by xuqianqian on 2018/2/28. */ public abstract class BaseLazyFragment extends Fragment { protected View mRootView; public Context mContext; protected boolean isVisible; private boolean isPrepared; private boolean isLoad = false; //最先执行 @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (getUserVisibleHint()) {//当前显示 isVisible = true; if(!isLoad){ lazyLoad(); } } else { isVisible = false; //onInvisible(); } } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mContext = getActivity(); setHasOptionsMenu(true); } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { if (mRootView == null) { mRootView = getLayout(); } return mRootView; } @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); isPrepared = true; //如果已经加载过了，就无需再重新加载 if(!isLoad){ lazyLoad(); } } /** * 懒加载 */ protected void lazyLoad() { if (!isPrepared || !isVisible) { return; } isLoad = true; initData(); } // protected void onInvisible() { // // } //初始化布局View public abstract View getLayout(); public abstract void initData(); } 2.让你的fragment extend BaseLazyFragmentpublic class GankFragment extends BaseLazyFragment { String type; public static GankFragment newInstance(String type) { GankFragment gankFragment = new GankFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;type&quot;, type); gankFragment.setArguments(bundle); return gankFragment; } //加载布局 @Override public View getLayout() { type = getArguments().getString(&quot;type&quot;); TextView tv = new TextView(getActivity()); tv.setText(type); tv.setGravity(Gravity.CENTER); return tv; } @Override public void initData() { //初始化一些控件，加载网络数据 } } 3.剩下的就是FragmentPagerAdapter了public class TitleAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragments; private List&lt;String&gt; types; public TitleAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments, List&lt;String&gt; types) { super(fm); this.fragments = fragments; this.types = types; } @Override public Fragment getItem(int position) { return fragments.get(position); } @Override public int getCount() { return fragments.size(); } @Override public CharSequence getPageTitle(int position) { return types.get(position); } } MainActivity.java private List&lt;String&gt; titles = new ArrayList&lt;&gt;(); private List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;(); TitleAdapter titleAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TabLayout tablayout = findViewById(R.id.tablayout); ViewPager viewpager = findViewById(R.id.viewpager); titles.add(&quot;android&quot;); titles.add(&quot;ios&quot;); titles.add(&quot;web&quot;); titles.add(&quot;java&quot;); fragments.add(GankFragment.newInstance(&quot;android&quot;)); fragments.add(GankFragment.newInstance(&quot;ios&quot;)); fragments.add(GankFragment.newInstance(&quot;web&quot;)); fragments.add(GankFragment.newInstance(&quot;java&quot;)); titleAdapter = new TitleAdapter(getSupportFragmentManager(), fragments, titles); viewpager.setAdapter(titleAdapter); tablayout.setTabMode(TabLayout.MODE_FIXED); tablayout.setupWithViewPager(viewpager); } https://github.com/QQabby/LazyFragmentApplication]]></content>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog]]></title>
    <url>%2F2018%2F02%2F28%2FDialog%2F</url>
    <content type="text"><![CDATA[快速初始化materialDialognew MaterialDialog.Builder(mContext) .title(&quot;title&quot;) .content(&quot;I&apos;m a content&quot;) .negativeText(&quot;cancel&quot;) .negativeColorRes(R.color.colorNegative) .positiveText(&quot;ok&quot;) .positiveColorRes(R.color.colorPositive) .onPositive(new MaterialDialog.SingleButtonCallback() { @Override public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) { showMsg(&quot;click dialog ok&quot;); ... } }) .show();]]></content>
      <tags>
        <tag>materialDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序速查笔记]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这个微信小程序也出来好长时间了，一直想做一个属于自己的小程序，这不说动手就动手实现一个吧，比较简易，中间也遇到不少问题，记录一下，方便以后自己查阅。 微信小程序的结构 默认没有这么些文件夹的，只有index ，然后这个标识 app 开头的文件都是一些全局的设置。可以自己查看下，都有注释，就从这个配置开始说。 修改启动页面默认启动页面是index页面，如果要修改，打开app.json配置文件，在顶部你会发现有一个pages的配置，如下： &quot;pages&quot;: [ &quot;pages/home/home&quot; 只需要将我们的想要显示的页面的路径写在 第一个 就可以成为启动页，特别注意路径一定要正确。 当然你会新建很多页面，所有的页面都必须写在这个里面，不然跳转的时候会找不到。 底部tab栏切换就是底部tab栏切换,同样还是在app.json 配置文件中修改如下： &quot;tabBar&quot;: { &quot;color&quot;: &quot;#333333&quot;, &quot;selectedColor&quot;: &quot;#2B91D8&quot;, &quot;backgroundColor&quot;: &quot;#eee&quot;, &quot;borderStyle&quot;: &quot;white&quot;, &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_home_nor.png&quot;, &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_home_pre.png&quot; }, { &quot;pagePath&quot;: &quot;pages/myCenter/myCenter&quot;, &quot;text&quot;: &quot;我的&quot;, &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_center_nor.png&quot;, &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_center_pre.png&quot; } ] }, 这里的 pagePath 就是页面的路径，text文字，iconPath图标，注意图片一定要带后缀，selectedIconPath点击态的图标，各自换成你自己的就行，问题不会太大。 加载中如下： 有标签可以直接显示这个,在wxml文件中编写： &lt;loading hidden=&quot;{{hidden}}&quot; bindchange=&quot;loadingChange&quot;&gt; 加载中... &lt;/loading&gt; 可以控制显示还是隐藏，在.js文件中可以控制： data: { hidden: false, } 可以在data 底下配置默认值，hidden: false 默认不显示，赋值的时候必须在这里面写： that.setData({ hidden: true }) 网络请求 wx.request({ //网络请求地址url url: &apos;https://xx&apos;, header: { // &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &apos;content-type&apos;: &apos;application/json&apos; // &apos;content-type&apos;: &apos;text/xml&apos; }, //请求头参数配置 data: { page: pageNo, timestamp: timeStamps }, method: &quot;POST&quot;, success: function (res) { //xmlstring2json 是我使用第三方xml转json的一个库 var xml2json = require(&apos;..//lib/xmlstring2json/dist/xml2json&apos;); var json = JSON.stringify(xml2json(res.data), null, 4); var jsonObject = xml2json(res.data); var jokeObject = jsonObject.root.joke //timestamp if(pageNo == 0){ timeStamps = jsonObject.root.timestamp.text } // console.log(&apos;json::&apos; + jsonObject.root.timestamp.text) // var data = new Array(); // for (var i = 0; i &lt; jokeObject.length;i++){ // var text = JSON.stringify(jokeObject[i].text).replace(&quot;#&quot;, &quot;&quot;) // //JSON.parse(text).text // var value = JSON.parse(text).text; // data.push(value) // } // console.log(&apos;data::：&apos; + jokeObject[0].text.text ); // var l = jokeObject; var l; if(pageNo == 0){ l = jokeObject }else{ var l = that.data.list; for (var i = 0; i &lt; jokeObject.length; i++) { l.push(jokeObject[i]) } } //页面绑定的数据赋值 that.setData({ list: l }) pageNo++ that.setData({ hidden: true }) }, fail : function(s){ wx.showModal({ title: &apos;提示&apos;, content: &apos;请求接口失败&apos; + JSON.stringify(s) }) } 要进行网络请求，首先测试阶段可以将开发工具里的： 最后一个选项勾选上，不校验…,同时管理员还需在后台配置网络请求的域名，两个缺一不可。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给TextView上的drawable上的图片添加动画？]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%A6%82%E4%BD%95%E7%BB%99TextView%E4%B8%8A%E7%9A%84drawableEnd%E7%AD%89%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[可能你遇到过这样的场景，就是在 xml 里，给TextView添加了一个drawableLeft或者drawableRight等，你想给这个图片添加一个动画，然而你会发现当你给这个TextView加动画吧并不是我们想要的，我们只想要那个图片做动画，文字不需要做任何动画，目前可以有两种做法。 第一种做法 也是比较通俗的方法，说这个drawable 单独弄成ImageView不就好了，在xml里新增一个ImageView 是吧，干嘛非要加在一个标签里面，要相信布局都是很强大的，肯定可以实现效果。 第二种做法 你说真的没办法，必须写在一个里面，也是有办法的，那就不能在xml里设置drawableLeft了，代码设置，如下： 123AnimationDrawable d = (AnimationDrawable) getResources().getDrawable(R.drawable.animation_draw); d.setBounds(0,0,d.getIntrinsicWidth(),d.getIntrinsicHeight()); messageText.setCompoundDrawables(d, null, null, null); 这个具体的动画在这个animation_draw里，如下： 12345678&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot; android:duration=&quot;500&quot; /&gt;&lt;/animation-list&gt; 这是一个帧动画，里面可以放很多的item,从而形成动画,碰到了这种情况记录下，方便以后查阅。]]></content>
      <tags>
        <tag>add animation to drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O 新特性 AutoSizing]]></title>
    <url>%2F2018%2F01%2F16%2FAndroid-O-%E6%96%B0%E7%89%B9%E6%80%A7-AutoSizing%2F</url>
    <content type="text"><![CDATA[自动调整TextView的大小的使用autoSizing Android 8.0允许根据TextView的大小自动设置文本展开或收缩的大小,这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。 在之前看 文字太多？控件太小？试试 TextView 的新特性 Autosizing 吧！ 作者写到关于这个属性的所有用法，在这里我就不多说什么了，用法其实挺简单，关键是我在用的时候遇到了一些小问题，导致一直出不来。 官方文档 点击即可查看，可以看别人讲解的同时也可自行查阅文档，双方对比着看，感觉会好一点。 如下图可以简单明了的说明该特性： 具体最简单的使用有两种： 1.一种就是api &gt;= api 26的可以直接在xml里面该属性：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; /&gt; 在此需要注意的是：使用这个autoSizeTextType的时候，控件的layout_width layout_height 不能使用这个wrap_content否则看不出什么效果，要使用具体可衡量的。这个也不难理解，因为它要计算，你设置一个模糊的宽和高，就算不出来了。 2. api&lt;26 的低设备 的兼容写法 官方文档里也明确说明了兼容低版本The library provides support to Android 4.0 (API level 14) and higher. 也就是兼容到4.0以上，写法有些不同，如下：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; tools:ignore=&quot;MissingPrefix&quot; app:autoSizeTextType=&quot;uniform&quot; /&gt;&lt;/LinearLayout&gt; 这个app是这个xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 我们在自定义控件的时候经常遇到它，tools是这个xmlns:tools=&quot;http://schemas.android.com/tools&quot; 当然以上写法都支持动态编码，具体可查阅文档 敲黑板重点你会发现你写完之后编译是报错的，错误类似是这样的： 找不到！！！ 在写那篇文章作者的帮助下，发现首先要兼容低版本，module 的 build.gradle 文件添加依赖时候 就是这个com.android.support:appcompat-v7:xx 后面的版本号要26以上，你看看你自己项目里有哪个版本你就写上哪个，还要在project 的 build.gradle 文件里添加：maven{ url &#39;https://maven.google.com&#39; }添加到对应的位置123456789allprojects &#123; repositories &#123; jcenter() //添加如下内容 maven&#123; url &apos;https://maven.google.com&apos; &#125; &#125;&#125; 至此我发现我的项目终于不报错了，可以运行起来并进行下一步的实践操作了，大家如果在项目中也遇到这样的问题，按我那样改应该没啥问题了，顺便把我写的代码上传到github 上了，又需要的可以下载看看：demo 另外在查看 Android O新特性中发现一个比较好玩的东西：现在，findViewById() 函数的全部实例均返回 T，而不是 View。以后就可以这么写啦：1EditText et = findViewById(R.id.et); 就是那样，无需强转了，当然了使用了Kotlin的话就忽略吧，因为Kotlin连findViewById也不用写，哈哈。更多好玩特性可查看 文档。]]></content>
      <tags>
        <tag>Android O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改自动生成get/set方法模板代码]]></title>
    <url>%2F2018%2F01%2F11%2F%E4%BF%AE%E6%94%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get-set%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天看到面对接口脏数据你还在V层if str==null else setText? 一文，觉着写得挺好，开发过程中多思考多动手，会带来意想不到的效果。底下评论大家也都说了各自的方法和见解，文中有一些问题作者后来也解决了，看到评论里有人说： 说到配置as,就可以实现在创建bean时自动生成return xx==null?&quot;&quot;:xx; 觉着很好，因为我觉着这是一种挺简单的方法，但是就如同底下人问了怎么配置呀，我也不知道，于是我就在自己as工具里新建了一个bean对象，按住alt+insert添加get/set方法，发现了解决办法。如下图： 平时手快也没注意，今天仔细看了看，那上面的意思不就是，get 方法模块，set方法模板吗，后面跟着 IntelliJ Default大概就是默认的生成模板吧，点击后面的三个点按钮进去看看，如下： 这是set的，get方法也类似是这样的，大概也能看懂，想着是不是可以直接模板就好了，发现无法修改，后来又发现左上角的+号，原来是自己可以新建一个模板，然后再生成的时候选择自己的模板就好了，如我们在get模板中新建一个自己的模板： 我们知道我们只需要改一下最后get方法return那个地方的代码，也就是这儿： 不确定是不是，我们可以在后面跟着一个“#”号试试：123$&#123;name&#125;() &#123; return $field.name+&quot;#&quot;;&#125; 在生成的时候选择我们自定义的模板： 发现最后生成的代码：1234567public String getAge() &#123; return age + &quot;#&quot;;&#125;public void setAge(String age) &#123; this.age = age;&#125; 这样证明确定是这样的，那么我么可以继续进行真正的判断了：我们先把这个默认里的get方法代码拷贝到 MyGetter中，我们再根据我们自己的需要修改模板代码,其它地方不变，就修改需要修改的地方：我们想要实现这样的：return xx==null?&quot;&quot;:xx,Ok ，那么我认为大概是这么写的，首先判断是否是字符串：12345678$&#123;name&#125;() &#123; #if(field.String)&#123; return $field.name == null ? &quot;&quot; : $field.name; &#125; #else return $field.name; #end &#125; 我们对比一个default的写法：123$&#123;name&#125;() &#123; return $field.name;&#125; 好的，我们再继续生成一下：1234567public String getAge() &#123; return age == null ? &quot;&quot; : age; &#125; public void setAge(String age) &#123; this.age = age; &#125; 好的，达成效果，耶，居然还可以这么玩，以后可根据自己需求自行修改，谢谢大家。]]></content>
      <tags>
        <tag>get/set.template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2018%2F01%2F09%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[● standard 标准模式​ 简述：对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。例如：A启动A，A再接着启动A,A再接着启动A,，然后再分别出栈，如图所示：​ ● singleTop简述：当活动的启动模式指定为 singleTop ,在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。例如：如果快速点击一个按钮，进入Activity，要保证启动的Activity不为多个，可以使用将Activity的启动模式改为 singleTop，就不会启动多个了。如图所示：​ ● singleTask简述：当活动的启动模式指定为singleTask，每次启动该活动时候，它会先在系统中查找属性值taskaffinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，他就会这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了“singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。 如果设置了“singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 当栈底部的 A 重新被启动打开时，会执行onNewIntent() onStart() 方法。 使用场景：应用主页面一般是 singleTask ● singleInstance（单独任务栈）简述：使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都会共用同一个返回栈，也就解决了共享活动实例的问题。​ 返回的页面顺序是：C-B-A]]></content>
      <tags>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL实例]]></title>
    <url>%2F2018%2F01%2F08%2FAIDL%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[说到进程间通信，一般首先就会想到AIDL，也看了很多文章，做下笔记，记录一下，方便以后查阅。 对于 AIDL 我是这样理解的，首先进程间是无法通信的，那要通信就得有一个媒介或者说两个进程有统一对外的接口可以相互识别，从这个 AIDL全程的名字Android Interface Definition Language (android 接口定义语言) 来看不难看出它就是我们进程间通信的媒介，它可以实现我们想要的通信。 在翻阅网上各类文章的讲解后，我认为一个比较好的实例可以更好理解这个东西，具体如下： 第一步我们新创建两个module，代表我们两个进程，进程名称默认就是我们程序的包名： 第二步我们先编写service这个module里的代码，先定义一个 Person的一个bean对象，记住一定要implements Parcelable 接口，大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Person implements Parcelable &#123; private String mName; public Person(String name) &#123; mName = name; &#125; protected Person(Parcel in) &#123; mName = in.readString(); &#125; public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel in) &#123; return new Person(in); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(mName); &#125; @Override public String toString() &#123; return "\nPerson&#123;" + "mName='" + mName + '\'' + '&#125;'; &#125;&#125; 然后我们再新建一个文件夹：aidl,新建一个包名和Person类一模一样的包名和与之对应的aidl,还有一个我们对外提供获取person集合的一个aidl: 在Person.aidl里，我们序列化我们java里的 Person 类： 12345package com.example.service.bean;//还要和声明的实体类在一个包里，同时注意不要新建aidl文件，因为你会发现，新建不了，//提示你名称唯一，此时你新建一个file,名字为Person.aidl就可以，需要特别注意下parcelable Person; IMyAidl.aidl 文件提供对外方法：12345678910111213141516// IMyAidl.aidlpackage com.example.service.bean;//特别注意一定要手动导包，不会自动导包import com.example.service.bean.Person;// Declare any non-default types here with import statements//可以理解为通信媒介interface IMyAidl &#123; /** * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出) */ void addPerson(in Person person); List&lt;Person&gt; getPersonList();&#125; 然后在我们的java文件里，新建一个MyAidlService,123456789101112131415161718192021222324252627282930313233343536373839public class MyAidlService extends Service &#123; private final String TAG = this.getClass().getSimpleName(); private ArrayList&lt;Person&gt; mPersons; /** * 创建生成本地的binder ,实现AIDL的方法 */ private IBinder mIBinder = new IMyAidl.Stub()&#123; @Override public void addPerson(Person person) throws RemoteException &#123; mPersons.add(person); &#125; @Override public List&lt;Person&gt; getPersonList() throws RemoteException &#123; return mPersons; &#125; &#125;; /** * 客户端与服务端绑定时的回调，返回IBinder对象后客户端就可以通过它远程调用服务端的方法，即实现了通讯 * @param intent * @return */ @Nullable @Override public IBinder onBind(Intent intent) &#123; mPersons = new ArrayList&lt;&gt;(); return mIBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; 最后别忘了在清单文件中注册MyAidlService1234&lt;service android:name="com.example.service.MyAidlService" android:enabled="true" android:exported="true" /&gt; 到此，我们完成了service端的工作： 第三步将我们刚才创建好的aidl文件夹拷贝到 app module下main文件夹下，在MainActivity中绑定服务，123Intent intent = new Intent(); intent.setComponent(new ComponentName("com.example.service","com.example.service.MyAidlService")); bindService(intent,mConnection,BIND_AUTO_CREATE); 其中这个mConnection可以让我们拿到IMyAidl对象的代理123456789101112private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mAidl = IMyAidl.Stub.asInterface(iBinder); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mAidl = null; &#125; &#125;; 通过返回的IBinder 拿到这个IMyAidl，此时我们就可以通信了，例如我们调用IMyAidl中的addPerson方法，再调用getPersonList看看：1234567891011Random random = new Random(); Person person = new Person("qian"+random.nextInt(20)); try&#123; mAidl.addPerson(person); List&lt;Person&gt; mPersons = mAidl.getPersonList(); tvName.setText(mPersons.toString()); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; 打印发现list 返回了我们添加的Person，完成了app与service两个进程间的通信。demo地址：https://github.com/QQabby/AIDLDemo]]></content>
      <tags>
        <tag>AIDL实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文件相关]]></title>
    <url>%2F2017%2F12%2F28%2F%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[向sd卡根目录中写入文件123456789101112//首先判断是否存在sd卡if(Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED))&#123; //获取外部设备 File file=new File(Environment.getExternalStorageDirectory(),"qianqian.txt"); FileOutputStream outStream=new FileOutputStream(file); //写入文件 outStream.write(content.getBytes()); outStream.close(); &#125; 读取assets下的文件路径123//格式如下file:///android_asset/myVideo.htmlfile:///android_asset/xx(文件名称) 读取assets下的文件转化为String123456789101112131415public String getFromAssets(String fileName) &#123; try &#123; InputStreamReader inputReader = new InputStreamReader( getResources().getAssets().open(fileName)); BufferedReader bufReader = new BufferedReader(inputReader); String line = ""; String Result = ""; while ((line = bufReader.readLine()) != null) Result += line; return Result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125;]]></content>
      <tags>
        <tag>向sd卡写入文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU算法还一知半解？]]></title>
    <url>%2F2017%2F12%2F19%2Flru%2F</url>
    <content type="text"><![CDATA[某年某月某日，糖葫芦同学在掘金app上看了几篇文章，偶然看到了一篇熟悉的词LRU算法，脑海里就想这不是经常说的嘛，就那么回事，当天晚上睡觉，LRU算法是啥来着，好像是什么最近最少使用的，白天在地铁上看的文章也不少，但是到晚上想想好像啥也没记住，就记得LRU算法，我发现人大多数是这样的啊，对于自己熟悉的部分呢还能记着点，不熟悉或者不会的可能真的是看过就忘啊~既然这样还不如先把熟悉的弄明白。 第二天来到公司，我觉着还是有必要看一下这个LRU的源码，到底是怎么回事，嗯，糖葫芦同学刷刷得看，下面我们将进入正题，请戴眼镜的同学把眼镜擦一擦，哈哈哈 First先看源码，再用具体的demo加以验证，我们先看一下这个LruCache这个类的大致结构和方法，如下图所示： 这又是 get(K)，put(K,V), remove(K) 的方法的 给人的感觉就像是一个Map的集合嘛，又有Key ，又有value 的，再看下具体的代码： 12345678910111213141516171819202122232425public class LruCache&lt;K, V&gt; &#123; private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 看到开头，我们就明白了，哦原来这个LruCache类中维护一个LinkedHashMap的一个集合，缓存我们这个对象，而且构造方法里需要我们传入一个maxSize的一个值，根据上面的注释我们就明白了这个就是我们LruCache缓存对象的最大数目。 有什么用呢？根据惯性思维，我们可以认为，在put新的缓存对象的时候，根据我们设定的最大值remove集合里的某些缓存对象，进而添加新的缓存对象。 Second根据我们的分析，我们有必要去看一下这个put方法的源码：12345678910111213141516171819202122232425262728/** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous;&#125; 代码量也不是特别多，我们看下这个，在这个synchronized同步代码块里，我们看到这个 size,是对put进来缓存对象个数的累加，然后调用集合的map.put方法，返回一个对象 previous ，就是判断这个集合中是否添加了这个缓存对象，如果不为null,就对size减回去。 最后又调用一个 trimToSize(maxSize)方法，上面都是对添加一些逻辑的处理，那么不可能无限制添加啊，肯定有移除操作，那么我们推测这个逻辑可能在这个trimToSize(maxSize) 里处理。 源码如下：123456789101112131415161718192021222324252627282930313233/** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //只要当前size&lt;= maxSize 就结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; // 获取这个对象，然后从map中移除掉，保证size&lt;=maxSize Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 注释：Remove the eldest entries until the total of remaining entries is at or below the requested size 大概意思是说：清除时间最久的对象直到剩余缓存对象的大小小于设置的大小。没错是我们想找的。 这里说明一下：maxSize就是我们在构造方法里传入的，自己设置的1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这样LruCache的核心方法 trimToSize方法我们就说完了，接下来我将通过实例再次验证下： 设置场景 假设我们设置maxSize 为2，布局里显示3个imageView,分别代表3张我们要显示的图片，我们添加3张图片，看看会不会显示3张？ xml布局显示如下（代码就不贴了，很简单）： activity代码如下：12345678910111213141516171819202122232425262728public final int MAX_SIZE = 2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_lru); ImageView iv1 = (ImageView) findViewById(R.id.iv1); ImageView iv2 = (ImageView) findViewById(R.id.iv2); ImageView iv3 = (ImageView) findViewById(R.id.iv3); Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),R.drawable.bg); Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(),R.drawable.header_img); Bitmap bitmap3 = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); LruCache&lt;String,Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE); lruCache.put("1",bitmap1); lruCache.put("2",bitmap2); lruCache.put("3",bitmap3); Bitmap bitmap = lruCache.get("1"); iv1.setImageBitmap(bitmap); Bitmap b2 = lruCache.get("2"); iv2.setImageBitmap(b2); Bitmap b3 = lruCache.get("3"); iv3.setImageBitmap(b3); &#125; 图： 我们可以先尝试分析一下：因为我们设置的MaxSize 是2 ，那么在put第三个Bitmap的时候，在trimToSize方法中，发现这个size是3 ，maxSize 是2，会继续向下执行,不会break,结合下面代码看下12345678910111213141516171819202122232425262728public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //第一次循环：此时 size 是3，maxSize 是 2 //第二次循环，此时 size 是 2 ，maxSize 是 2 ，满足条件，break,结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; //获取最先添加的第一个元素 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); //移除掉第一个缓存对象 map.remove(key); // size = 2,减去移除的元素 size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 这个 safeSizeOf 是调用sizeOf方法。 那么也就是说，我们在put第三个bitmap的时候，LruCache 会自动帮我们移除掉第一个缓存对象，因为第一个最先添加进去，时间也最长，当然后添加的bitmap就是新的，最近的，那么我们推断这个iv1是显示不出图片的，因为被移除掉了，其它剩余两个可以显示，分析就到这里，看下运行结果是不是跟我们分析的一样： 哇！真的跟我们想的一样耶，证明我们想的是对的。这里我们思考一下就是为什么LruCache使用了这个LinkedHashMap,为什么LinkedHashMap的创造方法跟我们平时创建的不太一样，源码是这样的：1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这里说一下在掘金发布的评论里 藏地情人评论是：new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true)这句代码表示，初始容量为零，0.75是加载因子，表示容量达到最大容量的75%的时候会把内存增加一半。最后这个参数至关重要。表示访问元素的排序方式，true表示按照访问顺序排序，false表示按照插入的顺序排序。这个设置为true的时候，如果对一个元素进行了操作(put、get)，就会把那个元素放到集合的最后。 确实也是这样的，我们看下LinkedHashMap的源码：1234567891011121314151617/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; 里面这个assessOrder 注释里也说的很明白：the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order -&gt; true 呢就表示会排序，false 就代表按照插入的顺序。默认不传就是 false ,而且我们每次 get(K) put(K,V) 的时候 会根据这个变量调整元素在集合里的位置。而这么做的目的也只有一个：保留最近使用的缓存对象，举个例子说明一下： 我们向这个集合里添加了三种元素 LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE);(MAX_SIZE=2) lruCache.put(&quot;1&quot;, bitmap1); lruCache.put(&quot;2&quot;, bitmap2); lruCache.put(&quot;3&quot;, bitmap3); 此时它们在集合里的顺序是这样的： 那比如说我们在put 3 元素之前，使用了1元素，就是调用了get(&quot;1&quot;)方法，我们知道LinkedHashMap就会改变链表里元素的存储顺序，代码是这样的：1234lruCache.put("1", bitmap1);lruCache.put("2", bitmap2);lruCache.get("1");lruCache.put("3", bitmap3); 那么此时对应链表里的顺序就是： 当我们再调用显示的时候，循环遍历就会优先把第一个位置的key = &quot;2&quot; 的缓存对象移除掉，保证了最近使用的原则，当然了因为把这个max_size = 2所以在我们执行lruCache.put(&quot;3&quot;, bitmap3); 时，集合最终会变成这样： 集合里只剩下 1 ,3对应的缓存对象。 至此，LruCache就说完了，如果看完的你有不明白的地方可以留言，一起讨论下~]]></content>
      <tags>
        <tag>Lru</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
