<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2018%2F01%2F09%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[● standard 标准模式 简述：对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。例如：A启动A，A再接着启动A,A再接着启动A,，然后再分别出栈，如图所示： ● singleTop简述：当活动的启动模式指定为 singleTop ,在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。例如：如果快速点击一个按钮，进入Activity，要保证启动的Activity不为多个，可以使用将Activity的启动模式改为 singleTop，就不会启动多个了。如图所示： ● singleTask简述：当活动的启动模式指定为singleTask，每次启动该活动时候，它会先在系统中查找属性值taskaffinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，他就会这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了“singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。 如果设置了“singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 ● singleInstance（单独任务栈）简述：使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都会共用同一个返回栈，也就解决了共享活动实例的问题。 返回的页面顺序是：C-B-A]]></content>
      <tags>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL实例]]></title>
    <url>%2F2018%2F01%2F08%2FAIDL%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[说到进程间通信，一般首先就会想到AIDL，也看了很多文章，做下笔记，记录一下，方便以后查阅。 对于 AIDL 我是这样理解的，首先进程间是无法通信的，那要通信就得有一个媒介或者说两个进程有统一对外的接口可以相互识别，从这个 AIDL全程的名字Android Interface Definition Language (android 接口定义语言) 来看不难看出它就是我们进程间通信的媒介，它可以实现我们想要的通信。 在翻阅网上各类文章的讲解后，我认为一个比较好的实例可以更好理解这个东西，具体如下： 第一步我们新创建两个module，代表我们两个进程，进程名称默认就是我们程序的包名： 第二步我们先编写service这个module里的代码，先定义一个 Person的一个bean对象，记住一定要implements Parcelable 接口，大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Person implements Parcelable &#123; private String mName; public Person(String name) &#123; mName = name; &#125; protected Person(Parcel in) &#123; mName = in.readString(); &#125; public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel in) &#123; return new Person(in); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(mName); &#125; @Override public String toString() &#123; return "\nPerson&#123;" + "mName='" + mName + '\'' + '&#125;'; &#125;&#125; 然后我们再新建一个文件夹：aidl,新建一个包名和Person类一模一样的包名和与之对应的aidl,还有一个我们对外提供获取person集合的一个aidl: 在Person.aidl里，我们序列化我们java里的 Person 类： 12345package com.example.service.bean;//还要和声明的实体类在一个包里，同时注意不要新建aidl文件，因为你会发现，新建不了，//提示你名称唯一，此时你新建一个file,名字为Person.aidl就可以，需要特别注意下parcelable Person; IMyAidl.aidl 文件提供对外方法：12345678910111213141516// IMyAidl.aidlpackage com.example.service.bean;//特别注意一定要手动导包，不会自动导包import com.example.service.bean.Person;// Declare any non-default types here with import statements//可以理解为通信媒介interface IMyAidl &#123; /** * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出) */ void addPerson(in Person person); List&lt;Person&gt; getPersonList();&#125; 然后在我们的java文件里，新建一个MyAidlService,123456789101112131415161718192021222324252627282930313233343536373839public class MyAidlService extends Service &#123; private final String TAG = this.getClass().getSimpleName(); private ArrayList&lt;Person&gt; mPersons; /** * 创建生成本地的binder ,实现AIDL的方法 */ private IBinder mIBinder = new IMyAidl.Stub()&#123; @Override public void addPerson(Person person) throws RemoteException &#123; mPersons.add(person); &#125; @Override public List&lt;Person&gt; getPersonList() throws RemoteException &#123; return mPersons; &#125; &#125;; /** * 客户端与服务端绑定时的回调，返回IBinder对象后客户端就可以通过它远程调用服务端的方法，即实现了通讯 * @param intent * @return */ @Nullable @Override public IBinder onBind(Intent intent) &#123; mPersons = new ArrayList&lt;&gt;(); return mIBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; 最后别忘了在清单文件中注册MyAidlService1234&lt;service android:name="com.example.service.MyAidlService" android:enabled="true" android:exported="true" /&gt; 到此，我们完成了service端的工作： 第三步将我们刚才创建好的aidl文件夹拷贝到 app module下main文件夹下，在MainActivity中绑定服务，123Intent intent = new Intent(); intent.setComponent(new ComponentName("com.example.service","com.example.service.MyAidlService")); bindService(intent,mConnection,BIND_AUTO_CREATE); 其中这个mConnection可以让我们拿到IMyAidl对象的代理123456789101112private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mAidl = IMyAidl.Stub.asInterface(iBinder); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mAidl = null; &#125; &#125;; 通过返回的IBinder 拿到这个IMyAidl，此时我们就可以通信了，例如我们调用IMyAidl中的addPerson方法，再调用getPersonList看看：1234567891011Random random = new Random(); Person person = new Person("qian"+random.nextInt(20)); try&#123; mAidl.addPerson(person); List&lt;Person&gt; mPersons = mAidl.getPersonList(); tvName.setText(mPersons.toString()); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; 打印发现list 返回了我们添加的Person，完成了app与service两个进程间的通信。demo地址：https://github.com/QQabby/AIDLDemo]]></content>
      <tags>
        <tag>AIDL实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文件相关]]></title>
    <url>%2F2017%2F12%2F28%2F%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[向sd卡根目录中写入文件123456789101112//首先判断是否存在sd卡if(Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED))&#123; //获取外部设备 File file=new File(Environment.getExternalStorageDirectory(),"qianqian.txt"); FileOutputStream outStream=new FileOutputStream(file); //写入文件 outStream.write(content.getBytes()); outStream.close(); &#125; 读取assets下的文件路径123//格式如下file:///android_asset/myVideo.htmlfile:///android_asset/xx(文件名称) 读取assets下的文件转化为String123456789101112131415public String getFromAssets(String fileName) &#123; try &#123; InputStreamReader inputReader = new InputStreamReader( getResources().getAssets().open(fileName)); BufferedReader bufReader = new BufferedReader(inputReader); String line = ""; String Result = ""; while ((line = bufReader.readLine()) != null) Result += line; return Result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125;]]></content>
      <tags>
        <tag>向sd卡写入文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU算法还一知半解？]]></title>
    <url>%2F2017%2F12%2F19%2Flru%2F</url>
    <content type="text"><![CDATA[某年某月某日，糖葫芦同学在掘金app上看了几篇文章，偶然看到了一篇熟悉的词LRU算法，脑海里就想这不是经常说的嘛，就那么回事，当天晚上睡觉，LRU算法是啥来着，好像是什么最近最少使用的，白天在地铁上看的文章也不少，但是到晚上想想好像啥也没记住，就记得LRU算法，我发现人大多数是这样的啊，对于自己熟悉的部分呢还能记着点，不熟悉或者不会的可能真的是看过就忘啊~既然这样还不如先把熟悉的弄明白。 第二天来到公司，我觉着还是有必要看一下这个LRU的源码，到底是怎么回事，嗯，糖葫芦同学刷刷得看，下面我们将进入正题，请戴眼镜的同学把眼镜擦一擦，哈哈哈 First先看源码，再用具体的demo加以验证，我们先看一下这个LruCache这个类的大致结构和方法，如下图所示： 这又是 get(K)，put(K,V), remove(K) 的方法的 给人的感觉就像是一个Map的集合嘛，又有Key ，又有value 的，再看下具体的代码： 12345678910111213141516171819202122232425public class LruCache&lt;K, V&gt; &#123; private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 看到开头，我们就明白了，哦原来这个LruCache类中维护一个LinkedHashMap的一个集合，缓存我们这个对象，而且构造方法里需要我们传入一个maxSize的一个值，根据上面的注释我们就明白了这个就是我们LruCache缓存对象的最大数目。 有什么用呢？根据惯性思维，我们可以认为，在put新的缓存对象的时候，根据我们设定的最大值remove集合里的某些缓存对象，进而添加新的缓存对象。 Second根据我们的分析，我们有必要去看一下这个put方法的源码：12345678910111213141516171819202122232425262728/** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous;&#125; 代码量也不是特别多，我们看下这个，在这个synchronized同步代码块里，我们看到这个 size,是对put进来缓存对象个数的累加，然后调用集合的map.put方法，返回一个对象 previous ，就是判断这个集合中是否添加了这个缓存对象，如果不为null,就对size减回去。 最后又调用一个 trimToSize(maxSize)方法，上面都是对添加一些逻辑的处理，那么不可能无限制添加啊，肯定有移除操作，那么我们推测这个逻辑可能在这个trimToSize(maxSize) 里处理。 源码如下：123456789101112131415161718192021222324252627282930313233/** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //只要当前size&lt;= maxSize 就结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; // 获取这个对象，然后从map中移除掉，保证size&lt;=maxSize Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 注释：Remove the eldest entries until the total of remaining entries is at or below the requested size 大概意思是说：清除时间最久的对象直到剩余缓存对象的大小小于设置的大小。没错是我们想找的。 这里说明一下：maxSize就是我们在构造方法里传入的，自己设置的1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这样LruCache的核心方法 trimToSize方法我们就说完了，接下来我将通过实例再次验证下： 设置场景 假设我们设置maxSize 为2，布局里显示3个imageView,分别代表3张我们要显示的图片，我们添加3张图片，看看会不会显示3张？ xml布局显示如下（代码就不贴了，很简单）： activity代码如下：12345678910111213141516171819202122232425262728public final int MAX_SIZE = 2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_lru); ImageView iv1 = (ImageView) findViewById(R.id.iv1); ImageView iv2 = (ImageView) findViewById(R.id.iv2); ImageView iv3 = (ImageView) findViewById(R.id.iv3); Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),R.drawable.bg); Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(),R.drawable.header_img); Bitmap bitmap3 = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); LruCache&lt;String,Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE); lruCache.put("1",bitmap1); lruCache.put("2",bitmap2); lruCache.put("3",bitmap3); Bitmap bitmap = lruCache.get("1"); iv1.setImageBitmap(bitmap); Bitmap b2 = lruCache.get("2"); iv2.setImageBitmap(b2); Bitmap b3 = lruCache.get("3"); iv3.setImageBitmap(b3); &#125; 图： 我们可以先尝试分析一下：因为我们设置的MaxSize 是2 ，那么在put第三个Bitmap的时候，在trimToSize方法中，发现这个size是3 ，maxSize 是2，会继续向下执行,不会break,结合下面代码看下12345678910111213141516171819202122232425262728public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //第一次循环：此时 size 是3，maxSize 是 2 //第二次循环，此时 size 是 2 ，maxSize 是 2 ，满足条件，break,结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; //获取最先添加的第一个元素 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); //移除掉第一个缓存对象 map.remove(key); // size = 2,减去移除的元素 size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 这个 safeSizeOf 是调用sizeOf方法。 那么也就是说，我们在put第三个bitmap的时候，LruCache 会自动帮我们移除掉第一个缓存对象，因为第一个最先添加进去，时间也最长，当然后添加的bitmap就是新的，最近的，那么我们推断这个iv1是显示不出图片的，因为被移除掉了，其它剩余两个可以显示，分析就到这里，看下运行结果是不是跟我们分析的一样： 哇！真的跟我们想的一样耶，证明我们想的是对的。这里我们思考一下就是为什么LruCache使用了这个LinkedHashMap,为什么LinkedHashMap的创造方法跟我们平时创建的不太一样，源码是这样的：1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这里说一下在掘金发布的评论里 藏地情人评论是：new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true)这句代码表示，初始容量为零，0.75是加载因子，表示容量达到最大容量的75%的时候会把内存增加一半。最后这个参数至关重要。表示访问元素的排序方式，true表示按照访问顺序排序，false表示按照插入的顺序排序。这个设置为true的时候，如果对一个元素进行了操作(put、get)，就会把那个元素放到集合的最后。 确实也是这样的，我们看下LinkedHashMap的源码：1234567891011121314151617/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; 里面这个assessOrder 注释里也说的很明白：the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order -&gt; true 呢就表示会排序，false 就代表按照插入的顺序。默认不传就是 false ,而且我们每次 get(K) put(K,V) 的时候 会根据这个变量调整元素在集合里的位置。而这么做的目的也只有一个：保留最近使用的缓存对象，举个例子说明一下： 我们向这个集合里添加了三种元素 LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE);(MAX_SIZE=2) lruCache.put(&quot;1&quot;, bitmap1); lruCache.put(&quot;2&quot;, bitmap2); lruCache.put(&quot;3&quot;, bitmap3); 此时它们在集合里的顺序是这样的： 那比如说我们在put 3 元素之前，使用了1元素，就是调用了get(&quot;1&quot;)方法，我们知道LinkedHashMap就会改变链表里元素的存储顺序，代码是这样的：1234lruCache.put("1", bitmap1);lruCache.put("2", bitmap2);lruCache.get("1");lruCache.put("3", bitmap3); 那么此时对应链表里的顺序就是： 当我们再调用显示的时候，循环遍历就会优先把第一个位置的key = &quot;2&quot; 的缓存对象移除掉，保证了最近使用的原则，当然了因为把这个max_size = 2所以在我们执行lruCache.put(&quot;3&quot;, bitmap3); 时，集合最终会变成这样： 集合里只剩下 1 ,3对应的缓存对象。 至此，LruCache就说完了，如果看完的你有不明白的地方可以留言，一起讨论下~]]></content>
      <tags>
        <tag>Lru</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
