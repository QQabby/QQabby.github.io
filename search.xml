<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Animation动画相关知识点]]></title>
      <url>/2019/01/15/Animation%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<blockquote>
<p>关于 <code>Animation</code> 的一些回顾和总结</p>
</blockquote>
<h1 id="关于Animation-和-Animator"><a href="#关于Animation-和-Animator" class="headerlink" title="关于Animation 和 Animator"></a>关于Animation 和 Animator</h1><blockquote>
<p><code>Animation</code> 是我们经常用到的一些动画，包括帧动画和补间动画，而 <code>Animator</code> 是<code>Android 3.0</code> 的时候推出的动画框架，也称为属性动画</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>版本兼容</th>
<th>实现效率</th>
<th>适用性</th>
<th>是否产生内存泄漏</th>
<th>使用效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Animation</td>
<td>可兼容Android3.0以下的版本</td>
<td>直接通过代码对矩阵进行处理</td>
<td>仅对View对象有用</td>
<td>不会</td>
<td>假的移动</td>
</tr>
<tr>
<td>Animator</td>
<td>无法兼容，也没有向下兼容的support包</td>
<td>通过设置对象的setter,getter方法，来达到动画目的，使用了java反射机制，可用于任意对象，效率低于Animation</td>
<td>任意对象(但是需要有get/set方法)</td>
<td>可能会，当设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏。</td>
<td>真的位置变换</td>
</tr>
</tbody>
</table>
<h1 id="关于动画的基本使用"><a href="#关于动画的基本使用" class="headerlink" title="关于动画的基本使用"></a>关于动画的基本使用</h1><ul>
<li><p><code>Animation</code> 相关动画的使用</p>
<p><strong>帧动画</strong></p>
<blockquote>
<p>一般我们使用帧动画都是采取xml定义的方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yun_anim.xml</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:oneshot=<span class="string">"false"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">"@mipmap/app_loading0"</span></span><br><span class="line">        android:duration=<span class="string">"150"</span> /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">"@mipmap/app_loading1"</span></span><br><span class="line">        android:duration=<span class="string">"150"</span> /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">"@mipmap/app_loading2"</span></span><br><span class="line">        android:duration=<span class="string">"150"</span> /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">"@mipmap/app_loading3"</span></span><br><span class="line">        android:duration=<span class="string">"150"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/animation-list&gt;  </span><br><span class="line"><span class="comment">//将它定义成一个drawable,这样引用</span></span><br><span class="line">&lt;ImageView</span><br><span class="line">        android:id=<span class="string">"@+id/img_progress"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:src=<span class="string">"@drawable/yun_anim"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>补间动画</strong></p>
<blockquote>
<p>包括一些平移(<code>Translate</code>)，旋转(<code>Rotate</code>)，透明度(<code>Alpha</code>)，缩放动画(<code>Scale</code>)，使用都差不多,可以在xml中创建使用也可以动态创建使用。</p>
</blockquote>
<p><code>xml</code> 中类似于这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个动画集合</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=<span class="string">"200"</span></span><br><span class="line">        android:fromYDelta=<span class="string">"100%p"</span></span><br><span class="line">        android:toYDelta=<span class="string">"0"</span> /&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"><span class="comment">//使用xx布局文件的名称</span></span><br><span class="line">Animation translateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.xx);</span><br><span class="line">iv.startAnimation(translateAnimation);</span><br></pre></td></tr></table></figure>
<p><code>java</code> 代码设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位移动画，相应还有旋转其它类似</span></span><br><span class="line">Animation animation = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">translateAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line">iv.startAnimation(translateAnimation);</span><br></pre></td></tr></table></figure>
<p><strong>属性动画</strong></p>
<blockquote>
<p><code>ValueAnimator</code> 是属性动画的一个核心类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator anim = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);  </span><br><span class="line">anim.setDuration(<span class="number">300</span>);  </span><br><span class="line">anim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">float</span> currentValue = (<span class="keyword">float</span>) animation.getAnimatedValue();  </span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"cuurent value is "</span> + currentValue);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">anim.start()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ObjectAnimator</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透明度的变化，还可以位移啥的</span></span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(iv, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  </span><br><span class="line">animator.setDuration(<span class="number">5000</span>);  </span><br><span class="line">animator.start();  </span><br><span class="line">------------------------------</span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(iv, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">180f</span>);  </span><br><span class="line">animator.setDuration(<span class="number">5000</span>);  </span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>官方一张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-70b61445cb4184f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>ValueAnimator</code> 是属性动画很重要的一个类，其中 <code>ObjectAnimator</code> 继承于 <code>ValueAnimator</code> ..</p>
<h1 id="问题：那-ValueAnimator-到底是怎样实现初始值平滑过渡到结束值的呢？"><a href="#问题：那-ValueAnimator-到底是怎样实现初始值平滑过渡到结束值的呢？" class="headerlink" title="问题：那 ValueAnimator  到底是怎样实现初始值平滑过渡到结束值的呢？"></a>问题：那 <code>ValueAnimator</code>  到底是怎样实现初始值平滑过渡到结束值的呢？</h1><blockquote>
<p>这个是由 <code>TypeEvaluator</code> 和 <code>TimeInterpolator</code> 共同决定的。</p>
</blockquote>
<p><strong>具体来说：<code>TypeEvaluator</code> 决定了从初始值过度到结束值过度的方式。<code>TimeInterpolator</code> 决定了动画从初始值过渡到结束值的节奏。</strong></p>
<p>有个例子很恰当：你每天上班去公司，是选择地铁出行还是公交，还是骑行，选择从出发地到目的地的一种抵达方式，这个是 <code>TypeEvaluator</code>, 假如你选择骑行，是均速骑行到目的地还是先加速后减速，还是一开始慢后来快，这个就是 <code>TimeInterpolator</code> 决定的。</p>
<p><strong>用<code>TypeEvaluator</code> 确定运动轨迹</strong></p>
<p>一般来说，要定义运动轨迹，需要实现 <code>TypeEvaluator</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This function returns the result of linearly interpolating the start and end values, with</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The</span></span><br><span class="line"><span class="comment">     * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (x1 - x0)&lt;/code&gt;,</span></span><br><span class="line"><span class="comment">     * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;,</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *			</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fraction   The fraction from the starting to the ending values 动画当前进行的进度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startValue The start value.开始值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endValue   The end value.结束值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A linear interpolation between the start and end values, given the</span></span><br><span class="line"><span class="comment">     *         &lt;code&gt;fraction&lt;/code&gt; parameter.线性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Point startValue, Point endValue)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//自定义轨迹路线，假如我们做一个线性运动</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Point((<span class="keyword">int</span>)(startValue.getX()+endValue.getX()*fraction),</span><br><span class="line">                (<span class="keyword">int</span>)(startValue.getY()+endValue.getY()*fraction));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Point startP = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">      Point endP = <span class="keyword">new</span> Point(<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">      ValueAnimator valueAnimator = ValueAnimator.ofObject(<span class="keyword">new</span> PointEvaluator(), startP, endP);</span><br><span class="line">      valueAnimator.setDuration(<span class="number">5000</span>);</span><br><span class="line">      valueAnimator.setRepeatCount(<span class="number">10</span>);</span><br><span class="line">      valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">              Point currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">              iv.setX(currentPoint.getX());</span><br><span class="line">              iv.setY(currentPoint.getY());</span><br><span class="line">              current.setX(<span class="number">130</span>+currentPoint.getX());</span><br><span class="line">              current.setY(currentPoint.getY());</span><br><span class="line"></span><br><span class="line">              current.setText(<span class="string">""</span>);</span><br><span class="line">              current.setText(<span class="string">"x="</span>+currentPoint.getX()+<span class="string">"   y="</span>+currentPoint.getY());</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      valueAnimator.start();</span><br></pre></td></tr></table></figure>
<p>这样我们就完成了动画轨迹的定义。</p>
<p>例如我们来一个最简单的线性运动：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-25a93ab5dac3f562.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="one.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-17842c6ce993f25e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="two.jpg"></p>
<h1 id="TimeInterpolator"><a href="#TimeInterpolator" class="headerlink" title="TimeInterpolator"></a>TimeInterpolator</h1><blockquote>
<p>前面说过，这个是用来控制动画从开始到结束的节奏的。Android 自己提供了几个自带的 <code>Interpolator</code>,当然同时也可以自定义实现。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-d068e8aa57ec96d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      
        
        <tags>
            
            <tag> animation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[断点续传了解]]></title>
      <url>/2019/01/14/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%BA%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>所谓断点续传，也就是要从文件已经下载的地方开始继续下载。所以在客户端浏览器传给 <code>wen</code> 服务器的时候要多加一条信息即：从哪里开始的问题。</p>
</blockquote>
<p>假设：我们从服务器下载一个文件，需要从 <code>2000070</code> 这个字节后开始下载，之前已经下载过了，注意查看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get /down.zip http/<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">user-agent: netfox</span><br><span class="line"></span><br><span class="line">range: bytes=<span class="number">2000070</span>-<span class="comment">//新增加字段，range,这一行的意思就是告诉服务器我这个文件从2000070字节开始传输，前面的字节就不用传了。</span></span><br><span class="line"></span><br><span class="line">accept: text/html, image/gif, image/jpeg, *; q=.<span class="number">2</span>, *<span class="comment">/*; q=.2</span></span><br></pre></td></tr></table></figure>
<p>服务器收到这条信息，就开始返回信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">206</span> <span class="comment">//注意此时服务器的返回码不再是200而是206</span></span><br><span class="line"></span><br><span class="line">content-length=<span class="number">106786028</span></span><br><span class="line"></span><br><span class="line">content-range=bytes <span class="number">2000070</span>-<span class="number">106786027</span>/<span class="number">106786028</span> <span class="comment">//这行也是服务器新增加字段，返回的字节是从2000070-106786027 之间的字节，之前的字节就不传了。</span></span><br><span class="line"></span><br><span class="line">date=mon, <span class="number">30</span> apr <span class="number">2001</span> <span class="number">12</span>:<span class="number">55</span>:<span class="number">20</span> gmt</span><br><span class="line"></span><br><span class="line">etag=w/<span class="string">"02ca57e173c11:95b"</span></span><br><span class="line"></span><br><span class="line">content-type=application/octet-stream</span><br><span class="line"></span><br><span class="line">server=microsoft-iis/<span class="number">5.0</span></span><br><span class="line"></span><br><span class="line">last-modified=mon, <span class="number">30</span> apr <span class="number">2001</span> <span class="number">12</span>:<span class="number">55</span>:<span class="number">20</span> gmt</span><br></pre></td></tr></table></figure>
<p>以上差不多就是断点续传需要知道的知识和大致的原理。</p>
<ul>
<li><p>问题</p>
<p> 用什么方法实现提交 <code>range:bytes=2000070-</code>  ？</p>
</li>
</ul>
<blockquote>
<p>使用最原始的 <code>socket</code> 肯定可以完成，不过很费事，用java的net包中提供了设置的方法，如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">			<span class="comment">//通过设置requestProperty</span></span><br><span class="line">               httpURLConnection.setRequestProperty(<span class="string">"rande"</span>,<span class="string">"bytes=2000070"</span>);</span><br><span class="line">			<span class="comment">//这样获取的输入流就是从2000070这个字节后开始的	</span></span><br><span class="line">               InputStream input = httpURLConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>接下来：获取到流了，那么如何从流保存到文件中去呢？</p>
<p>保存文件的方法，采用的是 <code>io</code> 包中的 <code>randomacessfile</code> 类。如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面文件已经获取到 inputStream--input</span></span><br><span class="line">RandomAccessFile saveFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"down.zip"</span>,<span class="string">"rw"</span>);<span class="comment">//down.zip下载文件名称</span></span><br><span class="line">saveFile.seek(<span class="number">2000070</span>);<span class="comment">//定位文件指针到这个 2000070 位置</span></span><br><span class="line"><span class="keyword">byte</span>[] b= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> read;</span><br><span class="line"><span class="keyword">while</span>((read = input.read(b,<span class="number">0</span>,<span class="number">1024</span>))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">saveFile.write(b,<span class="number">0</span>,read);</span><br></pre></td></tr></table></figure>
<p>基本大概就是这样。</p>
]]></content>
      
        
        <tags>
            
            <tag> 断点续传 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Serializable与 Parcelable 的区别]]></title>
      <url>/2019/01/10/Serializable%E4%B8%8EParcable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>序列化的两种方式，一种是 <code>java</code> 提供的 <code>Serilizable</code> 和 <code>Android</code> 自身提供的 <code>Parcelable</code>.</p>
</blockquote>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//默认方式最好设置为1L,因为 java sdk 会自动进行hash计算，并生成唯一的</span></span><br><span class="line">     <span class="comment">//UID值。手动设置serialVersionUID的好处是当前class如果改变了成员变量，</span></span><br><span class="line">     <span class="comment">//比如增加或删除之后，这个UID是不改变的，反序列化不会失效。</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     ....</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//Parcable 类似</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> String lastName;</span><br><span class="line">	...</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;UserInfo&gt; CREATOR = <span class="keyword">new</span> Creator&lt;UserInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserInfo <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserInfo(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> UserInfo[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserInfo[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeString(lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>存储媒介的不同</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>存储媒介</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serializable</td>
<td>使用的IO读写存储在硬盘上，序列化过程使用了反射技术，并且期间产生临时对象（？）,从而引起频繁的GC。</td>
<td>代码少</td>
</tr>
<tr>
<td>Parcelable</td>
<td>使用的IO读写在内存中，内存的读写速度肯定优于硬盘读写速度，所以Parcelable的性能上优于Serializable.</td>
<td>代码写起来比较多</td>
</tr>
</tbody>
</table>
<p>具体到开发中用哪个，个人觉着要考虑要传递对象的大小，如果对象比较大，手机内存比较小，可能会报出 <code>TransactionTooLargeException: The Binder transaction failed because it was too large .</code> 此时就要考虑使用 <code>Parcelable</code> 了，如果对象不是特别大，使用 <code>Serializable</code> 还是挺合适的，毕竟实现比较简单。</p>
]]></content>
      
        
        <tags>
            
            <tag> Serializable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IntentService理解总结]]></title>
      <url>/2019/01/09/IntentService%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>平常用的不是特别多，但是要知道内部原理，看看源码总结一下</p>
</blockquote>
<h1 id="首先为什么会有这个东西？"><a href="#首先为什么会有这个东西？" class="headerlink" title="首先为什么会有这个东西？"></a>首先为什么会有这个东西？</h1><blockquote>
<p>我们知道服务中 service 中的代码是运行在主线程中的，不能做耗时的操作，于是那如果想做耗时操作怎么做呢？就出来 <code>IntentService</code> 这么个东西，用来处理后台服务中的耗时操作并且可以在任务完成之后，自动停止服务。</p>
</blockquote>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异步任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印当前线程的id</span></span><br><span class="line">    Log.d(<span class="string">"MyIntentService"</span>, <span class="string">"Thread id is "</span> + Thread.currentThread(). getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    Log.d(<span class="string">"MyIntentService"</span>, <span class="string">"onDestroy executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启服务</span></span><br><span class="line">Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService.class);</span><br><span class="line">startService(intentService);</span><br></pre></td></tr></table></figure>
<p>通过打印当前线程的 <code>id</code> 我们可以知道当前线程不是在主线程中，执行完成后，会自动执行 <code>onDestroy()</code> 方法。以上属于 <code>IntentService</code> 的基本用法。</p>
<h1 id="有什么好处呢？"><a href="#有什么好处呢？" class="headerlink" title="有什么好处呢？"></a>有什么好处呢？</h1><ul>
<li>省去在 <code>Service</code> 中手动开线程的麻烦</li>
<li>当操作任务完成后自动停止服务</li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntentService is a base class for &#123;<span class="doctag">@link</span> Service&#125;s that handle asynchronous</span></span><br><span class="line"><span class="comment"> * requests (expressed as &#123;<span class="doctag">@link</span> Intent&#125;s) on demand.  Clients send requests</span></span><br><span class="line"><span class="comment"> * through &#123;<span class="doctag">@link</span> android.content.Context#startService(Intent)&#125; calls; the</span></span><br><span class="line"><span class="comment"> * service is started as needed, handles each Intent in turn using a worker</span></span><br><span class="line"><span class="comment"> * thread, and stops itself when it runs out of work.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This "work queue processor" pattern is commonly used to offload tasks</span></span><br><span class="line"><span class="comment"> * from an application's main thread.  The IntentService class exists to</span></span><br><span class="line"><span class="comment"> * simplify this pattern and take care of the mechanics.  To use it, extend</span></span><br><span class="line"><span class="comment"> * IntentService and implement &#123;<span class="doctag">@link</span> #onHandleIntent(Intent)&#125;.  IntentService</span></span><br><span class="line"><span class="comment"> * will receive the Intents, launch a worker thread, and stop the service as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> 使用它，需要继承IntentService,并且实现 onHandleIntent方法，IntentService会收到这些Intent,开启一个工作线程，在合适的时间会自动停止服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All requests are handled on a single worker thread -- they may take as</span></span><br><span class="line"><span class="comment"> * long as necessary (and will not block the application's main loop), but</span></span><br><span class="line"><span class="comment"> * only one request will be processed at a time.</span></span><br><span class="line"><span class="comment"> 所有的请求被处理在一个单一的工作线程中，不会阻塞主线程，但是在同一时间指挥处理一个请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;div class="special reference"&gt;</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Developer Guides&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For a detailed discussion about how to create services, read the</span></span><br><span class="line"><span class="comment"> * &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;guide/components/services.html"&gt;Services&lt;/a&gt; developer</span></span><br><span class="line"><span class="comment"> * guide.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> *官网文档链接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.os.AsyncTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//异步处理任务</span></span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            <span class="comment">//停止自身服务</span></span><br><span class="line">            <span class="comment">//stopSelf()： 会立马结束服务</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//stopSelf(int startId)： 等待所有消息都处理完后才终止服务</span></span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an IntentService.  Invoked by your subclass's constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name Used to name the worker thread, important only for debugging.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets intent redelivery preferences.  Usually called from the constructor</span></span><br><span class="line"><span class="comment">     * with your preferred semantics.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If enabled is true,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Service#START_REDELIVER_INTENT&#125;, so if this process dies before</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onHandleIntent(Intent)&#125; returns, the process will be restarted</span></span><br><span class="line"><span class="comment">     * and the intent redelivered.  If multiple Intents have been sent, only</span></span><br><span class="line"><span class="comment">     * the most recent one is guaranteed to be redelivered.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If enabled is false (the default),</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Service#START_NOT_STICKY&#125;, and if the process dies, the Intent</span></span><br><span class="line"><span class="comment">     * dies along with it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//创建了一个HandlerThread</span></span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">		<span class="comment">//取出HandlerThread线程的 looper ,由于 `HandlerThread` 又是一个异步线程，当我们把 </span></span><br><span class="line">        <span class="comment">//Looper 传递给 ServiceHandler时，使得 ServiceHandler也变成了一个异步执行的线程</span></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * You should not override this method for your IntentService. Instead,</span></span><br><span class="line"><span class="comment">     * override &#123;<span class="doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService</span></span><br><span class="line"><span class="comment">     * receives a start request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> android.app.Service#onStartCommand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unless you provide binding for your service, you don't need to implement this</span></span><br><span class="line"><span class="comment">     * method, because the default implementation returns null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> android.app.Service#onBind</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked on the worker thread with a request to process.</span></span><br><span class="line"><span class="comment">     * Only one Intent is processed at a time, but the processing happens on a</span></span><br><span class="line"><span class="comment">     * worker thread that runs independently from other application logic.</span></span><br><span class="line"><span class="comment">     * So, if this code takes a long time, it will hold up other requests to</span></span><br><span class="line"><span class="comment">     * the same IntentService, but it will not hold up anything else.</span></span><br><span class="line"><span class="comment">     * When all requests have been handled, the IntentService stops itself,</span></span><br><span class="line"><span class="comment">     * so you should not call &#123;<span class="doctag">@link</span> #stopSelf&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent The value passed to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *               android.content.Context#startService(Intent)&#125;.</span></span><br><span class="line"><span class="comment">     *               This may be null if the service is being restarted after</span></span><br><span class="line"><span class="comment">     *               its process has gone away; see</span></span><br><span class="line"><span class="comment">     *               &#123;<span class="doctag">@link</span> android.app.Service#onStartCommand&#125;</span></span><br><span class="line"><span class="comment">     *               for details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>IntentService.java</code> 总结来说就是：一个 <code>HandlerThread + ServiceHandler</code> , 以队列的形式处理异步操作的类。</p>
<p><code>IntentService</code> 是继承与 <code>Service</code> 的，在 <code>onCreate()</code> 时，创建了 <code>HandlerThread</code> 实例（ <code>HandlerThread</code> 又是啥呢，它是 <code>Thread</code> 子类，内部拿到一个当前线程的 <code>Looper</code>, <code>Looper</code> 一直轮询消息，获得消息，处理消息），而 <code>IntentService</code> 内部有一个<code>ServiceHandler</code>,<code>ServiceHandler</code> 的创建的 <code>Looper</code> 是拿的是  <code>HandlerThread</code> 的 <code>Looper</code> , <code>IntentService</code> 在 <code>onStart()</code> 通过发送 <code>Message</code>, 在处理 <code>Message</code> 调用的是 <code>onHandleIntent()</code> 方法。</p>
]]></content>
      
        
        <tags>
            
            <tag> IntentService </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IOC]]></title>
      <url>/2019/01/04/IOC/</url>
      <content type="html"><![CDATA[<blockquote>
<p>以下内容是我最近在学习 <code>Spring Boot</code> <code>Spring MVC</code> 过程中，针对 <code>ioc</code> 控制反转所了解到的内容。</p>
</blockquote>
<h1 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h1><ul>
<li>使用 Spring Boot, Spring 如何实现 IOC</li>
<li>使用 <code>maven</code></li>
</ul>
<blockquote>
<p>java oop : 每次都是自己 new 对象，不够方便，核心原因是产生了代码的偶合。</p>
<p>目标：希望容器给我对象，直接获得对象；</p>
<p>IOC:  控制反转，表示把对象的控制权交给容器</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.setName(<span class="string">"糖葫芦"</span>);</span><br><span class="line">        stu.setAge(<span class="string">"18"</span>);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">在另外一个类 SpringBootIocApplicationTests.java 中：</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    Student student;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这里可以直接拿到</span></span><br><span class="line">        System.out.println(<span class="string">"student:"</span>+student.getName());</span><br><span class="line">        <span class="comment">//student:糖葫芦</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Maven-项目"><a href="#Maven-项目" class="headerlink" title="Maven 项目"></a>Maven 项目</h1><p>如果不用 <code>Spring Boot</code> ,创建 <code>Maven</code> 项目进行实现：</p>
<ul>
<li><p>使用 <code>ide</code> 创建 <code>maven</code> 项目</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-ea6711b4d7e0dd01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<p>注意勾选 <code>create from..</code></p>
<p>要实现控制反转，需要我们导入 <code>Spring Context</code> 配置，在 <code>maven</code> 官网：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-29301f3172d18176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>搜索 <code>Spring</code>, 底下有很多版本，导入你想导入的版本，点击进去，看到：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-7a98eb230a6b228e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>将红色框部分，拷贝到 项目的 <code>pom.xml</code> 文件中，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project </span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.3.20.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>然后我们还需要手动设置配置文件：在 <code>resources</code> 文件夹下，创建一个 <code>xml</code> ,我们可以这么创建 <code>xml</code>,可以帮助我们自带一些配置，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-1876403145bb9ff7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>applicationContext.xml</code> :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"student"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"Student"</span>&gt;&lt;!--将这个bean加入到spring的ioc容器--&gt;</span><br><span class="line">        &lt;property name="name" value="糖葫芦"&gt;&lt;/property&gt;&lt;!--给bean的pname属性赋值--&gt;</span><br><span class="line">        &lt;property name="age" value="18"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>最后，如何获取呢？通过 <code>ApplicationContext</code> 获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">	<span class="comment">//传入xml 中定义的bean 的 id </span></span><br><span class="line">       Student student = (Student) context.getBean(<span class="string">"student"</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"student::"</span>+student.getName()+ <span class="string">"::::age::"</span>+student.getAge());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以拿到我们在 <code>xml</code> 中定义的 <code>bean</code> 的内容了。</p>
]]></content>
      
        
        <tags>
            
            <tag> IOC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[组件化随笔]]></title>
      <url>/2018/12/25/%E7%BB%84%E4%BB%B6%E5%8C%96%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<blockquote>
<p>随着技术越来越发展，代码越来越臃肿，经常会牵一发而动全身，发生bug的概率也比较高，组件化一定程度上成了我们必不可少的一个部分，使用组件化能够：</p>
<ul>
<li>提高代码的复用性</li>
<li>降低组件之间的耦合性，一定程度上减少bug的产生</li>
</ul>
</blockquote>
<p>设计组件化：</p>
<ul>
<li>分层设计，app壳工程，业务组件，功能组件，基础组件。</li>
<li>业务组件为了防止相互引用出现死循环，每一个业务组件设计成两个module,  一个 export module,一个 implement module.  互相依赖 export modult 即可。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-873e195f5a7233c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      
        
        <tags>
            
            <tag> 组件化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Context]]></title>
      <url>/2018/12/25/Context/</url>
      <content type="html"><![CDATA[<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>之间的继承关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/23/167dbb5dce7fdc2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<h1 id="Context-作用"><a href="#Context-作用" class="headerlink" title="Context 作用"></a>Context 作用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以点击studio旁边的 Structure 结构示意图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interface to global information about an application environment.  This is</span></span><br><span class="line"><span class="comment">* an abstract class whose implementation is provided by</span></span><br><span class="line"><span class="comment">* the Android system.  It</span></span><br><span class="line"><span class="comment">* allows access to application-specific resources and classes, as well as</span></span><br><span class="line"><span class="comment">* up-calls for application-level operations such as launching activities,</span></span><br><span class="line"><span class="comment">* broadcasting and receiving intents, etc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 四大组件相关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(@RequiresPermission Intent intent)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(@RequiresPermission Intent intent)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Intent <span class="title">registerReceiver</span><span class="params">(@Nullable BroadcastReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            IntentFilter filter)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">stopService</span><span class="params">(Intent service)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(@RequiresPermission Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull ServiceConnection conn, @BindServiceFlags <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(@NonNull ServiceConnection conn)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取系统/应用资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AssetManager <span class="title">getAssets</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Resources <span class="title">getResources</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Context <span class="title">getApplicationContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> &lt;T&gt; <span class="function">T <span class="title">getSystemService</span><span class="params">(@NonNull Class&lt;T&gt; serviceClass)</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getString</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">(@ColorRes <span class="keyword">int</span> id)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Drawable <span class="title">getDrawable</span><span class="params">(@DrawableRes <span class="keyword">int</span> id)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setTheme</span><span class="params">(@StyleRes <span class="keyword">int</span> resid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TypedArray <span class="title">obtainStyledAttributes</span><span class="params">(@StyleableRes <span class="keyword">int</span>[] attrs)</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取应用相关信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ApplicationInfo <span class="title">getApplicationInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getPackageName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Looper <span class="title">getMainLooper</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(@NonNull String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件相关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> File <span class="title">getSharedPreferencesPath</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> File <span class="title">getDataDir</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">deleteFile</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> File <span class="title">getExternalFilesDir</span><span class="params">(@Nullable String type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> File <span class="title">getCacheDir</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, @PreferencesMode <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">deleteSharedPreferences</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库相关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SQLiteDatabase <span class="title">openOrCreateDatabase</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">deleteDatabase</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> File <span class="title">getDatabasePath</span><span class="params">(String name)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其它</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponentCallbacks</span><span class="params">(ComponentCallbacks callback)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterComponentCallbacks</span><span class="params">(ComponentCallbacks callback)</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComponentCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Context</code> 就相当于 <code>Application</code> 的大管家，主要负责：</p>
<ul>
<li>四大组件，启动  <code>Activity</code> , 广播，服务等</li>
<li>获取系统资源</li>
<li>文件操作相关</li>
<li>数据库操作相关</li>
</ul>
<h1 id="ContextWrapper"><a href="#ContextWrapper" class="headerlink" title="ContextWrapper"></a>ContextWrapper</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxying implementation of Context that simply delegates all of its calls to</span></span><br><span class="line"><span class="comment"> * another Context.  Can be subclassed to modify behavior without changing</span></span><br><span class="line"><span class="comment"> * the original Context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Context mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the base context for this ContextWrapper.  All calls will then be</span></span><br><span class="line"><span class="comment">     * delegated to the base context.  Throws</span></span><br><span class="line"><span class="comment">     * IllegalStateException if a base context has already been set.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base The new base context for this wrapper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base context as set by the constructor or setBaseContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getBaseContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextWrapper</code> 实际上就是 <code>Context</code> 的代理类，所有的操作都是 <code>mBase</code> 完成。另外，Activity, Service 的 getBaseContext 返回的就是这个 mBase.</p>
<h1 id="ContextThemeWrapper"><a href="#ContextThemeWrapper" class="headerlink" title="ContextThemeWrapper"></a>ContextThemeWrapper</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A context wrapper that allows you to modify or replace the theme of the</span></span><br><span class="line"><span class="comment"> * wrapped context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextThemeWrapper</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mThemeResource;</span><br><span class="line">    <span class="keyword">private</span> Resources.Theme mTheme;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line">    <span class="keyword">private</span> Configuration mOverrideConfiguration;</span><br><span class="line">    <span class="keyword">private</span> Resources mResources;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new context wrapper with no theme and no base context.</span></span><br><span class="line"><span class="comment">     * &lt;p class="note"&gt;</span></span><br><span class="line"><span class="comment">     * &lt;strong&gt;Note:&lt;/strong&gt; A base context &lt;strong&gt;must&lt;/strong&gt; be attached</span></span><br><span class="line"><span class="comment">     * using &#123;<span class="doctag">@link</span> #attachBaseContext(Context)&#125; before calling any other</span></span><br><span class="line"><span class="comment">     * method on the newly constructed context wrapper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextThemeWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new context wrapper with the specified theme.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The specified theme will be applied on top of the base context's theme.</span></span><br><span class="line"><span class="comment">     * Any attributes not explicitly defined in the theme identified by</span></span><br><span class="line"><span class="comment">     * &lt;var&gt;themeResId&lt;/var&gt; will retain their original values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base the base context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> themeResId the resource ID of the theme to be applied on top of</span></span><br><span class="line"><span class="comment">     *                   the base context's theme</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextThemeWrapper</span><span class="params">(Context base, @StyleRes <span class="keyword">int</span> themeResId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(base);</span><br><span class="line">        mThemeResource = themeResId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new context wrapper with the specified theme.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Unlike &#123;<span class="doctag">@link</span> #ContextThemeWrapper(Context, int)&#125;, the theme passed to</span></span><br><span class="line"><span class="comment">     * this constructor will completely replace the base context's theme.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base the base context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> theme the theme against which resources should be inflated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextThemeWrapper</span><span class="params">(Context base, Resources.Theme theme)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(base);</span><br><span class="line">        mTheme = theme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Call to set an "override configuration" on this context -- this is</span></span><br><span class="line"><span class="comment">     * a configuration that replies one or more values of the standard</span></span><br><span class="line"><span class="comment">     * configuration that is applied to the context.  See</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Context#createConfigurationContext(Configuration)&#125; for more</span></span><br><span class="line"><span class="comment">     * information.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method can only be called once, and must be called before any</span></span><br><span class="line"><span class="comment">     * calls to &#123;<span class="doctag">@link</span> #getResources()&#125; or &#123;<span class="doctag">@link</span> #getAssets()&#125; are made.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOverrideConfiguration</span><span class="params">(Configuration overrideConfiguration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"getResources() or getAssets() has already been called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOverrideConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Override configuration has already been set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mOverrideConfiguration = <span class="keyword">new</span> Configuration(overrideConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used by ActivityThread to apply the overridden configuration to onConfigurationChange</span></span><br><span class="line"><span class="comment">     * callbacks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getOverrideConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOverrideConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ensure we're returning assets with the correct configuration.</span></span><br><span class="line">        <span class="keyword">return</span> getResourcesInternal().getAssets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getResourcesInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Resources <span class="title">getResourcesInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOverrideConfiguration == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mResources = <span class="keyword">super</span>.getResources();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Context resContext = createConfigurationContext(mOverrideConfiguration);</span><br><span class="line">                mResources = resContext.getResources();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheme</span><span class="params">(<span class="keyword">int</span> resid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeResource != resid) &#123;</span><br><span class="line">            mThemeResource = resid;</span><br><span class="line">            initializeTheme();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThemeResId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mThemeResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTheme != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mTheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mThemeResource = Resources.selectDefaultTheme(mThemeResource,</span><br><span class="line">                getApplicationInfo().targetSdkVersion);</span><br><span class="line">        initializeTheme();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mTheme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInflater;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBaseContext().getSystemService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by &#123;<span class="doctag">@link</span> #setTheme&#125; and &#123;<span class="doctag">@link</span> #getTheme&#125; to apply a theme</span></span><br><span class="line"><span class="comment">     * resource to the current Theme object. May be overridden to change the</span></span><br><span class="line"><span class="comment">     * default (simple) behavior. This method will not be called in multiple</span></span><br><span class="line"><span class="comment">     * threads simultaneously.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> theme the theme being modified</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resId the style resource being applied to &lt;var&gt;theme&lt;/var&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first &#123;<span class="doctag">@code</span> true&#125; if this is the first time a style is being</span></span><br><span class="line"><span class="comment">     *              applied to &lt;var&gt;theme&lt;/var&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onApplyThemeResource</span><span class="params">(Resources.Theme theme, <span class="keyword">int</span> resId, <span class="keyword">boolean</span> first)</span> </span>&#123;</span><br><span class="line">        theme.applyStyle(resId, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> first = mTheme == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            mTheme = getResources().newTheme();</span><br><span class="line">            <span class="keyword">final</span> Resources.Theme theme = getBaseContext().getTheme();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTheme.setTo(theme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合注释及源码，可以发现，相比 ContextWrapper, ContextThemeWrapper 有自己的另外的Resource以及 Theme 成员，并且可以传入配置信息以初始化自己的 Resource 及 Theme.</p>
<p>ContextThemeWrapper 和它的mBase 成员在 Resource 以及 Theme 相关的行为上是不同的。</p>
<h1 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h1><p><code>ContextImpl</code> 和 <code>ContextThemeWrapper</code> 最大的区别就是没有一个 <code>Configuration</code>. 其它的行为大致一样。 另外 <code>ContextImpl</code> 可以用于创建  <code>Activity</code> <code>Service</code> 的 <code>mBase</code> 成员，这个 <code>mBase context</code> 除了参数不同，它们的 <code>Resource</code> 也不同， 需要注意的是， createActivityContext等方法中 setResource 是 mBase 自己调用的， Activity,  service 以及 Application 本身并没有执行 setResource. </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>ContextWrapper, ContextThemeWrapper 都是 Context 的代理类，二者的区别在于 ContextThemeWrapper 有自己的 Theme 以及 Resource,并且 Resource 可以传入自己配置初始化</li>
<li>ContextImpl 是 Context 主要实现类， Activity,  Service 和 Application 的 Base contex都是由他创建的，即 ContextWrapper 代理的就是 ContextImpl 对象本身</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> context </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecyclerView刷新机制]]></title>
      <url>/2018/12/24/RecyclerView%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="掘金博客记录"><a href="#掘金博客记录" class="headerlink" title="掘金博客记录"></a>掘金博客记录</h1><ul>
<li><p><code>adapter.notifyDataSetChanaged()</code> 引起的刷新</p>
<p>我们假设 <code>recycleView</code> 的初始状态是没有数据的，然后往数据源中加入数据后，调用</p>
<p><code>adapter.notifyDataSetChanged()</code> 来引起<code>RecyclerView</code> 的刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.addAll(data)</span><br><span class="line">adapter.notifyDataSetChanged()</span><br></pre></td></tr></table></figure>
<p><code>adapter.notifyDataSetChanged()</code> 时，会引起 <code>recycleView</code> 重新布局（<code>requestLayout</code>）.因此从 <code>onLayout()</code> 方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">        dispatchLayout();</span><br><span class="line">        TraceCompat.endSection();</span><br><span class="line">        mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法直接调用了 <code>dispatchLayout()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"No adapter attached; skipping layout"</span>);</span><br><span class="line">            <span class="comment">// leave the state in START</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"No layout manager attached; skipping layout"</span>);</span><br><span class="line">            <span class="comment">// leave the state in START</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">                || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">            <span class="comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span></span><br><span class="line">            <span class="comment">// changed size.</span></span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>缩写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (数据变化 || 布局变化) &#123;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是裁掉了一些代码，可以看到整个布局过程总共分为3步，下面3步对应的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STEP_START----&gt;dispatchLayoutStep1()</span><br><span class="line">STEP_LAYOUT----&gt;dispatchLayoutStep2()</span><br><span class="line">STEP_ANIMATIONS----&gt;dispatchLayoutStep2(),dispatchLayoutStep3()</span><br></pre></td></tr></table></figure>
<p>第一步：<code>STEP_START</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * The first step of a layout where we;</span><br><span class="line">    * - process adapter updates 更新adapter</span><br><span class="line">    * - decide which animation should run 确定哪个动画应该运行</span><br><span class="line">    * - save information about current views 保存当前views的信息</span><br><span class="line">    * - If necessary, run predictive layout and save its information</span><br><span class="line">    */</span><br><span class="line">   private void dispatchLayoutStep1() &#123;</span><br><span class="line">   	.....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>第二步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">确定view的真正状态</span></span><br><span class="line"><span class="comment">     * The second layout step where we do the actual layout of the views for the final state.</span></span><br><span class="line"><span class="comment">     这步可能会执行多次如果necessary</span></span><br><span class="line"><span class="comment">     * This step might be run multiple times if necessary (e.g. measure).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        onEnterLayoutOrScroll();</span><br><span class="line">        mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">        mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">        <span class="comment">//设置好初始状态</span></span><br><span class="line">        mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: Run layout 调用布局管理器布局</span></span><br><span class="line">        mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">        mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">        mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">        mState.mLayoutStep = State.STEP_ANIMATIONS;<span class="comment">//接下来执行布局的第三步</span></span><br><span class="line">        onExitLayoutOrScroll();</span><br><span class="line">        stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个 <code>mState</code>, 它是 一个 <code>RecyclerView.State</code> 对象。顾名思义它是用来保存 <code>RecyclerView</code> 状态的一个对象，主要是用在 <code>LayoutManager</code> <code>Adapter</code> 组件之间共享 <code>recyclerView</code> 状态的。可以看到这个方法将布局交给了 <code>mLayout</code>. 就是指的是 <code>LineaLayoutManager</code>. 因此接下来看下：<code>LinearLayoutManager.onLayoutChildren()</code>:</p>
</li>
<li><p><code>LinearLayoutManager.onLayoutChildren()</code></p>
<p>这个方法比较长，就不展示具体源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// layout algorithm: 布局算法</span></span><br><span class="line">        	<span class="number">1</span>.检查children 和其它变量，找到锚坐标和锚</span><br><span class="line">        <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></span><br><span class="line">        <span class="comment">//  item position. item位置</span></span><br><span class="line">            <span class="number">2</span>.开始填充，从底部开始</span><br><span class="line">        <span class="comment">// 2) fill towards start, stacking from bottom</span></span><br><span class="line">             <span class="number">3</span>.填充   </span><br><span class="line">        <span class="comment">// 3) fill towards end, stacking from top</span></span><br><span class="line">             <span class="number">4</span>.滚动满足要求像从底部填充一样   </span><br><span class="line">        <span class="comment">// 4) scroll to fulfill requirements like stack from bottom.</span></span><br><span class="line">        <span class="comment">// create layout state</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定锚点<code>View</code></p>
<p>锚点<code>View</code>的确定通过： <code>updateAnchorInfoForLayout</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateAnchorFromChildren</span><span class="params">(RecyclerView.Recycler recycler,</span></span></span><br><span class="line"><span class="function"><span class="params">            RecyclerView.State state, AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">	....</span><br><span class="line">        View referenceChild = anchorInfo.mLayoutFromEnd</span><br><span class="line">        		<span class="comment">//如果是从end(尾部)位置开始布局，那就找最接近end的那个位置的view作为锚点View</span></span><br><span class="line">                ? findReferenceChildClosestToEnd(recycler, state)</span><br><span class="line">        <span class="comment">////如果是从start(尾部)位置开始布局，那就找最接近start的那个位置的view作为锚点View</span></span><br><span class="line">                : findReferenceChildClosestToStart(recycler, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><code>AnchorInfo</code> 最重要的两个属性是; <code>mCoordinate</code> 和 <code>mPosition</code>. 找到锚点 <code>View</code> 后就会通过<code>anchorInfo.assignFromView()</code> 方法来设置这两个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignFromView</span><span class="params">(View child, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutFromEnd) &#123;</span><br><span class="line">                mCoordinate = mOrientationHelper.getDecoratedEnd(child)</span><br><span class="line">                        + mOrientationHelper.getTotalSpaceChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCoordinate = mOrientationHelper.getDecoratedStart(child);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPosition = position;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mCoordinate: 就是锚点View的 Y(x) 坐标去掉 RecycleView 的 padding.</span><br><span class="line">mPosition: 其实就是 锚点View的位置</span><br></pre></td></tr></table></figure>
<p>当确定好 <code>AnchorInfo</code> 后，需要根据 <code>AnchorInfo</code> 来确定 <code>RecycleView</code> 当前可用于布局的空间，然后来摆放子View。以布局方向为 <code>start to end</code> 正常方向为例，这里的锚点View其实就是 <code>RecyclerView</code>最顶部的 View：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// fill towards end  (1)</span><br><span class="line">    updateLayoutStateToFillEnd(mAnchorInfo); //确定AnchorView到RecyclerView的底部的布局可用空间</span><br><span class="line">    ...</span><br><span class="line">    fill(recycler, mLayoutState, state, false); //填充view, 从 AnchorView 到RecyclerView的底部</span><br><span class="line">    endOffset = mLayoutState.mOffset; </span><br><span class="line"></span><br><span class="line">    // fill towards start (2)</span><br><span class="line">    updateLayoutStateToFillStart(mAnchorInfo); //确定AnchorView到RecyclerView的顶部的布局可用空间</span><br><span class="line">    ...</span><br><span class="line">    fill(recycler, mLayoutState, state, false); //填充view,从 AnchorView 到RecyclerView的顶部</span><br></pre></td></tr></table></figure>
<p>上面我标注了（1）（2），1次布局是由这两部分组成的，具体如下图：</p>
<p><img src="C:\Users\xuqianqian\AppData\Roaming\Typora\typora-user-images\1545640614074.png" alt="1545640614074"></p>
<p><strong>fill towards end</strong></p>
<p><strong>确定可用布局空间</strong></p>
<p>在 <code>fill</code> 之前，需要先确定 从锚点<code>View</code> 到 <code>RecyclerView</code> 底部有多少可用空间。是通过 <code>updateLayoutStateToFillEnd</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">updateLayoutStateToFillEnd(anchorInfo.mPosition, anchorInfo.mCoordinate);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLayoutStateToFillEnd</span><span class="params">(<span class="keyword">int</span> itemPosition, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - offset;</span><br><span class="line">    ...</span><br><span class="line">    mLayoutState.mCurrentPosition = itemPosition;</span><br><span class="line">    mLayoutState.mLayoutDirection = LayoutState.LAYOUT_END;</span><br><span class="line">    mLayoutState.mOffset = offset;</span><br><span class="line">    mLayoutState.mScrollingOffset = LayoutState.SCROLLING_OFFSET_NaN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mLayoutState</code> 是 <code>LinearLayoutmanager</code> 用来保存布局状态的一个对象。 <code>mLayoutState.mAvailable</code> 就是用来表示 有多少空间可用布局。<code>mOrientationHelper.getEndAfterPadding() - offset</code> 其实大致可以理解为<code>RecycleView</code> 的高度。所以这里可用布局空间 <code>mLayoutState.mAvailable</code> 就是 <code>ReycleView</code> 的高度。</p>
<p><strong>摆放子View</strong></p>
<p>接下来继续看 <code>LinearLayoutManager.fill()</code> 方法，这个方法是布局的核心方法，是用来向 <code>RecycleView</code> 中添加子View的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="function"><span class="params">            RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// max offset we should set is mFastScroll + available</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;<span class="comment">//可用高度就是RecyclerView的高度</span></span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">            <span class="comment">// TODO ugly bug fix. should not happen</span></span><br><span class="line">            <span class="keyword">if</span> (layoutState.mAvailable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            recycleByLayoutState(recycler, layoutState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    <span class="comment">//保存布局一个child view后的结果</span></span><br><span class="line">        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            <span class="comment">//有剩余空间的话，就一直添加 childView</span></span><br><span class="line">            layoutChunkResult.resetInternal();</span><br><span class="line">            <span class="keyword">if</span> (VERBOSE_TRACING) &#123;</span><br><span class="line">                TraceCompat.beginSection(<span class="string">"LLM LayoutChunk"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//布局子View的核心方法</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">            <span class="keyword">if</span> (VERBOSE_TRACING) &#123;</span><br><span class="line">                TraceCompat.endSection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (layoutChunkResult.mFinished) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一次layoutchunk 消耗了多少空间</span></span><br><span class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Consume the available space if:</span></span><br><span class="line"><span class="comment">             * * layoutChunk did not request to be ignored</span></span><br><span class="line"><span class="comment">             * * OR we are laying out scrap children</span></span><br><span class="line"><span class="comment">             * * OR we are not doing pre-layout</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            回收可用空间....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的核心就是调用 <code>layoutChunk()</code> 来不断消耗<code>layoutState.mAvailable</code> 直到消耗完毕，继续看下 <code>layoutChunk()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">        View view = layoutState.next(recycler);  <span class="comment">//这个方法会向 recycler view 要一个holder </span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; <span class="comment">//根据布局方向，添加到不同的位置</span></span><br><span class="line">            addView(view);   <span class="comment">//添加到 RecyclerView 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//调用view的measure</span></span><br><span class="line">        </span><br><span class="line">        ...measure后确定布局参数 left/top/right/bottom</span><br><span class="line"></span><br><span class="line">        layoutDecoratedWithMargins(view, left, top, right, bottom); <span class="comment">//调用view的layout</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到这里其实就完成了上面的 <code>fill towards end</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateLayoutStateToFillEnd(mAnchorInfo)<span class="comment">// 确定布局可用空间</span></span><br><span class="line"></span><br><span class="line">fill(recycler,mLayoutState,state,<span class="keyword">false</span>)<span class="comment">// 填充View</span></span><br></pre></td></tr></table></figure>
<p><code>fill towards start</code> 就是从 锚点<code>View</code> 向 <code>RecycleView</code> 顶部来摆放子<code>View</code>，具体逻辑类似 <code>fill towards end.</code></p>
<p><strong>RecyclerView 滑动时的刷新逻辑</strong></p>
<blockquote>
<p>在不加载新的数据情况下， RecycleView 在滑动时是如何展示 子View的，即下面这种状态：</p>
</blockquote>
<p><img src="C:\Users\xuqianqian\AppData\Roaming\Typora\typora-user-images\1545643914261.png" alt="1545643914261"></p>
<p>下面就来分析一个 3，4 和 12，13是如何展示的。</p>
<p>RecycleView 在 OnTouchEvent 对滑动事件做了监听，然后派发到 scrollStep() 方法：</p>
]]></content>
      
        
        <tags>
            
            <tag> RecyclerView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HandlerThread源码]]></title>
      <url>/2018/12/20/HandlerThread%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handy class for starting a new thread that has a looper. The looper can then be </span></span><br><span class="line"><span class="comment"> * used to create handler classes. Note that start() must still be called.</span></span><br><span class="line"><span class="comment"> */</span>开启一个线程内部有一个looper, 这个looper可以用来创建handler. 切记一定要调用start方法.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们初始化和启动了一个线程，既然是线程那就看 <code>run</code> 方法， <code>run</code> 方法中创建了 <code>Looper</code> 对象，然后设置线程等级，开启循环 <code>loop()</code> .</p>
]]></content>
      
        
        <tags>
            
            <tag> handlerThread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进程保活大法]]></title>
      <url>/2018/12/19/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E5%A4%A7%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>收集整理android 进程保活方法</p>
</blockquote>
<h1 id="1像素Activity"><a href="#1像素Activity" class="headerlink" title="1像素Activity"></a>1像素Activity</h1><blockquote>
<p>注册监听屏幕开启和屏幕关闭时的广播，当屏幕关闭时，开启1像素的 <code>Activity</code>,  当屏幕开启时，关闭1像素的 <code>Activity</code>. </p>
</blockquote>
<ul>
<li><p>查看进程等级</p>
<p>可以在<code>studio</code> 终端进行命令行, <code>pid</code> 进程<code>id</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat proc/&#123;pid&#125;/oom_adj</span><br></pre></td></tr></table></figure>
<p><code>OnePxActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnePxActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context,OnePxActivity.class);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        Log.i(<span class="string">"qq"</span>,<span class="string">"OnPxActivity onCreate........."</span>);</span><br><span class="line">        Window window = getWindow();</span><br><span class="line">        window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class="line"></span><br><span class="line">        WindowManager.LayoutParams params = window.getAttributes();</span><br><span class="line">        params.x = <span class="number">0</span>;</span><br><span class="line">        params.y = <span class="number">0</span>;</span><br><span class="line">        params.width = <span class="number">1</span>;</span><br><span class="line">        params.height = <span class="number">1</span>;</span><br><span class="line">        window.setAttributes(params);</span><br><span class="line"></span><br><span class="line">        KeepAliveManager.getInstance().setKeepAliveManager(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.i(<span class="string">"qq"</span>,<span class="string">"OnPxActivity onDestroy........."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广播 ： 监听开启/关闭的广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(intent.getAction().equals(Intent.ACTION_SCREEN_ON))&#123;</span><br><span class="line">            <span class="comment">//屏幕点亮</span></span><br><span class="line">            Log.i(<span class="string">"qq"</span>,<span class="string">"收到屏幕开启广播"</span>);</span><br><span class="line">            KeepAliveManager.getInstance().finishOnePxActivity(context);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(intent.getAction().equals(Intent.ACTION_SCREEN_OFF))&#123;</span><br><span class="line">            <span class="comment">//屏幕熄灭, 启动activity</span></span><br><span class="line">            Log.i(<span class="string">"qq"</span>,<span class="string">"收到屏幕关闭广播"</span>);</span><br><span class="line">            KeepAliveManager.getInstance().startOnePxActivity(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助类：<code>KeepAliveManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepAliveManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">KeepAliveManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KeepAliveManager mInstance = <span class="keyword">new</span> KeepAliveManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  WeakReference&lt;OnePxActivity&gt; mReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveManager</span><span class="params">(OnePxActivity activity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeepAliveManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startOnePxActivity</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        OnePxActivity.launch(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishOnePxActivity</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != mReference &amp;&amp; mReference.get() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mReference.get().finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> KeepAliveReceiver mReceiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerReceiver</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mReceiver = <span class="keyword">new</span> KeepAliveReceiver();</span><br><span class="line">        IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_ON);</span><br><span class="line">        context.registerReceiver(mReceiver,filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != mReceiver)&#123;</span><br><span class="line">            context.unregisterReceiver(mReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MainActivity</code> 使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        KeepAliveManager.getInstance().registerReceiver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        KeepAliveManager.getInstance().unregisterReceiver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>亲身实践了，发现确实<code>oom_adj</code> 变小，被杀死的概率比较低了，当屏幕变暗的时候。</p>
<h1 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h1><p><code>ForegroundService.java</code>   :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForgroundService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_ID = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT &lt; <span class="number">18</span>)&#123;</span><br><span class="line">            <span class="comment">//设置成前台服务，并且不显示通知栏消息</span></span><br><span class="line">            startForeground(SERVICE_ID,<span class="keyword">new</span> Notification());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Build.VERSION.SDK_INT &lt; <span class="number">26</span>)&#123;</span><br><span class="line">            startForeground(SERVICE_ID,<span class="keyword">new</span> Notification());</span><br><span class="line">            startService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>,InnerService.class));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//android 8.0</span></span><br><span class="line"></span><br><span class="line">            NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">            <span class="keyword">if</span>(manager != <span class="keyword">null</span>)&#123;</span><br><span class="line">                NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(<span class="string">"channel"</span>,<span class="string">"name"</span>,NotificationManager.IMPORTANCE_NONE);</span><br><span class="line">                manager.createNotificationChannel(channel);</span><br><span class="line">                NotificationCompat.Builder builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">"channel"</span>);</span><br><span class="line">				<span class="comment">//设置成前台服务，Android9.0 会有通知栏消息，需要添加新的权限</span></span><br><span class="line">                <span class="comment">//&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE"/&gt;</span></span><br><span class="line">                startForeground(SERVICE_ID,builder.build());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">            startForeground(SERVICE_ID,<span class="keyword">new</span> Notification());</span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            stopSelf();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双进程守护"><a href="#双进程守护" class="headerlink" title="双进程守护"></a>双进程守护</h1><blockquote>
<p>后续补上…</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 进程保活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[INSTALL_FAILED_TEST_ONLY]]></title>
      <url>/2018/12/17/INSTALL-FAILED-TEST-ONLY/</url>
      <content type="html"><![CDATA[<blockquote>
<p>莫名其妙更新了 studio的配置，然后打包签名，利用<code>adb install xx.apk</code> 安装就出现了 <code>INSTALL_FAILED_TEST_ONLY</code>,安装失败。心想也没干什么啊，查阅相关资料后，<br>原因是：<code>Android Studio 3.0</code>会在<code>debug apk</code>的<code>manifest</code>文件<code>application</code>标签里自动添加 <code>android:testOnly=&quot;true&quot;</code>属性</p>
</blockquote>
<p>网上有说：将这个<code>android:testOnly=&quot;false&quot;</code> 添加到 <code>Application</code> 标签中，但是还是没有成功。</p>
<ul>
<li>解决办法一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -t xx.apk</span><br></pre></td></tr></table></figure>
<p>需要加上<code>-t</code>. 问题是解决了，可以安装成功了，但是对于以前qq 发送文件还是不能安装成功。</p>
<ul>
<li>解决办法二：<br>还是点击普通的绿色按钮安装，此时生成一个apk,我们再点击 <code>Build---&gt; Build Apk</code> 此时拿出 <code>output--&gt;apk--&gt;xx.apk</code> 可以正常安装了。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> studio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Moved Permanently]]></title>
      <url>/2018/12/14/Moved-Permanently/</url>
      <content type="html"><![CDATA[<blockquote>
<p>关于下载文件中包含重定向问题的解决方案。<br>之前下载文件没问题，但是今天遇到一个下载文件里包含重定向，还是用之前的下载文件的方法就不行了，默认浏览器打开下载，是自动重定向的。</p>
</blockquote>
<p>这是我以前的下载文件的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">            String result = <span class="string">""</span>;</span><br><span class="line">            OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(params[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">// 创建一个HttpURLConnection连接</span></span><br><span class="line">                URLConnection urlConn = (URLConnection ) url</span><br><span class="line">                        .openConnection();</span><br><span class="line">              </span><br><span class="line">                InputStream input = urlConn.getInputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 文件夹</span></span><br><span class="line">                File dir = <span class="keyword">new</span> File(Constant.K0_VOICE_DIR);</span><br><span class="line">                <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">                    dir.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 本地文件</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(Constant.K0_VOICE_DIR + params[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                    file.createNewFile();</span><br><span class="line">                    <span class="comment">// 写入本地</span></span><br><span class="line">                    output = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                    result = file.getAbsolutePath();</span><br><span class="line">                    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> inputSize = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((inputSize = input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        output.write(buffer, <span class="number">0</span>, inputSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                    output.flush();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    output.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//下载完成.....</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>按照这个下载，你会发现下载的例如<code>mp3</code> 会无法播放，点开查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; a href=&quot;https:xxxx&quot;&gt;Moved Permanently&lt;/ a&gt;.</span><br></pre></td></tr></table></figure></p>
<p><code>href</code> 里包含一个新的链接。需要添加如下代码，获取新的链接地址下载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> URLConnection urlConn = (URLConnection ) url</span><br><span class="line">                        .openConnection();</span><br><span class="line">//下载的文件中含有重定向链接</span><br><span class="line"> String redirect = urlConn.getHeaderField(&quot;Location&quot;);</span><br><span class="line">  if (redirect != null)&#123;</span><br><span class="line">     urlConn = new URL(redirect).openConnection();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>奉上我在 <code>stackoverflow</code> 上找到的答案：<br><img src="https://upload-images.jianshu.io/upload_images/1948557-095d000258975357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      
        
        <tags>
            
            <tag> Moved Permanently </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[okhttp初探]]></title>
      <url>/2018/12/12/okhttp%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用依赖最新的版本 <code>implementation(&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;)</code></p>
<p>网站：<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></p>
</blockquote>
<h1 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequests</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Response response = client.newCall(request).execute();</span><br><span class="line">        <span class="keyword">return</span> response.body().string();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MediaType JSON = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        String json = <span class="string">"http://www.roundsapp.com/post"</span>;</span><br><span class="line">        String url = bowlingJson(<span class="string">"Jesse"</span>,<span class="string">"Jake"</span>);<span class="comment">//json字符串</span></span><br><span class="line"></span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        RequestBody body = RequestBody.create(JSON,json);</span><br><span class="line"></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Response response = client.newCall(request).execute();</span><br><span class="line">        <span class="keyword">return</span> response.body().string();</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>1.创建 OkHttpClient 对象</p>
<p>2.创建 Request</p>
<p>3.同步或者异步发出请求</p>
<p>4.得到 Response</p>
</blockquote>
<p>同步执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断是否执行过，每个Call请求只能请求一次，如果需要重复执行可以使用clone 方法</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    timeout.enter();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.获取分发器 dispatcher, 执行 execute</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//3.获取网络请求的结果</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e = timeoutExit(e);</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.最后通知 dispatcher 执行完毕</span></span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>clone</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> RealCall <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(client, originalRequest, forWebSocket);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>Dispatcher.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当异步线程执行时，会依照不同的策略执行</span></span><br><span class="line">* Policy on when async requests are executed.</span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p><code>OkHttpClinet</code> 拿到返回结果，是通过 <code>getResponseWithInterceptorChain()</code> 方法，从名字上我们可以大概猜测方法的语义，通过一系列的拦截器链得到结果，我们可以看下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">// Build a full stack of interceptors.一个集合存储所有的拦截器啊</span></span><br><span class="line">   List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//用户自定义的拦截器，能拦截所有的请求</span></span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//猜测是重试机制</span></span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//请求的头信息，cookie,gzip</span></span><br><span class="line">   interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//猜测是缓存</span></span><br><span class="line">   interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//开始与目标服务器建立连接，获得RealConnection</span></span><br><span class="line">   interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">       <span class="comment">//用户自定义的 interceptor, 仅在生产网络请求时生效</span></span><br><span class="line">     interceptors.addAll(client.networkInterceptors());<span class="comment">//猜测是网络请求</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//向服务器发出一次网络请求的地方</span></span><br><span class="line">   interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">       originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">       client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>Interceptor</code> 是 <code>OkHttp</code> 最核心的一个东西，采用了责任链的设计模式，除了日常负责拦截请求进行一些额外处理，例如 cookie, 实际上它把网络请求，缓存，透明压缩等功能都统一在一起，每个功能都是一个 <code>Interceptor</code> , 它们再连接称为 <code>Intercepteor.Chain</code> 拦截链条，环环相扣，最终完成一次网络请求。</p>
<p><code>RealInterceptorChain.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A concrete interceptor chain that carries the entire interceptor chain: all application</span></span><br><span class="line"><span class="comment"> * interceptors, the OkHttp core, all network interceptors, and finally the network caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;<span class="comment">//所有的拦截器集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StreamAllocation streamAllocation;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpCodec httpCodec;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RealConnection connection;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Call call;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> readTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> writeTimeout;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> calls;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpCodec httpCodec, RealConnection connection, <span class="keyword">int</span> index, Request request, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener, <span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line">    <span class="keyword">this</span>.httpCodec = httpCodec;</span><br><span class="line">    <span class="keyword">this</span>.index = index;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.call = call;</span><br><span class="line">    <span class="keyword">this</span>.eventListener = eventListener;</span><br><span class="line">    <span class="keyword">this</span>.connectTimeout = connectTimeout;</span><br><span class="line">    <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">    <span class="keyword">this</span>.writeTimeout = writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Interceptor.<span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> millis = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Interceptor.<span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> millis = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Interceptor.<span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> millis = checkDuration(<span class="string">"timeout"</span>, timeout, unit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StreamAllocation <span class="title">streamAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpCodec <span class="title">httpStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EventListener <span class="title">eventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我没看懂，网上说是传递参数和执行拦截器，并且设定条件，每个拦截器都会执行 <code>proceed</code> 方法。</p>
<p>拦截器：<code>RetryAndFollowUpInterceptor.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This interceptor recovers from failures and follows redirects as necessary. It may throw an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> IOException&#125; if the call was canceled.</span></span><br><span class="line"><span class="comment"> 这个拦截器必要时会重试和重定向，可能会抛出异常在call被取消的时候</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">    <span class="keyword">this</span>.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123;<span class="comment">//被取消</span></span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>BridgeInterceptor.java</code></p>
<p>基本上请求的头信息，<code>Cookie</code> 压缩:   <code>gzip</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bridges from application code to network code. First it builds a network request from a user</span></span><br><span class="line"><span class="comment"> * request. Then it proceeds to call the network. Finally it builds a user response from the network</span></span><br><span class="line"><span class="comment"> * response.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CookieJar cookieJar;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>CacheInterceptor.java</code></p>
<p>缓存信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Serves requests from the cache and writes responses to the cache. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(InternalCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">     <span class="comment">//从缓存中获取 response</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1></li>
</ul>
<blockquote>
<p>okHttp 利用连接池来复用连接，避免反复握手建立连接，并且具备在合适的时候挥手连接的能力。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> okhttp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CAS机制]]></title>
      <url>/2018/12/11/CAS%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>背景介绍：CAS 完整名称为 ： “Compare and Swap” 比较并替换。</p>
<p>里面涉及三个基本操作数，内存地址值：V；旧的预期值：A；新的预期值：B。</p>
<p>规则：当更新变量时，只有当内存地址里的值V = 旧的预期值A，才能被成功的更新为B。</p>
</blockquote>
<p>举个例子:</p>
<ul>
<li><p>在内存地址V中，存在一个变量值为10的值：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-47b1c8227b762c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>此时线程一，线程二 ，同时去操作这个变量，例如都想+1；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-f3270a1b18e0640c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对于线程一来说： A：10； B: 11； V: 10</p>
<p>但是由于线程二比线程一执行的更快，此时线程二已经把内存地址V中的10更新为11.</p>
</li>
</ul>
<p>​    那么当线程一再次执行更新操作，发现 V = 11,A = 10,  V≠A，更新失败。</p>
<p>​    此时线程一需要重新读取内存中的值，并重新计算要更新的新值，计算后得出：</p>
<p>​    A= 11，B= 12. 重新提交请求，这个过程称为自旋。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-079d6e98119d08b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>​    首先<code>Compare</code> V== A， 然后进行<code>swap</code> , V = 12，被更新为12.</p>
<p>从思想上来说，<code>syncronized</code> 属于悲观锁，认为并发情况非常严重，<code>CAS</code> 机制属于乐观锁，认为并发情况并不是一种特别严重的情况，发生问题，不断尝试更新即可。</p>
<blockquote>
<p>使用场景：Atomic系列类，以及Lock系列类的底层实现；不适合高并发的场景，高并发还是 <code>syncronized</code> </p>
</blockquote>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li><p>CPU消耗大</p>
<blockquote>
<p>如果在多个线程并发去更新一个变量，多个线程同时去重复尝试更新某一个变量，却又一直不成功，循环往复就会给CPU造成很大的压力。</p>
</blockquote>
</li>
<li><p>不能保证代码块的原子性</p>
<blockquote>
<p>CAS 可以保证一个变量的原子性，却无法保证整个代码块的原子性。</p>
</blockquote>
</li>
<li><p>ABA问题—–最大的问题</p>
</li>
</ul>
<h1 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h1><p>举例说明：</p>
<p>假设有三个线程都要对内存地址V 中的 A 进行操作，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-60314392b088122f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>线程一：旧的预期值：A；新的预期值：B</p>
<p>线程二：旧的预期值：A；新的预期值：B</p>
<p>线程三：还未开始工作</p>
<ol>
<li>线程一首先进行了操作，顺利将A更新为B：<br><img src="https://upload-images.jianshu.io/upload_images/1948557-b40a30b649fba727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
<p>此时线程三上来了，它是：旧的预期值：B；新的预期值：A，此时发现：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-b40a30b649fba727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>​                        V(B) == B(B)，更新成功，变为图下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-67f24f8970d8bf77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>此时线程二开始工作，线程二的目标是：旧的预期值：A；新的预期值：B，同样一比对，相同，于是也更新成功，变为如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-b40a30b649fba727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>虽然从结果上来看，A 成功的变为 B，然后在实际涉及钱的时候，问题就大了。</p>
<p>再次举例：</p>
<p>小明银行卡里有200块钱，想取出100块钱，但是由于设备故障，提交了两次扣款申请。</p>
<p>扣款申请1：旧的预估值：200，新的预估值：100</p>
<p>扣款申请2：旧的预估值：200，新的预估值：100</p>
<p>此时，扣款申请1提前进行了操作，扣款成功，小明银行卡里为100块钱；</p>
<p>扣款申请2假设还在等待。//block</p>
<p>此时小明的妈妈给小明存储100元，ok, 现在小明银行卡里就是200块钱。</p>
<p>扣款申请2恢复正常，开始必对，旧的预估值：200，卡里余额200，成功，替换更新为100.  更新成功，那么此时小明银行卡里剩余金额：100块。</p>
<p>哈哈！！！这显然是不对的，虽然值相同，但是中间操作改变了最终的结果。那如何解决这个问题呢？可以利用版本号，每修改成功一次V，都要设置一个版本号。每次更新的时候，不但要比对值还要比对版本号，就可以避免这种错误。</p>
<p>好，就上面的例子说明下：</p>
<p>当扣款申请1完成更新操作时，我们设置内存地址V中的值的版本号为：：01</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-910dc6244e7f8607.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>第二次操作：妈妈成功向卡里存入了100块</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-6c8c948395b44f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>扣款申请2开始工作：</p>
<p>旧的预估值：200，新的预估值：100；版本号为00</p>
<p>而此时：V（200）= 旧的预估值（200）成立</p>
<p>​        版本号（00） ≠ version（02） 不成立</p>
]]></content>
      
        
        <tags>
            
            <tag> CAS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap 高并发导致的死循环]]></title>
      <url>/2018/12/07/HashMap-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">    </span><br><span class="line">     Entry&lt;K,V&gt; e = src[j];<span class="comment">//src 表示原table</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">        <span class="comment">//此处表示取出下一个位置的Entry(键值对)</span></span><br><span class="line">        Entry&lt;K&lt;V&gt; next = e.next;</span><br><span class="line">        <span class="comment">//计算得出在扩容后新数组table中的下标，因为扩容后要重新计算下标</span></span><br><span class="line">        <span class="comment">//未扩容前下标:index = hash(key) &amp; (length-1)</span></span><br><span class="line">        <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);</span><br><span class="line">        <span class="comment">//根据下标取出在新表newTable中的Entry&lt;K,V&gt;</span></span><br><span class="line">        e.next = newTable[i];</span><br><span class="line">        <span class="comment">//将当前e 赋值给newTable[i](Entry&lt;K,V&gt;)</span></span><br><span class="line">        newTable[i] = e;</span><br><span class="line">		<span class="comment">//将下一个next.Entry 赋值给当前的e	</span></span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例说明下：</p>
<p>原</p>
<p><code>table</code>的信息排列是：<img src="https://upload-images.jianshu.io/upload_images/1948557-23de68a7bfa7c35e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>再次添加新元素的时候就需要扩容了，此时我们来类比下上述的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">    </span><br><span class="line">     Entry&lt;K,V&gt; e = src[j];<span class="comment">//src 表示原table</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">        <span class="comment">//next = Entry2</span></span><br><span class="line">        Entry&lt;K&lt;V&gt; next = e.next;</span><br><span class="line">        <span class="comment">//假设计算结果为3；循环第二次：假设Entry2计算的位置也是3</span></span><br><span class="line">        <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);</span><br><span class="line">       <span class="comment">//第一次Entry1.next = newTable[3]，此时newTable[3]还为null；所以是Entry1.next地址指向null</span></span><br><span class="line">       <span class="comment">//循环第二次：Entry2.next = Entry1</span></span><br><span class="line">        e.next = newTable[i];</span><br><span class="line">       <span class="comment">//newTable[3] = Entry1, 此时e是 Entry1;</span></span><br><span class="line">       <span class="comment">//循环第二次： newTable[3] = Entry2</span></span><br><span class="line">        newTable[i] = e;</span><br><span class="line">		<span class="comment">//Entry1 = Entry2,e 指向了Entry2,好再次循环;</span></span><br><span class="line">        <span class="comment">//循环第二次：e = null,跳出循环</span></span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变成如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-0311750fe51fc624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上述是属于正常情况的那种，假设我们现在有两个线程同时去 <code>put</code> 元素，二者均发现需要做扩容处理，那么又会出现什么情况呢？</p>
<blockquote>
<p>参考阅读网上的博客+自己理解记录</p>
</blockquote>
<p>当线程一 和 线程二 同时进行插入的时候刚好达到扩容的条件，然后同时开始进行 <code>Resize</code> 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">    <span class="comment">//src 表示原table</span></span><br><span class="line">     Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K&lt;V&gt; next = e.next;<span class="comment">//假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">            <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程一挂起，线程二继续操作，变成如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-5a88832ba483e707.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>线程二是 <code>rehash</code> 之后的样子，如上图：</p>
<p>当前线程一来说：</p>
<p> <code>e</code> 是: <code>key(3)</code></p>
<p>  <code>next</code> 是： <code>key(7)</code></p>
<p>线程一来了，被调度回来了，该人家执行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;<span class="comment">//再次循环，e:key(7) next:key(3)</span></span><br><span class="line">    		<span class="comment">//假设线程一执行到这里就被调度挂起了,开始继续执行</span></span><br><span class="line">    		<span class="comment">//第二次循环：next = key(3),next 指向key(3)</span></span><br><span class="line">    		<span class="comment">//e:key(3) next:null</span></span><br><span class="line">           Entry&lt;K&lt;V&gt; next = e.next;</span><br><span class="line">           <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);<span class="comment">//根据线程二的计算不难推出线程一计算的i = 3</span></span><br><span class="line">           <span class="comment">//key(7).next 指向 key(3)</span></span><br><span class="line">    		<span class="comment">//key(3).next 指向 key(7)</span></span><br><span class="line">           e.next = newTable[i];</span><br><span class="line">    		<span class="comment">//first :   newTable[3] = key(3)</span></span><br><span class="line">    		<span class="comment">//second ： newTable[3] = key(7)</span></span><br><span class="line">    		<span class="comment">//third :   newTable[3] = key(3)</span></span><br><span class="line">           newTable[i] = e;</span><br><span class="line">    		<span class="comment">//e 指向key(7)</span></span><br><span class="line">    		<span class="comment">//e = key(3)</span></span><br><span class="line">    		<span class="comment">//e = null//退出循环</span></span><br><span class="line">           e = next</span><br></pre></td></tr></table></figure>
<p>这样就产生死循环了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key(<span class="number">7</span>).next 指向 key(<span class="number">3</span>)</span><br><span class="line">key(<span class="number">3</span>).next 指向 key(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>当我们取出一个key(5) 的一个值时，恰巧也是 <code>int i = 3</code> , 这样去取，就陷入<code>key(3),key(7)</code> 的死循环中去了。</p>
<p>为了更清晰的展示每一次循环，我决定分开来展示：</p>
<p>第一次：要从这个线程一恢复运行开始说起吧： <code>e: key(3) ;  next: key(7)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K&lt;V&gt; next = e.next;<span class="comment">//第一次的时候，线程一被卡住在这里，当时状态是：e:key(3),next:key(7)  这应该都没什么问题</span></span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//根据线程二的计算，这个值也应该是int i = 3</span></span><br><span class="line">            <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);</span><br><span class="line">    		<span class="comment">//key(3).next = newTable[3], 此时newTable[3]为null, key(3).next指向null</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">    		<span class="comment">//newTable[3] = key(3)</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">    		<span class="comment">//e = key(7),e指向key(7)</span></span><br><span class="line">            e = next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK, 由于<code>e = key(7)</code> 不为<code>null</code> ,循环继续：</p>
<p>第二次循环：经过上述循环，此时 <code>e: key(7),next: key(3)</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-4c55a39a57b101ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>由于线程二已经改变了这个整体<code>table</code> 的结构，当遍历到<code>key(7)</code> 时， <code>next: key(3)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;<span class="comment">//e:key(7) </span></span><br><span class="line">    		<span class="comment">//next = key(3)</span></span><br><span class="line">            Entry&lt;K&lt;V&gt; next = e.next;</span><br><span class="line">    		<span class="comment">//int i = 3</span></span><br><span class="line">            <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);</span><br><span class="line">    		<span class="comment">//key(7).next = key(3) , key(7).next指向key(3)</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">    		<span class="comment">//newTable[3] = key(7)</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">    		<span class="comment">//e = key(3) e指向key(3),不为null,循环继续</span></span><br><span class="line">            e = next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三次循环：<code>e : key(3) next:null</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;<span class="comment">//e:key(3) </span></span><br><span class="line">    		<span class="comment">//next = null next指向null</span></span><br><span class="line">            Entry&lt;K&lt;V&gt; next = e.next;</span><br><span class="line">    		<span class="comment">//int i = 3</span></span><br><span class="line">            <span class="keyword">int</span> i= indexFor(e.hash,newCapacity);</span><br><span class="line">    		<span class="comment">//key(3).next = key(7) key(3).next指向key(7)</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">    		<span class="comment">//newTable[3] = key(3)</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">    		<span class="comment">//e = null, 循环结束</span></span><br><span class="line">            e = next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>e : null, next:null</code>.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key(7).next指向key(3)</span></span><br><span class="line"><span class="comment">//key(3).next指向key(7)    这里产生死循环</span></span><br></pre></td></tr></table></figure>
<p>图就是这样的：最后<code>newTable[3] = key(3)</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-7f234b18992d6432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">         </p>
<p>over.</p>
]]></content>
      
        
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap基本知识]]></title>
      <url>/2018/12/06/HashMap%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>自我总结</p>
</blockquote>
<h1 id="什么是-HashMap"><a href="#什么是-HashMap" class="headerlink" title="什么是 HashMap?"></a>什么是 HashMap?</h1><p>首先看下类继承关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-efe988cf10bdbe95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p><code>HashMap</code> 是存储键值对的集合，一个 <code>key</code>–<code>value</code> , 这样的键值对也称为 <code>Entry</code> ，这些键值对分散存储于数组当中，组成 <code>HashMap</code> 的主干。</p>
</blockquote>
<ul>
<li><p>特点</p>
<p>其中 <code>key</code> 可为 <code>null</code> ；非线程安全；</p>
</li>
</ul>
<p>其中 <code>put</code> 方法 和 <code>get</code> 方法比较重要。</p>
<ul>
<li><p><code>put</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">           .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先根据 <code>key</code> 计算 <code>hash</code> 值 , 如何算出在 <code>Node</code> 数组中具体的下标呢？从上面代码我们可以大概看出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n-<span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<p>就是数组的长度 -1 &amp; <code>key</code> 的<code>hash</code> 值。</p>
<p>得到数组下标后，再把这个键值对放入进去，完成了 <code>put</code> 操作。</p>
<p>假设我们：  put(“qq”,”糖葫芦”) <code>hash(&quot;qq&quot;)</code>  = 2, 下标为2，那么结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-d546b4a3817d44ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>Entry1====&gt; [key = &quot;qq&quot;, value= &quot;糖葫芦&quot;]</code></p>
<p>但是总会有那么一种情况，就是不同 <code>key</code> 计算的 <code>hash</code> 之后是相同的，假如我们新 <code>put(&quot;mi&quot;,value=&quot;milo&quot;)</code> <code>index = hash(&quot;mi&quot;) = 2</code> 也是数组下标为2，那么此时在下标为2的位置就会通过 <strong>链表</strong> 的形式存储相应的键值对。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-02db6c08604d274a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>HashMap</code> 数组的每一个元素不止是一个<code>Entry</code> 对象，也是一个链表的头节点。每一个<code>Entry</code>对象通过 <code>Next</code> 指针指向它的下个 <code>Entry</code> 节点。当再有新的 <code>Entry</code> 映射到这个冲突位置时，也就是计算出 <code>hash</code> 值也是2，只需要插入到对应的链表当中去即可，注意：新插入的会在之前的前面，称为 <strong>头插入</strong>， 被新 <code>put</code> 进入的新元素可能被用到的概率大一些。</p>
<ul>
<li><p><code>get</code> 方法</p>
<p>了解了 <code>put</code> 方法，<code>get</code> 好理解些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一步：同样 根据 <code>key</code> 算出 <code>hash</code> 值；</p>
<p>第二步：根据 <code>hash</code>值和数组的长度 计算数组的下标 <code>index</code></p>
<p>第三步：假设我们取出我们 <code>get(&quot;qq&quot;)</code> 对应的值，我们知道下标是2，且是一个链表，我们需要循环遍历整个链表，找到 <code>key = &quot;qq&quot;</code> 的<code>Entry</code>。 </p>
</li>
<li><p>HashMap的默认长度是多少？为什么要那么定义？</p>
</li>
</ul>
<blockquote>
<p><code>HashMap</code> 默认长度是16，也可以自定义长度必须是2幂次方。之所以选择16，是为了方便于 <code>key</code> 映射 <code>index</code> 的算法。</p>
</blockquote>
<p>为了实现一个均匀的 <code>HashMap</code> ,数组的长度必须是 2 的幂次方，将 <code>index = hash(key) &amp; (length-1)</code> 这样做的效率也更高，通过位运算的方式。</p>
<p>举例：<code>book</code> 的 <code>hashcode</code>,结果为十进制的 3029737，二进制：1011100011101011101001；假定 <code>HashMap</code> 长度是默认的16， <code>length-1 = 15</code>,二进制： 1111；</p>
<p><code>index = hash(key) &amp; (length-1)</code></p>
<p>计算结果如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-3aafe8299c498f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>二进制：1001；十进制：就是index= 9。</p>
<p>那么假设我们自定义长度设置为：10. 那<code>length-1=9, 二进制就是：1001，我们重新计算下</code>index`, 如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-7c14459101e253f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>二进制为：1001 ；十进制就是： <code>index</code> = 9</p>
<p>然后我们再尝试一个新的 <code>HashCode</code>:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-db971df4f539f899.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果还是：1001；</p>
<p>然后我们继续来一个新的 <code>HashCode</code>:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-0109aae2931ed6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果还是：1001，<code>index= 9</code>.</p>
<p>也就是说，当 <code>HashMap</code> 长度为 10 的时候，多个 不同的<code>key</code>生成的 <code>index</code> 可能是相同的，相同的概率比较大，这样，显然不符合 <code>Hash</code> 算法均匀分布的原则。</p>
<p>反观长度为16或者2的幂次方，<code>length-1</code> 的值是所有二进制全为1，这种情况下，<code>index</code> 的结果等同于<code>HashCode</code> 的后几位值，只有输入的 <code>HashCode</code> 本身分布均匀，<code>Hash</code> 算法的结果也是均匀的。        </p>
]]></content>
      
        
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView更清晰地观察缓存]]></title>
      <url>/2018/11/28/RecycleView%E6%9B%B4%E6%B8%85%E6%99%B0%E5%9C%B0%E8%A7%82%E5%AF%9F%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>为了更清晰的观察 <code>recycleView</code> 缓存复用，在看到有一篇文章是打印缓存相关信息后，觉着确实是一种办法，比打断点更合适查看缓存的变化情况，就尝试自己写了写。</p>
</blockquote>
<p>这里我主要利用反射观察的是：<code>mCachedViews</code> 和 <code>recycleViewPool</code>  里面的变化情况。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; class1 = Class.forName(<span class="string">"android.support.v7.widget.RecyclerView"</span>);</span><br><span class="line">            Field field = class1.getDeclaredField(<span class="string">"mRecycler"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            RecyclerView.Recycler recycler = (RecyclerView.Recycler) field.get(recyclerView);</span><br><span class="line">            Field field1 = recycler.getClass().getDeclaredField(<span class="string">"mCachedViews"</span>);</span><br><span class="line">            field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ArrayList&lt;RecyclerView.ViewHolder&gt; mCachedViews = (ArrayList&lt;RecyclerView.ViewHolder&gt;) field1.get(recycler);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mCachedViews.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"mCachedViews::"</span>+mCachedViews.get(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            RecyclerView.RecycledViewPool viewPool = recyclerView.getRecycledViewPool();</span><br><span class="line">            <span class="comment">//这里之所以能获取到 RecycledViewPool中的mScrpa，需要新建一个android.support.v7.widget包，将该类放入该包下即可访问到。</span></span><br><span class="line">            SparseArray&lt;RecyclerView.RecycledViewPool.ScrapData&gt; list = viewPool.mScrap;</span><br><span class="line">            <span class="comment">//这里传入的类型type 是我在adapter中定义的，如下：</span></span><br><span class="line">            <span class="comment">//@Override</span></span><br><span class="line">            <span class="comment">//public int getItemViewType(int position) &#123;</span></span><br><span class="line">                <span class="comment">//return 666;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            RecyclerView.RecycledViewPool.ScrapData spra = list.get(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">            Field field2 = spra.getClass().getDeclaredField(<span class="string">"mScrapHeap"</span>);</span><br><span class="line">            ArrayList&lt;RecyclerView.ViewHolder&gt; mScrapHeap= (ArrayList&lt;RecyclerView.ViewHolder&gt;) field2.get(spra);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mScrapHeap.size();i++)&#123;</span><br><span class="line">                    Log.i(<span class="string">"xx"</span>,<span class="string">"mScrapHeapInfo::"</span>+mScrapHeap.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"================================================="</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>, <span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：反射获取</p>
<p>然后在 <code>recycleView</code> 滚动的时候，显示信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.addOnScrollListener(<span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line"><span class="comment">//                int recycleCount = recyclerView.getRecycledViewPool().getRecycledViewCount(666);</span></span><br><span class="line"><span class="comment">//                Log.i("xx","recyclePoolCount::"+recycleCount);</span></span><br><span class="line"></span><br><span class="line">                getInfo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>还有可以在 <code>adapter</code> 重写方法： <code>onViewRecycled(ViewHOlder holder)</code> 方法，可以查看最新被回收的位置<code>ViewHolder</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewRecycled</span><span class="params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line">      Log.i(<span class="string">"xx"</span>,<span class="string">"holder被回收了"</span>+holder);<span class="comment">//可以拿到被回收holder的相关信息</span></span><br><span class="line">      <span class="keyword">super</span>.onViewRecycled(holder);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样我们就可以通过日志的方式来近距离查看 <code>recyclerView</code> 复用回收。</p>
</blockquote>
<p>我们假设这样一个场景：总共假设有20个<code>item</code> ,使用 <code>GrideLayoutManager</code> 每行显示5个，一个屏幕差不多显示两行，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/1948557-27492586f55e0863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="image.png"></p>
<p>我们在 <code>adapter</code> 的 <code>onCreateViewHolder</code> 和 <code>onBindViewHolder</code> 方法的地方都打印日志，并且重写 <code>onViewRecycled</code> 方法，查看 <code>View</code> 的回收情况。</p>
<p>当我们向下滑动，将第一行的数据滑出屏幕后，我们发现打印日志如下：<br><img src="https://upload-images.jianshu.io/upload_images/1948557-c2458832f3c67cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们发现 2，3，4卡位的 <code>ViewHolder</code> 被回收了。这里的被回收是指添加到 <code>RecycleViewPool</code> 当中了。<br>此时 <code>mCachedViews</code> 中的缓存信息如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-0c788729353d624f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从日志上来看，它缓存了：1，0，15，16，17，18，19共7个卡位的数据。</p>
<blockquote>
<p>这里补充一下：<code>mCachedViews</code> 的大小在源码定义中默认是:<br><code>static final int DEFAULT_CACHE_SIZE = 2;</code>（当然也可以自己设置，通过 <code>RecyclerView #setItemViewCacheSize</code>，一般不设置）经过我的多次实验观察，当每行设置为5列时，<code>mCachedViews.size == 2+ 5 = 7</code>,当每行是4时，<code>mCachedViews.size == 2+ 4 = 6</code>，所以此时就是<code>mCachedView.size 是7</code>。</p>
</blockquote>
<p>问题1：为什么<code>mCachedViews</code> 缓存的卡位是1，0，15，16，17，18，19？<br>要回答这个问题，首先应该明白当我们在滑动第三行展示的时候，此时 <code>RecyclerView</code> 创建了第四行的 <code>ViewHolder</code>,即 15，16，17，18，19因为它们未曾展示到屏幕上，所以被 <code>mCachedViews</code> 缓存，继续滑动，第一行数据移出屏幕之外，也要回收了，0，1，2，3，4，5 这5个是将要被缓存，但是<code>mCachedVIews</code> 已经缓存了5个，势必只能再添加两个，两外三个卡位的 <code>ViewHolder</code> 将要被回收，<code>GrideLayoutManager</code> 默认从右往左回收：</p>
<p>第一次回收4，3卡位如图：<br><img src="https://upload-images.jianshu.io/upload_images/1948557-838bccbb3e3a5030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>第二次回收2卡位如图：</p>
<blockquote>
<p>因为此时缓存数量已到最大值7了，所以再次添加时，会移除第一个。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int cachedViewSize = mCachedViews.size();</span><br><span class="line">                    if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</span><br><span class="line">                        recycleCachedViewAt(0);</span><br><span class="line">                        cachedViewSize--;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-9937ef01f3e9ab4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>新缓存的2卡位被插入<code>index = 1</code> 的位置。<br>如此，我们就可以知道当1卡位会回收时，<code>mCachedViews</code> 中缓存的信息应该是，先移除第0个，也就是<code>position= 3</code> 的 <code>ViewHolder</code>,插入到 <code>index = 1</code> 的位置，顺序应该是：2，1，15，16，17，18，19，好我们看下日志：<br><img src="https://upload-images.jianshu.io/upload_images/1948557-8fa55d658c125d56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>是的，不出我们所料，至此到最后我们就知道了，当0卡位被回收时，<code>mCachedViews</code> 的缓存信息就是：1，0，15，16，17，18，19. 被移除的<code>ViewHolder</code> 被添加到了 <code>RecycleViewPool</code> 当中了，从 <code>RecycleViewPool</code> 当中取出的 <code>ViewHolder</code> 类似于全新的，但是不会重新调用 <code>onCreateViewHolder</code>,会重新调用 <code>onBindViewHolder</code> 重新绑定数据。</p>
]]></content>
      
        
        <tags>
            
            <tag> recycleView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap 原理]]></title>
      <url>/2018/11/22/ConcurrentHashMap-%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>背景知识：我们知道 <code>HashMap</code> 是线程不安全的，多线程情况下，进行<code>put</code> 操作会引起死循环，导致<code>CPU</code> 利用率比较高，所以在并发情况下不能使用 <code>HashMap</code> ;</p>
<p>而 <code>Hashtable</code> 是线程安全的，其实就是在 <code>put</code> 操作的时候加了 <code>syncronized</code>, 但是当一个线程在进行<code>put</code> 操作时，其它的线程连 <code>get</code> 操作也不能进行，导致阻塞或者轮询状态，所以竞争越来越激烈，效率低下。</p>
</blockquote>
<p>目录结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>锁分段技术</p>
<blockquote>
<p><code>Hashtable</code> 在多并发的情况下效率低下，是因为很多线程争夺同一把锁，而假如容器内有多把锁，每一把锁用于锁容器内的一部分数据，当多线程访问容器内不同段的数据时，线程间就不会存在锁竞争，从而有效的提高并发访问效率。</p>
</blockquote>
</li>
</ul>
<h1 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h1><blockquote>
<p>英文翻译：” 段“ </p>
</blockquote>
<p>内部结构是：二级的哈希表，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-10a2659ddd348113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>多个<code>Segment</code> 保存在一个名为<code>segments</code> 数组当中，每个 <code>Segment</code> 高度自治，各个 <code>Segment</code> 之前读写互不影响。</p>
<h1 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h1><ul>
<li><p><code>get</code>  </p>
<blockquote>
<p>想要获取里面的元素，按照结构，我们大概也能猜测出如何获取。</p>
</blockquote>
<ul>
<li><ol>
<li>首先根据 <code>key</code> 计算的 <code>hash</code> 值；</li>
<li>计算得出 在 <code>segments</code> 数组中的下标，根据下标得出相对应的 <code>Segment</code>；</li>
<li>再根据<code>key</code> 的 <code>hash</code> 值，找到<code>Segment</code> 数组中的位置</li>
</ol>
</li>
</ul>
</li>
<li><p><code>put</code> </p>
<blockquote>
<p>put 元素</p>
</blockquote>
<ul>
<li>1.首先根据 <code>key</code> 计算<code>hash</code> 值</li>
<li>2.通过 <code>hash</code> 值，定位到具体的 <code>Segment</code> 对象</li>
<li>3.获取可重入锁</li>
<li>4.再次通过 <code>hash</code> 值，定位到 <code>Segment</code> 数组中的具体位置</li>
<li>5.插入或覆盖原 <code>HashEntry</code> 对象</li>
<li>6.释放锁</li>
</ul>
</li>
</ul>
<h1 id="统计Size大小"><a href="#统计Size大小" class="headerlink" title="统计Size大小"></a>统计Size大小</h1><p><code>jdk 1.7</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">   <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>遍历所有的 <code>Segment</code></li>
<li>把 <code>Segment</code> 元素数量累加起来</li>
<li>把 <code>Segment</code> 修改次数累加起来</li>
<li>判断所有的<code>Segment</code> 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程有修改，尝试统计，统计次数+1；反之，统计结束。</li>
<li>如果统计次数超过阀值，则对每个 <code>Segment</code> 加锁，重新统计</li>
<li>再次判断总修改次数是否大于上一次的总修改次数，</li>
<li>释放锁，统计结束。</li>
</ol>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> concurrentHashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[集合随笔]]></title>
      <url>/2018/11/21/%E9%9B%86%E5%90%88%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<h1 id="1-ArrayList-和-HashMap-是否线程安全？"><a href="#1-ArrayList-和-HashMap-是否线程安全？" class="headerlink" title="1.  ArrayList 和 HashMap 是否线程安全？"></a>1.  ArrayList 和 HashMap 是否线程安全？</h1><blockquote>
<p><code>Collection</code> <code>ArrayList</code> <code>HashMap</code> <code>HashSet</code> 都是非同步的，线程是不安全的</p>
<p>集合中：<code>Vector</code> 和 <code>HashTable</code> 是线程安全的 </p>
</blockquote>
<table>
<thead>
<tr>
<th>Collection</th>
<th>—-&gt;  线程安全：Collections.synchronizedCollection()</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>—–&gt; Collections.synchronizedList()</td>
</tr>
<tr>
<td>HashMap</td>
<td>——&gt; Collections.synchronizedMap()</td>
</tr>
<tr>
<td>HashSet</td>
<td>——-&gt; Collections.synchronizedSet()</td>
</tr>
</tbody>
</table>
]]></content>
      
        
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Handler 相关总结]]></title>
      <url>/2018/11/21/Handler-%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ul>
<li><ol>
<li>首先一个线程中是可以创建多个 <code>Handler</code> 的，互不影响，默认在 <code>ActivityThread</code> 当中也创建了一个 <code>Handler H</code> ,我们还是可以在 <code>MainActivity</code> 中创建我们自己的 <code>Handler</code>, 互不影响；</li>
</ol>
</li>
<li><ol>
<li>一个线程 对应一个 <code>Looper</code> ,一个 <code>Looper</code> 对应一个 <code>MessageQueue</code> ;</li>
</ol>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> handler </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[性能优化]]></title>
      <url>/2018/11/21/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<ul>
<li><p>布局优化</p>
<ul>
<li><p>减少布局层次，单一可以用<code>LinearLayout</code> 解决的页面不用 <code>RelativeLayout</code>,如果布局复杂，则用<code>RelativeLayout</code> 更好，毕竟比起布局嵌套，这种会好些</p>
</li>
<li><p><code>&lt;include&gt;</code> 标签使用，主要用于布局重用</p>
<blockquote>
<p>需要注意的是：此标签内，如果外面指定了 <code>id</code> 里面跟布局也定义<code>id</code> 以外部定义为准。同时如果里面定义了 类似于 <code>android:layout_width=&quot;wrap_content&quot;</code> 的属性，需配套 <code>android:layout_height=&quot;wrap_content&quot;</code> 同时使用。</p>
</blockquote>
</li>
<li><p><code>&lt;merge&gt;</code> 标签一般和 <code>&lt;include&gt;</code> 标签配合使用。一般如果当前根布局例如是：<code>LinearLayout</code> ,<code>include</code> 的布局也是 <code>LinearLayout</code> ,那么 <code>include</code> 的根布局就可以使用 <code>&lt;merge&gt;</code> 标签代替<code>LinearLayout</code>.</p>
</li>
<li><p><code>&lt;ViewStub&gt;</code> 标签，意义为按需加载，轻量级，宽和高都是0，在实际开发中，有很多布局在正常情况下不会显示，比如网络异常的布局，这个时候没有必要在布局加载时就加载进来，通过<code>&lt;ViewStub&gt;</code> 就可以在需要用到的时候再加载，提高程序初始化的性能。</p>
</li>
</ul>
</li>
<li><p>绘制优化</p>
<blockquote>
<p>在 <code>onDraw()</code> 中不要创建新的局部对象，这是因为 <code>onDraw()</code> 可能会频繁的调用，这样就会在一瞬间产生大量的临时对象，这不仅占用过多的内存而且会导致系统频繁的gc, 降低程序的执行效率; 另外也不能做一些耗时的任务。</p>
</blockquote>
</li>
<li><p>内存泄漏优化</p>
<ul>
<li><p>静态变量导致的内存泄漏</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_combine);</span><br><span class="line"></span><br><span class="line">        mContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例模式导致的内存泄漏</p>
</li>
<li><p>属性动画导致的内存泄漏</p>
<blockquote>
<p>Android 3.0 之后，提供了属性动画，如果开启无限循环动画，隐藏后，未调用 <code>animator,cancel()</code> 来停止动画，也会发生内存泄漏，因为这个时候 <code>Activity</code> 的 <code>View</code> 被动画所持有，而 <code>View</code> 又持有 <code>Activity</code>, 最终<code>Activity</code> 无法释放。0- </p>
</blockquote>
</li>
</ul>
</li>
<li><p>响应速度优化和ANR日志</p>
<blockquote>
<p>响应速度优化的核心是避免在主线程做耗时操作， <code>Activity</code> 5s 未做出响应， <code>Service</code> 10s未做出响应，就会出现 ANR ,查看 <code>\data\anr</code> 目录下的 <code>trace,txt</code> 文件分析产生 ANR 的原因</p>
</blockquote>
</li>
<li><p>线程优化</p>
<blockquote>
<p>线程优化一般都是采用线程池，避免程序中存在大量的 Thread, 线程池可重用内部的线程，从而避免线程的创建和销毁所带来的性能开销。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高效使用RxJava]]></title>
      <url>/2018/11/20/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8RxJava/</url>
      <content type="html"><![CDATA[<p><code>Question</code></p>
<blockquote>
<p>场景一：在页面保存时，需要对页面所填写的一些列信息进行判断，确定正确无误后方可保存。</p>
</blockquote>
<p>例如：页面上中需要填写：姓名，性别，职业，年薪，住址等信息。</p>
<p>按照常规做法,我们有可能会这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Util.checkempty(mUserName))&#123;<span class="comment">//判断用户名是否为空</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Util.checkempty(mSex))&#123;<span class="comment">//判断性别是否为空</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">if</span>(Util.checkempty(mAddress))&#123;<span class="comment">//判断住址是否为空</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而用 <code>Rxjava.combineLatest</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建被观察者</span></span><br><span class="line">Observable userNameObservable =  Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                tv.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                        subscriber.onNext(s.toString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Observable sexObservable =  Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                sex.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                        subscriber.onNext(s.toString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Observable.combineLatest(userNameObservable, sexObservable, <span class="keyword">new</span> Func2&lt;String,String,Boolean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(String userName, String sex)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//判断用户名</span></span><br><span class="line">                <span class="keyword">boolean</span> isUserInvalid = !TextUtils.isEmpty(userName);</span><br><span class="line">                <span class="comment">//判断性别</span></span><br><span class="line">                <span class="keyword">boolean</span> isSexInvalid = !TextUtils.isEmpty(sex);</span><br><span class="line">                <span class="keyword">return</span> isUserInvalid &amp;&amp; isSexInvalid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//只有都满足条件后才会执行到这里</span></span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"信息："</span>+o);<span class="comment">//可以保存信息了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>场景二：搜索输入，避免多次调用搜索接口，搜索优化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                tv.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">                            subscriber.onNext(s.toString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).filter(<span class="keyword">new</span> Func1&lt;String, Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> !TextUtils.isEmpty(s);<span class="comment">//过滤为空的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).debounce(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        Log.i(<span class="string">"xx"</span>,<span class="string">"搜索字符串：："</span>+s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> rxjava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RxJava]]></title>
      <url>/2018/11/19/RxJava/</url>
      <content type="html"><![CDATA[<h1 id="1-变换"><a href="#1-变换" class="headerlink" title="1. 变换"></a>1. 变换</h1><ul>
<li><p><code>map()</code></p>
<blockquote>
<p>它是一对一的</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"image/logo.png"</span>)<span class="comment">//输入类型String,图片地址</span></span><br><span class="line">        .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getBitmap(filePath);<span class="comment">//转换为bitmap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">                showBitmap(bitmap);<span class="comment">//显示bitmap</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>flatMap()</code></p>
<blockquote>
<p>多对多转换</p>
</blockquote>
</li>
</ul>
<p>假如有这样一个场景，我们需要打印每个学生所修的课程，学生是一个集合，课程也是一个集合，如果按照<code>map()</code> 的做法如下：</p>
<blockquote>
<p>这里我选用我项目里随意一个bean 对象，意思不变</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UserInfo[] userInfos = <span class="keyword">new</span> UserInfo[<span class="number">3</span>];</span><br><span class="line">Observable.from(userInfos)</span><br><span class="line">                .map(<span class="keyword">new</span> Func1&lt;UserInfo, List&lt;AppInfo&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> List&lt;AppInfo&gt; <span class="title">call</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> userInfo.getAppInfos();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).subscribe(<span class="keyword">new</span> Action1&lt;List&lt;AppInfo&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(List&lt;AppInfo&gt; appInfos)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(AppInfo info : appInfos)&#123;</span><br><span class="line">                    Log.i(<span class="string">"xx"</span>,info.getAppName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>有种情况就是假如我不想要循环遍历呢，而是直接拿到 <code>AppInfo</code> 对象，显然 <code>map()</code> 是无法实现的，<code>map()</code> 我们前面也说过是 一对一的转换，而现在是一对多，那此时就应该用 <code>flatMap()</code>.</p>
<p>使用<code>flatMap()</code> 的话，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(userInfos)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Func1&lt;UserInfo, Observable&lt;AppInfo&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Observable&lt;AppInfo&gt; <span class="title">call</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.from(userInfo.getAppInfos());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;AppInfo&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</span><br><span class="line">                        Log.i(<span class="string">"xx"</span>,<span class="string">"appInfo.name::"</span>+appInfo.getAppName());</span><br><span class="line">                    &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>
<p>上述是用  <code>flatMap()</code> 编写的，去除了 <code>for</code> 循环，<code>flatMap()</code> 和 <code>map()</code> 有一个相同点：它们都是把传入的参数转化之后返回另一个对象。但需要注意的是，和<code>map()</code> 不同的是，<code>flatMap()</code> 中返回的是 <code>Observable</code> 对象。</p>
<p><code>flatMap()</code> 原理如下：</p>
<ul>
<li>使用传入的事件对象创建一个 <code>Observable</code> 对象；</li>
<li>并不发送这个 <code>Observable</code> 对象，而是将它激活，于是它开始发送事件；</li>
<li>每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code>,而这个 <code>Observale</code> 负责将这些事件统一交给 <code>Subscriber</code> 的回调方法。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Rxjava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[时间复杂度]]></title>
      <url>/2018/11/19/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>衡量代码的好坏，包括两个非常重要的指标：</p>
<ul>
<li>运行时间</li>
<li>占用空间</li>
</ul>
</blockquote>
<p>由于运行环境和输入规模的影响，代码的绝对执行时间是无法估计的，但是我们却可以预估代码的基本执行次数。我可以通俗的理解为：通过执行次数可以大概推算这个时间复杂度。</p>
<p>示例：</p>
<ul>
<li><p>一个有序排列好的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arry = &#123;-<span class="number">5</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">35</span>,<span class="number">46</span>&#125;,输入一个x，<span class="keyword">int</span> x = <span class="number">31</span></span><br></pre></td></tr></table></figure>
<p>在数组中找出和为  <code>x</code>  的两个数，例如： 9 +22 = 31。要求时间复杂度为<code>O(n)</code>.</p>
</li>
</ul>
<p>好，当我们看到这个问题的时候，我们认为这很容易嘛(先不考虑时间复杂度)，于是写了如下代码：</p>
<p>第一种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] array = &#123;-<span class="number">5</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">35</span>,<span class="number">46</span>&#125;;</span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="comment">//sum 在数据中找出和为sum的两个数</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">                <span class="comment">//判断是否相加=sum</span></span><br><span class="line">                <span class="keyword">if</span>(array[i] + array[j] == sum)&#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"第一个数的为："</span>+array[x]);</span><br><span class="line">        System.out.println(<span class="string">"第二个数的为："</span>+array[y]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据我们上面对时间复杂度的了解，我们知道改算法的时间复杂度是 <code>O(n^2)</code>， 是最低的一种，可以说，那么我们如何把时间复杂度设置为<code>O(n)</code> ,线性复杂度，其实就是需要一遍<code>for</code> 循环；</p>
<p>第二种算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;-<span class="number">5</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">35</span>,<span class="number">46</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">getSimpleIndex</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;<span class="comment">//第一次遍历数组，将元素和下标以K-V方式存入hm中</span></span><br><span class="line">            hm.put(array[i], i);<span class="comment">//key 为数组里面的值，value是下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;<span class="comment">//第二次遍历数组，查找是否有和为target的元素对</span></span><br><span class="line">            <span class="keyword">if</span> (hm.containsKey(target - array[i]) &amp;&amp; (i != hm.get(target - array[i]))) &#123;</span><br><span class="line">                <span class="comment">//保证两个元素不是同一个，否则如果target恰好是某个元素的2倍时就不符合题意</span></span><br><span class="line">                x = i;</span><br><span class="line">                y = hm.get(target - array[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(array[x]+<span class="string">" "</span>+array[y]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这是一种典型以空间换时间的解法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>常见的时间复杂度有如下：</p>
<ul>
<li>T(n) = O(n)</li>
<li>T(n) = O(logn)</li>
<li>T(n) = O(1)</li>
<li>T(n) = O(n²)</li>
</ul>
<p>这四种时间复杂度谁用时更长，更节省时间呢？</p>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(n²)</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java生产者消费者模式]]></title>
      <url>/2018/11/19/java%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><code>Producter.java</code> 生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(String name,Queue&lt;Integer&gt; queue,<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue)&#123;</span><br><span class="line">                <span class="keyword">while</span>(queue.size() == maxSize)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Queue is full,Productr["</span>+name+<span class="string">" ]thread waiting for"</span>);</span><br><span class="line">                        <span class="comment">//等待</span></span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"["</span>+name+<span class="string">"] producting value:+"</span>+i );</span><br><span class="line">                queue.offer(i++);</span><br><span class="line">                queue.notifyAll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Consumer.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name,Queue&lt;Integer&gt; queue,<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue)&#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Queue is empty,Consumer ["</span>+name+<span class="string">"] thread is waiting for Producer"</span>);</span><br><span class="line">                        <span class="comment">//如果为空，就等待</span></span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> x = queue.poll();</span><br><span class="line">                System.out.println(<span class="string">"["</span>+name+<span class="string">" Consumer value : "</span>+x);</span><br><span class="line">                queue.notifyAll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>main.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Thread product1 = <span class="keyword">new</span> Producter(<span class="string">"p-1"</span>,queue,<span class="number">5</span>);</span><br><span class="line">        Thread product2 = <span class="keyword">new</span> Producter(<span class="string">"p-2"</span>,queue,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Thread consumer1 = <span class="keyword">new</span> Consumer(<span class="string">"C1"</span>,queue,<span class="number">5</span>);</span><br><span class="line">        Thread consumer2 = <span class="keyword">new</span> Consumer(<span class="string">"C2"</span>,queue,<span class="number">5</span>);</span><br><span class="line">        Thread consumer3 = <span class="keyword">new</span> Consumer(<span class="string">"C3"</span>,queue,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        product1.start();</span><br><span class="line">        product2.start();</span><br><span class="line"></span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">        consumer3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android知识点三]]></title>
      <url>/2018/11/15/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/</url>
      <content type="html"><![CDATA[<h1 id="1-RecycleView-如何设置分割线的？"><a href="#1-RecycleView-如何设置分割线的？" class="headerlink" title="1. RecycleView 如何设置分割线的？"></a>1. RecycleView 如何设置分割线的？</h1><blockquote>
<p>它是读取系统自带的属性 <code>R.attr.listDivider</code>  属性，来设置分割线的，支持横向和纵向。</p>
</blockquote>
<h1 id="2-RecycleView-分割线的样式如何修改？"><a href="#2-RecycleView-分割线的样式如何修改？" class="headerlink" title="2. RecycleView 分割线的样式如何修改？"></a>2. RecycleView 分割线的样式如何修改？</h1><ul>
<li><p>第一种办法：因为 <code>R.attr.listDivider</code> 定义在系统样式中，那么我们可以重写这个属性修改，如下：</p>
<p>在<code>styles.xml</code> 中添加该属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><br><span class="line">        &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">        ....</span><br><span class="line">        &lt;item name="android:listDivider"&gt;@drawable/drawable_bg&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>drawable_bg</code> 为自定义分割线的<code>drawable</code>.</p>
</li>
<li><p>第二种办法：可以通过自带的 <code>setDrawable()</code> 改变，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DividerItemDecoration itemDecoration = <span class="keyword">new</span> DividerItemDecoration(<span class="keyword">this</span>,DividerItemDecoration.VERTICAL);</span><br><span class="line">        Drawable drawable = getResources().getDrawable(R.drawable.drawable_bg);</span><br><span class="line">        itemDecoration.setDrawable(drawable);</span><br><span class="line">        recyclerView.addItemDecoration(itemDecoration);</span><br></pre></td></tr></table></figure>
<h1 id="3-RecycleView-缓存"><a href="#3-RecycleView-缓存" class="headerlink" title="3. RecycleView 缓存"></a>3. RecycleView 缓存</h1><blockquote>
<p>缓存涉及三个类，分别是：</p>
</blockquote>
<ul>
<li><p><code>Recycler</code></p>
</li>
<li><p><code>RecycledViewPool</code></p>
</li>
<li><p><code>ViewCachedExtension</code> </p>
</li>
</ul>
</li>
<li><p><code>Recycler</code> : 用于管理已经废弃或者与 <code>RecyclerView</code> 分离的 <code>ViewHolder</code> </p>
<ul>
<li><code>mChangedScrap</code> : 与 <code>RecyclerView</code> 分离的 <code>ViewHolder</code> 列表</li>
<li><code>mAttachedScrap</code> : 未与 <code>RecyclerView</code> 分离的 <code>ViewHolder</code> 列表</li>
<li><code>mCachedViews</code> : <code>ViewHolder</code> 缓存列表</li>
</ul>
</li>
<li><p><code>RecycledViewPool</code> : <code>ViewHolder</code> 缓存池</p>
</li>
<li><p><code>ViewCachedExtension</code> : 开发者可以控制的 <code>ViewHolder</code> 缓存的帮助类</p>
</li>
</ul>
<p>获取缓存里的 <code>ViewHolder</code> 的关键方法是： <code>tryGetViewHolderForPositionByDeadline</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= mState.getItemCount()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Invalid item position "</span> + position</span><br><span class="line">                        + <span class="string">"("</span> + position + <span class="string">"). Item count:"</span> + mState.getItemCount()</span><br><span class="line">                        + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="keyword">false</span>;</span><br><span class="line">            ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 0) If there is a changed scrap, try to find from there</span></span><br><span class="line">            <span class="comment">// 0) 如果需要改变废弃的view，从这里查找</span></span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">                <span class="comment">//这里是 mChangedScrap 集合中取出</span></span><br><span class="line">                holder = getChangedScrapViewForPosition(position);</span><br><span class="line">                fromScrapOrHiddenOrCache = holder != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1) Find by position from scrap/hidden list/cache</span></span><br><span class="line">            <span class="comment">// 1） 这是从 mAttachedScrap 集合中查找</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">                <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                        <span class="comment">// recycle holder (and unscrap if relevant) since it can't be used</span></span><br><span class="line">                        <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                            <span class="comment">// we would like to recycle this but need to make sure it is not used by</span></span><br><span class="line">                            <span class="comment">// animation logic etc.</span></span><br><span class="line">                            holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                            <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                                removeDetachedView(holder.itemView, <span class="keyword">false</span>);</span><br><span class="line">                                holder.unScrap();</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                                holder.clearReturnedFromScrapFlag();</span><br><span class="line">                            &#125;</span><br><span class="line">                            recycleViewHolderInternal(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                        holder = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                <span class="keyword">if</span> (offsetPosition &lt; <span class="number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Inconsistency detected. Invalid item "</span></span><br><span class="line">                            + <span class="string">"position "</span> + position + <span class="string">"(offset:"</span> + offsetPosition + <span class="string">")."</span></span><br><span class="line">                            + <span class="string">"state:"</span> + mState.getItemCount() + exceptionLabel());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">                <span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></span><br><span class="line">                <span class="comment">// 2）从 mCachedViews 集合中查找缓存</span></span><br><span class="line">                <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                            type, dryRun);</span><br><span class="line">                    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// update position</span></span><br><span class="line">                        holder.mPosition = offsetPosition;</span><br><span class="line">                        fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">                    <span class="comment">// know it.</span></span><br><span class="line">                    <span class="comment">// 3 从mViewCacheExtension 获取</span></span><br><span class="line">                    <span class="keyword">final</span> View view = mViewCacheExtension</span><br><span class="line">                            .getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        holder = getChildViewHolder(view);</span><br><span class="line">                        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"getViewForPositionAndType returned"</span></span><br><span class="line">                                    + <span class="string">" a view which does not have a ViewHolder"</span></span><br><span class="line">                                    + exceptionLabel());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"getViewForPositionAndType returned"</span></span><br><span class="line">                                    + <span class="string">" a view that is ignored. You must call stopIgnoring before"</span></span><br><span class="line">                                    + <span class="string">" returning this view."</span> + exceptionLabel());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"tryGetViewHolderForPositionByDeadline("</span></span><br><span class="line">                                + position + <span class="string">") fetching from shared pool"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 4）从缓存池中获取 recycledViewPool</span></span><br><span class="line">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        holder.resetInternal();</span><br><span class="line">                        <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                            invalidateDisplayListInt(holder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> start = getNanoTime();</span><br><span class="line">                    <span class="keyword">if</span> (deadlineNs != FOREVER_NS</span><br><span class="line">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">                        <span class="comment">// abort - we have a deadline we can't meet</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果都没有 就重新创建 createViewHolder</span></span><br><span class="line">                    holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">                    .....</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>总结缓存的机制如下：</p>
<ul>
<li>1.从 <code>mChangedScrap</code> 或 <code>mAttachScrap</code> 中获取</li>
<li>2.从 <code>mCacheViews</code></li>
<li>3.从 <code>mRecycledViewPool</code> 缓存池中获取</li>
</ul>
<h1 id="4-RecycleView-刷新闪屏"><a href="#4-RecycleView-刷新闪屏" class="headerlink" title="4. RecycleView 刷新闪屏"></a>4. RecycleView 刷新闪屏</h1><p>一般刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adapter.notifyItemChanged(<span class="number">0</span>); 参数：position</span><br></pre></td></tr></table></figure>
<p>实际上会全部刷新，局部刷新应使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adapter.notifyItemChanged(<span class="number">0</span>,<span class="string">"q"</span>); 参数： position,payload</span><br></pre></td></tr></table></figure>
<p>并且在 <code>adapter</code> 中重写方法： <code>`onBindViewHolder(RecyclerView.ViewHolder holder, int position, List payloads)</code>方法`</p>
<p><code>payloads</code> 的 <code>size</code> 始终为1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position, List&lt;Object&gt; payloads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(payloads.isEmpty())&#123;</span><br><span class="line">            onBindViewHolder(holder,position);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        String type = payloads.get(<span class="number">0</span>);<span class="comment">//获取为 q</span></span><br><span class="line">            holder.name.setText(list.get(position));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-RecycleView-和-listView"><a href="#5-RecycleView-和-listView" class="headerlink" title="5. RecycleView 和 listView"></a>5. RecycleView 和 listView</h1><p>//<a href="https://zhuanlan.zhihu.com/p/23339185" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23339185</a></p>
<ul>
<li><p>缓存层级不同</p>
<blockquote>
<p>recycleView 比 listView 多两级缓存，支持开发者自定义缓存处理，支持多个recycleView共用同一个 recycleViewPool(缓存池)</p>
</blockquote>
</li>
</ul>
<p><code>listView</code> 缓存（两级缓存）：</p>
<table>
<thead>
<tr>
<th></th>
<th>是否需要回调createView</th>
<th>是否需要回调bindVIew</th>
<th>生命周期</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>mActiveViews</td>
<td>否</td>
<td>否</td>
<td>onLayout函数周期内</td>
<td>用于屏幕内itemView快速重用</td>
</tr>
<tr>
<td>mScrapViews</td>
<td>否</td>
<td>是</td>
<td>与mAdapter一致，当Adapter被更换时，mScrapViews即被清空</td>
</tr>
</tbody>
</table>
<p><code>RecycrleView</code> 缓存( 四级缓存)：</p>
<table>
<thead>
<tr>
<th></th>
<th>是否回调createView</th>
<th>回调bindVIew</th>
<th>生命周期</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>mAttachedScrap</td>
<td>否</td>
<td>否</td>
<td>onLayout</td>
<td>用于屏幕内itemView快速重用</td>
</tr>
<tr>
<td>mCacheViews</td>
<td>否</td>
<td>否</td>
<td>与mAdapter一致，当Adapter被更换时,mCacheVIews被缓存到mRecyclerPool</td>
<td>默认缓存大小是2</td>
</tr>
<tr>
<td>mViewCacheExtension</td>
<td></td>
<td></td>
<td></td>
<td>用户自定义实现</td>
</tr>
<tr>
<td>mRecyclerPool</td>
<td>否</td>
<td>是</td>
<td>与自身生命周期一致，不再引用时被释放</td>
<td>默认大小是5</td>
</tr>
</tbody>
</table>
<p><code>ListView</code> 和 <code>RecyclerView</code> 缓存机制：</p>
<ul>
<li><code>mActiveViews</code> 和 <code>mAttachedScrap</code> 功能相似，意义在于快速重用屏幕上可见的列表项 <code>itemView</code>,而不需要重新<code>createView</code> 和 <code>bindView</code></li>
<li><code>mScrapView</code> 和 <code>mCachedViews</code> + <code>mRecyclerViewPool</code> 功能相似，意义在于缓存离开屏幕的<code>itemView</code>,目的是让即将进入屏幕的 <code>itemView</code> 重用</li>
<li><code>RecycleView</code> 的优势在于 <code>mCacheVIews</code> 的使用，可以做到屏幕外的列表项<code>itemView</code> 进入屏幕内时也无须<code>bindView</code> 快速重用； <code>mRecycleViewPool</code> 可以供多个<code>recycleView</code> 共同使用，在特定场景下，如<code>viewpager</code> 加多个列表页有优势。</li>
</ul>
<h1 id="6-RecycleView-的回收复用机制的内部实现都是哪个类完成的？"><a href="#6-RecycleView-的回收复用机制的内部实现都是哪个类完成的？" class="headerlink" title="6. RecycleView 的回收复用机制的内部实现都是哪个类完成的？"></a>6. RecycleView 的回收复用机制的内部实现都是哪个类完成的？</h1><blockquote>
<p>RecycleView 的回收复用机制都是由内部类 <code>Recycler</code>  类，核心方法：<code>tryGetViewHolderForPositionByDeadline()</code> 方法中完成的。</p>
</blockquote>
<p>随笔源码记录：</p>
<h1 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, 		               FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//复用机制的原理</span></span><br><span class="line">    - <span class="number">1</span>.mCacheView</span><br><span class="line">    - <span class="number">2</span>.recyclerViewPool</span><br><span class="line">    - <span class="number">3</span>.扩展</span><br><span class="line">    - <span class="number">4</span>.都没有，重新创建一个ViewHolder(createViewHolder)   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h1><blockquote>
<p>也是 Recycler 类中的，核心方法：<code>recycleViewHolderInternal(holder)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycleView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This public recycle method tries to make view recycle-able since layout manager</span></span><br><span class="line">            <span class="comment">// intended to recycle this view (e.g. even if it is in scrap or change cache)</span></span><br><span class="line">            ViewHolder holder = getChildViewHolderInt(view);</span><br><span class="line">            <span class="keyword">if</span> (holder.isTmpDetached()) &#123;</span><br><span class="line">                removeDetachedView(view, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                holder.unScrap();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                holder.clearReturnedFromScrapFlag();</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//回收的内部实现</span></span><br><span class="line">            recycleViewHolderInternal(holder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>回收的逻辑：由 <code>LayoutManager</code> 来遍历移出屏幕的卡位，然后对每个卡位进行回收操作，回收时，都是把 <code>viewHolder</code> 放在 <code>mCachedViews</code> 里面，如果<code>mCachedViews</code> 满了，那就在<code>mCachedViews</code> 里拿一个<code>ViewHolder</code> 扔到 <code>ViewPool</code> 缓存里，然后<code>mCachedViews</code> 就可以空出位置来放新回收的<code>ViewHolder</code> 了。</p>
<blockquote>
<p><code>mCachedViews</code> 里存放的 <code>ViewHolder</code> 只有原本位置的卡位才能复用</p>
<p>参考链接：<a href="https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/79946425" target="_blank" rel="noopener">https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/79946425</a></p>
</blockquote>
<p>===================================================================================</p>
<ul>
<li><code>updateViewCacheSize()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateViewCacheSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> extraCache = mLayout != <span class="keyword">null</span> ? mLayout.mPrefetchMaxCountObserved : <span class="number">0</span>;</span><br><span class="line">            mViewCacheMax = mRequestedCacheMax + extraCache;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一次向上滑动</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android知识点总结二]]></title>
      <url>/2018/11/14/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="1-Canvas-save-跟-Canvas-restore-的调用时机"><a href="#1-Canvas-save-跟-Canvas-restore-的调用时机" class="headerlink" title="1. Canvas.save()  跟 Canvas.restore()的调用时机"></a>1. Canvas.save()  跟 Canvas.restore()的调用时机</h1><blockquote>
<p>save: 用来保存 <code>Canvas</code> 的状态。<code>save</code> 之后，可以调用<code>Canvas</code> 的平移，放缩，旋转等操作。</p>
<p><code>restore</code>: 用来恢复<code>canvas</code> 之前保存的状态。防止<code>save</code> 后对<code>Canvas</code> 执行的操作对后续的绘制有影响。</p>
</blockquote>
<h1 id="2-Android-P-9-0-的新特性"><a href="#2-Android-P-9-0-的新特性" class="headerlink" title="2. Android P(9.0) 的新特性"></a>2. Android P(9.0) 的新特性</h1><ul>
<li>支持WiFi室内定位</li>
<li>适配刘海屏</li>
<li>通知栏改进：可以显示对话，附加照片和表情等</li>
<li>多摄像头api</li>
<li>对于非 <code>http</code> 连接，将直接拦截，推荐使用<code>https</code></li>
</ul>
<h1 id="Android-8-0"><a href="#Android-8-0" class="headerlink" title="Android 8.0"></a>Android 8.0</h1><blockquote>
<p>PHONE 权限组新增加两个权限</p>
<ul>
<li>ANSWER_PHONE_CALLS:允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 assceptRingingCall() 函数</li>
<li>READ_PHONE_NUMBERS: 权限允许您的应用读取设备中存储的电话号码</li>
</ul>
</blockquote>
<ul>
<li><p>通知适配</p>
<blockquote>
<p>为了更好的管理通知的提醒，不想一些不重要的通知打扰用户，新增加用户渠道，用户可根据渠道屏蔽一些不重要的通知</p>
</blockquote>
</li>
<li><p>安装apk</p>
<blockquote>
<p>在 AndroidManifest 文件中添加未知来源应用的权限：</p>
<p><code>&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt;</code> 这样系统会自动询问用户完成授权。</p>
<p>也可以通过 <code>canRequestPackageInstalls</code> 查询是否有此权限，如果没有的话就使用 <code>Settings.ACTION_MANAGE_UNKNOW_APP_SOURCE</code> 引导用户安装未知应用权限去授权。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Build,VERSION&gt;SDK_INT &gt;= <span class="number">26</span>)&#123;</span><br><span class="line">     Boolean isInstall = getPackageManager().canRequestPackageInstalls();<span class="comment">//26以上</span></span><br><span class="line">    <span class="keyword">if</span>(isInstall)&#123;</span><br><span class="line">        <span class="comment">//有此权限，安装应用</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//跳转到 安装未知应用 权限界面，引导用户开启权限</span></span><br><span class="line">        Uri selfPackageUri = Uri.parse(<span class="string">"package:"</span> + <span class="keyword">this</span>.getPackageName());</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);</span><br><span class="line">                startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123;</span><br><span class="line">            <span class="comment">//如果权限开启，则开始安装应用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态广播无法正常接受</p>
</li>
</ul>
<h1 id="Android-N-7-0-的新特性"><a href="#Android-N-7-0-的新特性" class="headerlink" title="Android N(7.0) 的新特性"></a>Android N(7.0) 的新特性</h1><ul>
<li>私有文件外部将不能访问，通过<code>FileProvider</code> 可解决</li>
<li><code>SharedPreferences</code> 进程间通信模式闪退，<code>SecurityException</code></li>
</ul>
<h1 id="Android-6-0"><a href="#Android-6-0" class="headerlink" title="Android 6.0"></a>Android 6.0</h1><ul>
<li><p>运行时权限的申请</p>
</li>
<li><p><code>https</code> 的推荐</p>
</li>
</ul>
<h1 id="3-APK-内容"><a href="#3-APK-内容" class="headerlink" title="3. APK 内容"></a>3. APK 内容</h1><ul>
<li><code>assets</code> 存放需要打包到 <code>APK</code> 中的静态文件</li>
<li><code>lib</code> 目录  <code>native</code>库</li>
<li><code>res</code> 目录 存放应用程序的资源</li>
<li>META-INF 存放应用程序签名和证书的目录</li>
<li><code>AndroidManifest.xml</code> </li>
<li><code>classes.dex</code></li>
<li><code>resources.arsc</code> 资源配置文件</li>
</ul>
<h1 id="4-Binder-机制的优点"><a href="#4-Binder-机制的优点" class="headerlink" title="4. Binder 机制的优点"></a>4. Binder 机制的优点</h1><blockquote>
<p><code>Linux</code> 中使用的 <code>IPC</code> 通信机制有：<code>pipe</code>(管道)，<code>signal</code>(信号量)，<code>Socket</code></p>
<ul>
<li><code>socket</code>:是一个通用接口，传输效率低，开销比较大；</li>
<li>管道和消息队列：采用存储转发方式，所以至少需要拷贝2次数据，效率低，共享内存虽然在传输时没有拷贝数据，但其控制机制复杂，而 <code>Binder</code> 更好传输性能。</li>
<li>安全性更高，可以建立私有通道，有身份标识（UID/PID）</li>
<li>另外一个优点就是，通过<code>binder</code> 可以很方便的调用<code>server</code> 端的方法，犹如调用本地方法一样。</li>
</ul>
</blockquote>
<h1 id="5-Gradle-的生命周期"><a href="#5-Gradle-的生命周期" class="headerlink" title="5. Gradle 的生命周期"></a>5. Gradle 的生命周期</h1><ul>
<li><p>1.初始化</p>
<blockquote>
<p>初始化主要是读取 <code>settings.gragle</code> 文件，用于确定哪些项目参与构建，并创建<code>Project</code> 实例</p>
</blockquote>
</li>
<li><p>2.配置</p>
<blockquote>
<p>配置阶段主要是为每个 <code>build.gradle</code> 文件配置 <code>project</code> 对象</p>
</blockquote>
</li>
<li><p>3.执行</p>
<blockquote>
<p>主要根据 <code>gradle</code> 命令和传入参数创建并执行任务</p>
</blockquote>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随笔记录Android]]></title>
      <url>/2018/11/13/%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95Android/</url>
      <content type="html"><![CDATA[<h1 id="1-Android中数据存储的方式"><a href="#1-Android中数据存储的方式" class="headerlink" title="1. Android中数据存储的方式"></a>1. Android中数据存储的方式</h1><ul>
<li><code>FIle</code></li>
<li><code>SharedPreference</code></li>
<li><code>Sqlite</code></li>
<li>网络</li>
<li><code>ContentProvider</code></li>
<li><code>FileProvider</code> : 继承于 <code>ContentProvider</code> 的子类，可以用于解决Android7.0中禁止我们的应用对外部公开file://的问题。</li>
</ul>
<h1 id="2-SharedPreference-是进程同步的吗"><a href="#2-SharedPreference-是进程同步的吗" class="headerlink" title="2. SharedPreference 是进程同步的吗"></a>2. SharedPreference 是进程同步的吗</h1><blockquote>
<p>sharedPreference 默认不是线程同步的，可以设置模式为：<code>MODE_MULTI_PROCESS</code> 做到进程同步，系统默认也是有缓存的，有很多问题，在Android N（7.0）以上废弃不能使用了，会抛出异常。推荐使用 <code>ContentProvider</code> </p>
<p><code>sharedPreference</code> 四种模式：</p>
<ul>
<li>MODE_PRIVATE</li>
<li>MODE_MULTI_PROCESS</li>
<li>MODE_WORLD_READABLE</li>
<li>MODE_WORLD_WRITEABLE</li>
</ul>
</blockquote>
<h1 id="3-Shareferences-commit-和-apply-的区别"><a href="#3-Shareferences-commit-和-apply-的区别" class="headerlink" title="3.Shareferences commit 和 apply 的区别"></a>3.Shareferences commit 和 apply 的区别</h1><blockquote>
<p>在很早的sdk当中，一般都使用 <code>commit</code> 方法，同步，直接写入磁盘，并且有返回结果 <code>boolean</code> 类型，而 <code>apply</code> 是异步, 先写入内存，然后异步写入磁盘。 如果操作频繁的话，<code>apply</code> 的性能优于 <code>commit</code>.</p>
</blockquote>
<p>在阿里巴巴开发手册中也记录到：</p>
<blockquote>
<p>SharedPreference 提 交 数 据 时 ， 尽 量 使 用 Editor#apply()<br>，而非Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使用 Editor#commit()。</p>
</blockquote>
<h1 id="4-View-的-measureSpec-由谁决定的"><a href="#4-View-的-measureSpec-由谁决定的" class="headerlink" title="4. View 的 measureSpec 由谁决定的"></a>4. View 的 measureSpec 由谁决定的</h1><blockquote>
<ul>
<li>View的<code>MeasureSpec</code> 由这个父控件的<code>MeasureSpec</code> 和自身的 <code>LayoutParams</code> 决定</li>
<li>顶级 <code>DecorView</code> 由窗口尺寸和自身的 <code>LayoutParams</code> 共同确定</li>
</ul>
</blockquote>
<h1 id="5-ACTION-CANCEL-事件"><a href="#5-ACTION-CANCEL-事件" class="headerlink" title="5.ACTION_CANCEL 事件"></a>5.ACTION_CANCEL 事件</h1><blockquote>
<p>一般来说，如果一个子视图接受了父视图分发给它的 <code>ACTION_DOWN</code> 事件，那么与<code>ACTION_DOWN</code> 事件相关的事件都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个<code>ACTION_CANCEL</code> 事件。</p>
</blockquote>
<h1 id="6-View的invalidate-postInvalidate-requestLayout区别"><a href="#6-View的invalidate-postInvalidate-requestLayout区别" class="headerlink" title="6. View的invalidate postInvalidate requestLayout区别"></a>6. View的invalidate postInvalidate requestLayout区别</h1><ul>
<li><code>invalidate</code> 会调用 <code>onDraw</code> 进行重绘，只能在主线程</li>
<li><code>postIncalidate</code> 可以在其它线程，如子线程</li>
<li><code>requestLayout</code> 会调用 <code>onLayout</code> 和 <code>onMeasure</code> ,不一定会调用 <code>onDraw</code> </li>
</ul>
<h1 id="7-View-的生命周期"><a href="#7-View-的生命周期" class="headerlink" title="7. View 的生命周期"></a>7. View 的生命周期</h1><ul>
<li><ol>
<li><p><code>Creation</code> 创建（从xml中加载或者<code>layout</code> 文件中定义加载）</p>
<ol>
<li><code>onFinishInflate()</code> 从xml中加载完成</li>
</ol>
</li>
<li><p><code>Layout</code>  布局</p>
<ol>
<li><code>onMeasure()</code></li>
<li><code>onLayout()</code></li>
</ol>
</li>
<li><p><code>Drawing</code> 绘制</p>
<ol>
<li><code>onDraw()</code></li>
</ol>
</li>
<li><p><code>Event processing</code>  事件处理</p>
</li>
<li><p><code>Focus</code> 聚焦</p>
<ol>
<li><code>onFocusChanged()</code></li>
<li><code>onWindowFocusChanged()</code></li>
</ol>
</li>
<li><p><code>Attaching</code> 附上</p>
<ol>
<li><code>onAttachingToWindow()</code></li>
<li><code>onDetachedFromWindow()</code></li>
<li><code>onVisibiltyChanged()</code></li>
<li><code>onWindowVisibiltyChanged()</code></li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java基础二]]></title>
      <url>/2018/11/13/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续….仍需要查阅大量资料学习….</p>
<h1 id="2-Java-内存分配"><a href="#2-Java-内存分配" class="headerlink" title="2.Java 内存分配"></a>2.Java 内存分配</h1><ul>
<li>栈区：方法区内的局部变量，对象的引用等 优点：速度快，缺点：大小和生命周期必须是确定的。</li>
<li>堆区：new出来的对象，垃圾回收器回收的是堆区的内存</li>
<li>方法区（静态区）：静态变量，常量，保存类信息</li>
</ul>
<h1 id="3-垃圾"><a href="#3-垃圾" class="headerlink" title="3.垃圾"></a>3.垃圾</h1><blockquote>
<p>什么是垃圾？要通过科学的方法才能判断是否是为垃圾，有两种方法</p>
<ul>
<li>引用计数法：可能会导致内部循环</li>
<li>可达性分析：是否可达</li>
</ul>
</blockquote>
<p>借助一个图快速理解  <strong>引用计数法</strong>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-856824d0d0e05a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**循环问题*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo a=<span class="keyword">new</span> Demo();</span><br><span class="line">        Demo b=<span class="keyword">new</span> Demo();</span><br><span class="line">        a.instance=b;</span><br><span class="line">        b.instance=a;</span><br><span class="line">        a=<span class="keyword">null</span>;</span><br><span class="line">        b=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下这个 <strong>可达性分析</strong> ：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-5edf039e8f4eb629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>ObjD</code> 和 <code>ObjE</code> 虽然内部存在引用，但是定点不可达，所以也是垃圾回收的对象。</p>
<h1 id="4-垃圾回收的方法"><a href="#4-垃圾回收的方法" class="headerlink" title="4.垃圾回收的方法"></a>4.垃圾回收的方法</h1><ul>
<li><p>标记-清除：减少停顿时间，但会造成内存碎片</p>
</li>
<li><p>标记-整理：可以解决内存碎片，但是会增加停顿时间</p>
</li>
<li><p>复制清除：从一个地方拷贝到另一个地方，适合有大量回收的场景，比如：新生代回收</p>
<ul>
<li>优点：效率高于标记清除，活着的对象是整齐排列的，没有内存碎片</li>
<li>缺点： 浪费空间，毕竟如果按照1：1比例划分空间的话，那么将会有50%的空间被浪费。不过在jvm中，新生代空间并不是按照1：1来划分的，而是按照8：1：1的比例分为一个<code>eden</code> 区 和两个<code>survivor(survivor0,survivor1)</code> 区，然后一个<code>eden</code> 区，两个<code>survivor</code> 区。大部分对象在<code>Eden</code> 区中生成。回收时先将<code>eden</code> 区存活对象复制到一个<code>survicor0</code> 区，然后清空<code>eden</code> 区，当这个<code>survivor0</code>区也存放满了时，则将<code>eden</code>区和<code>survivor0</code>区存活对象复制到另一个<code>survivor1</code> 区，然后清空<code>eden</code> 区和<code>survivor0</code> 区，此时<code>survivor0</code>区是空的，然后将<code>survivor0</code>区和<code>survivor1</code>区交换，即保持<code>survivor1</code>区为空，这样的过程也叫做<code>Minor GC</code>,每进行<code>Minor GC</code> 一次，存活着的对象的年龄就会+1，当存活着的对象的年龄到达15岁时，就会被送进年老代。 当然，当整个<code>survivor1</code>区不足以存放<code>Eden</code>和<code>survivor0</code>的存活对象时，也会将存活对象直接放到年老代。若是年老代也满了就会触发一次<code>Full GC</code>，也就是新生代，老年代都进行回收。</li>
</ul>
</li>
<li><p>分代收集：把内存区域分成不同代，根据年代不同采取不同的策略；</p>
<ul>
<li>新生代：存放新创建的对象，采用复制回收方法</li>
<li>年老代：这些对象垃圾回收的频率较低，采取标记整理法</li>
<li>永久代：存放Java本身的一些数据，当类不再使用时，也会被回收</li>
</ul>
<p>手稿：</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-ecdfdaa2192d6319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h1 id="5-Full-GC-触发的条件"><a href="#5-Full-GC-触发的条件" class="headerlink" title="5. Full GC 触发的条件"></a>5. Full GC 触发的条件</h1><ul>
<li>调用 <code>System.gc</code> 时，系统建议执行<code>Full GC</code> 但是不必然执行</li>
<li>年老代或者永久代空间不足</li>
</ul>
<h1 id="6-线程调度"><a href="#6-线程调度" class="headerlink" title="6. 线程调度"></a>6. 线程调度</h1><ul>
<li><code>wait()</code> :  object 方法，必须在同步代码块中使用，使当前线程处于等待状态，释放锁</li>
<li><code>notify()</code> ： 和 <code>wait</code> 联合使用，通知一个线程，具体通知哪个由jvm 决定，使用不当可能发生死锁</li>
<li><code>notifyAll()</code> ： 和<code>wait</code>  方法联合使用，通知所有线程，具体哪个线程获得运行权 <code>jvm</code> 决定</li>
<li><code>sleep()</code> ： 睡眠状态</li>
</ul>
<h1 id="7-线程同步"><a href="#7-线程同步" class="headerlink" title="7.线程同步"></a>7.线程同步</h1><ul>
<li><code>Synchronzied</code> 修饰</li>
<li><code>ThreadLocal</code> : 每个线程都有一个局部变量的副本，互不干扰。一种以空间换时间的方式。</li>
<li>线程安全的容器和方法，可以实现线程同步，如： <code>Collections.SynchronizedList()</code> 将 <code>List</code> 转为线程同步；用<code>ConurrentHashMap</code> 实现<code>hashmap</code> 线程同步。</li>
</ul>
<blockquote>
<p><code>volatile</code> 修饰的变量不会缓存在寄存器中，每次使用都会从主存器中读取；保证可见性，不保证原子性</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识]]></title>
      <url>/2018/11/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="1-如何实现对象克隆？"><a href="#1-如何实现对象克隆？" class="headerlink" title="1. 如何实现对象克隆？"></a>1. 如何实现对象克隆？</h1><p>有两种方式：</p>
<ul>
<li><p>实现<code>Cloneable</code> 接口并重写 <code>clone</code> 方法（浅拷贝）；</p>
</li>
<li><p>实现<code>Serializable</code> ，通过对象的序列化和反序列化实现真正的深度克隆（深拷贝），代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型界定，可以检查出要克隆对象是否支持序列化，这项检查是编译器完成的，不是运行时抛出异常，这种方案明显优于使用object类的clone方法克隆对象。让问题在编译的时候暴漏出来总是优于把问题留在运行时。</p>
</blockquote>
</li>
</ul>
<h1 id="2-内部类访问局部变量的时候，为什么加final"><a href="#2-内部类访问局部变量的时候，为什么加final" class="headerlink" title="2. 内部类访问局部变量的时候，为什么加final?"></a>2. 内部类访问局部变量的时候，为什么加final?</h1><ul>
<li><p>内部类和局部变量的生命周期不同，方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类生命周期&gt;=局部变量</p>
</li>
<li><p>Java会在编译时在内部类的构造方法里边，将局部变量以参数形式传递给内部类</p>
</li>
<li><p>而如果局部变量发生改变，内部类不知情的场景，所以要加<code>fianl</code> ，保证引用不可改变</p>
<blockquote>
<p>注意：在Java8中，可以不适用final关键字，但是如果我们修改了局部变量还是会发生错误，从而保证局部变量的引用不变。</p>
</blockquote>
</li>
</ul>
<h1 id="3-transient-关键字"><a href="#3-transient-关键字" class="headerlink" title="3. transient 关键字"></a>3. transient 关键字</h1><blockquote>
<p>如果使用<code>transient</code> 修饰变量，当对象存储时，它的值不需要维持。换句话来说就是用<code>transient</code> 修饰的变量不参与序列化的过程。</p>
</blockquote>
<h1 id="4-String-和-StringBuild-StringBuffer的区别"><a href="#4-String-和-StringBuild-StringBuffer的区别" class="headerlink" title="4. String 和 StringBuild,StringBuffer的区别"></a>4. String 和 StringBuild,StringBuffer的区别</h1><blockquote>
<p><code>String</code> 是只读字符串,创建完成之后是不能修改，如果修改也是创建一个新对象，回收旧对象的过程，所以执行效率比较低，<code>StringBuild</code> 和 <code>StringBuffer</code> 可以改变，<code>StringBuild</code> 线程不安全，但是效率比较高，<code>StringBuffter</code> 线程安全</p>
<p>效率快慢：<code>Stringbuilder</code>&gt; <code>StringBuffer</code>&gt; <code>String</code></p>
</blockquote>
<h1 id="5-String-为什么设计成不可变"><a href="#5-String-为什么设计成不可变" class="headerlink" title="5. String 为什么设计成不可变"></a>5. String 为什么设计成不可变</h1><ul>
<li>安全性<ul>
<li>本身是<code>final</code> 类不可修改，不可变极为安全</li>
<li>String 常被用来作为 <code>HashMap</code> 的<code>key</code>  如果可变会引来安全问题，例如两个<code>key</code> 相同</li>
<li></li>
</ul>
</li>
<li>效率高<ul>
<li>通过字符串池可以节省很多空间</li>
<li>每一个<code>String</code> 对应一个 <code>hashcode</code> ,再次使用不用重新计算</li>
</ul>
</li>
</ul>
<h1 id="6-java-中的四种引用及应用场景"><a href="#6-java-中的四种引用及应用场景" class="headerlink" title="6. java 中的四种引用及应用场景"></a>6. java 中的四种引用及应用场景</h1><ul>
<li>强引用</li>
<li>弱引用—-引用到达，不可达就会被回收，即便是内存充足，可用于图片<code>Bitmap</code> 缓存，当不再使用<code>Bitmap</code> 时，就会被回收</li>
<li>软引用—–内存不足时被回收，也可用于<code>Bitmap</code>回收，当内存不足时，可回收</li>
<li>虚引用—-它指向的对象回收时，它本身会被加入到引用队列中，这样我们就知道它指向的对象何时被销毁</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeakCannary原理分析]]></title>
      <url>/2018/11/07/LeakCannary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>上篇写到  <a href="https://github.com/square/leakcanary">leakcanary</a> 的使用,这篇主要是了解<code>LeakCannary</code> 大概是如何工作的。</p>
</blockquote>
<h1 id="1-首先它是如何监听Activity-销毁的？"><a href="#1-首先它是如何监听Activity-销毁的？" class="headerlink" title="1.首先它是如何监听Activity 销毁的？"></a>1.首先它是如何监听<code>Activity</code> 销毁的？</h1><p>因为我们知道只有当<code>activity</code> 销毁（<code>onDestroy()</code>）的时候，我们才能对这个<code>activity</code> 进行分析查看哪些对象可能存在内存泄漏。</p>
<p>发现了如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">install</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class="line">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class="line">        .buildAndInstall();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>buildAndInstall()</code> 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ....</span><br><span class="line">   <span class="keyword">if</span> (refWatcher != DISABLED) &#123;</span><br><span class="line">     <span class="keyword">if</span> (watchActivities) &#123;</span><br><span class="line">     <span class="comment">//这是观察activity的</span></span><br><span class="line">       ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (watchFragments) &#123;</span><br><span class="line">       FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class="line">   <span class="keyword">return</span> refWatcher;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityRefWatcher</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context, RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">    Application application = (Application) context.getApplicationContext();</span><br><span class="line">    ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line">    <span class="comment">//拿到application，注册activity的生命周期回调</span></span><br><span class="line">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中这个：<code>lifecycleCallbacks</code> 就是回调监听<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">      <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;<span class="comment">//监听activity销毁</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">          refWatcher.watch(activity);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么我们也可以通过<code>application</code> 注册获取<code>activity</code> 的生命周期监听回调，如下是我写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCircleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.life_layout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Application application = (Application) getApplicationContext();</span><br><span class="line">        application.registerActivityLifecycleCallbacks(<span class="keyword">new</span> Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityCreated..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityStarted..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityResumed..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityPaused..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityStopped..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivitySaveInstanceState..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                application.unregisterActivityLifecycleCallbacks(<span class="keyword">this</span>);</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onDestroy..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以监听我们当前这个类的生命周期了，可以运行打印日志就知道了。</p>
<h1 id="2-内存泄漏的对象的引用路径"><a href="#2-内存泄漏的对象的引用路径" class="headerlink" title="2.内存泄漏的对象的引用路径"></a>2.内存泄漏的对象的引用路径</h1><p>这块使用到了 <code>square</code> 的另一个开源库 <a href="https://github.com/square/haha">haha</a> ,获取当前内存中的<code>heap</code>堆信息的<code>snapshot</code></p>
]]></content>
      
        
        <tags>
            
            <tag> leakcannary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2018/11/07/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80-leakcannary/</url>
      <content type="html"><![CDATA[<ul>
<li><p><code>build gradle</code>配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:1.6.1'</span></span><br><span class="line">releaseImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1'</span></span><br><span class="line"><span class="comment">// Optional, if you use support library fragments:</span></span><br><span class="line">debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-support-fragment:1.6.1'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>application</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">getRefWatcher</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        HealthApplication application = (HealthApplication) context.getApplicationContext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> application.refWatcher;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监测 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefWatcher refWatcher = MyApplication.getRefWatcher(<span class="keyword">this</span>);<span class="comment">//1</span></span><br><span class="line">       refWatcher.watch(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例如：我们写一个泄漏的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_event_bus);</span><br><span class="line"></span><br><span class="line">        RefWatcher refWatcher = MyApplication.getRefWatcher(<span class="keyword">this</span>);<span class="comment">//1</span></span><br><span class="line">        refWatcher.watch(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.obj = <span class="string">"qianqian"</span>;</span><br><span class="line">        message.what = <span class="number">666</span>;</span><br><span class="line">        handler.sendMessageDelayed(message,<span class="number">600000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"handle message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>界面上一个按钮，点击按钮退出程序，在程序 <code>onCreate</code> 方法中我们发送了一个延时的消息，按照我们的分析，肯定会发生泄漏的。来我们看下<code>leakcannary</code> 给我们的提示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-0ebd9f3bf02894c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<p>我们知道当我们退出程序的时候 <code>MessageQueue</code> 中的消息还没执行完毕，<code>MessageQueue.mMessages</code> 这个变量持有的是<code>Message</code> 这个对象，而 <code>Message.target</code>中的 <code>target</code>持有的该<code>Activity</code>的 <code>handler</code>引用，所以此时<code>finish</code> 掉的 <code>activity</code> 并不会被回收，导致<code>LeakActivity</code> 发生内存泄漏。</p>
<ul>
<li>其中一种解决办法呢，就是我们可以通过在点击或<code>activity</code> 退出时，<code>removeMessage</code>，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        handler.removeMessages(<span class="number">666</span>);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就不会有警告了。</p>
<p>也可以通过静态内部类+弱引用的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;LeakActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(SampleActivity activity)</span> </span>&#123;</span><br><span class="line">      mActivity = <span class="keyword">new</span> WeakReference&lt;LeakActivity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">      LeakActivityactivity = mActivity.get();</span><br><span class="line">      <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MyHandler handler= <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_event_bus);</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.obj = <span class="string">"qianqian"</span>;</span><br><span class="line">        message.what = <span class="number">666</span>;</span><br><span class="line">        handler.sendMessageDelayed(message,<span class="number">600000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实际项目中，可以用这个工具筛查一遍。</p>
]]></content>
      
        
        <tags>
            
            <tag> leakcannary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EventBus 源码分析（下篇）]]></title>
      <url>/2018/10/08/EventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>上篇  <a href="https://www.jianshu.com/p/bb25f4f56d65" target="_blank" rel="noopener">EventBus 源码分析（上篇）</a> 说到注册订阅的前半部分，此篇用来分析发送事件到接收事件这个过程。</p>
</blockquote>
<h1 id="1-发送事件"><a href="#1-发送事件" class="headerlink" title="1. 发送事件"></a>1. 发送事件</h1><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new RemindBean(&quot;2018-02-12&quot;,&quot;happy&quot;));</span><br></pre></td></tr></table></figure></p>
<p><code>post</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/** Posts the given event to the event bus. */</span><br><span class="line">    public void post(Object event) &#123;</span><br><span class="line">      - 1.获取当前线程的postingThreadState 对象</span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">      - 2. 获取里面那个事件队列</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        - 3. 将事件添加到队列中去</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">      - 4. 判断当前的event 是否在 posting</span><br><span class="line">        if (!postingState.isPosting) &#123;</span><br><span class="line">            - 5. 是否是主线程</span><br><span class="line">            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">            postingState.isPosting = true;</span><br><span class="line">            - 6. 判断是否取消</span><br><span class="line">            if (postingState.canceled) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (!eventQueue.isEmpty()) &#123;//不为空，进入循环</span><br><span class="line">                    - 7.按照顺序，post一个 remove一个</span><br><span class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postingState.isPosting = false;</span><br><span class="line">                postingState.isMainThread = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PostingThreadState</code> 大概看一眼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final static class PostingThreadState &#123;</span><br><span class="line">        final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;();</span><br><span class="line">        boolean isPosting;</span><br><span class="line">        boolean isMainThread;</span><br><span class="line">        Subscription subscription;</span><br><span class="line">        Object event;</span><br><span class="line">        boolean canceled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>再就是 <code>postSingleEvent(eventQueue.remove(0), postingState);</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">         - 1. 获取event的字节码（例如就是：RemindBean.class）</span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        boolean subscriptionFound = false;</span><br><span class="line">      </span><br><span class="line">        if (eventInheritance) &#123;//默认为true</span><br><span class="line">          - 2. 根据eventClass 的字节码查找</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">            int countTypes = eventTypes.size();</span><br><span class="line">            - 3.循环遍历</span><br><span class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                - 4.根据事件，字节码查找订阅者</span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!subscriptionFound) &#123;</span><br><span class="line">            if (logNoSubscriberMessages) &#123;</span><br><span class="line">                Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                post(new NoSubscriberEvent(this, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>postSingleEventForEventType</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          - 1.根据字节码取出subscriptions,还记得我们之前在subscribe这个方法的时候，</span><br><span class="line">把subscrber,subscriberMethod 封装成一个subscription 对象。</span><br><span class="line"></span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                - 2. 取出每一个subscription 对象</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                boolean aborted = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                  - 3. post到相应的线程中回调</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postingState.event = null;</span><br><span class="line">                    postingState.subscription = null;</span><br><span class="line">                    postingState.canceled = false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (aborted) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>postToSubscription</code>: 根据定义的不同线程，调用相应的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            case POSTING://一般没定义的，这个就是post在哪个线程，响应就在哪个线程执行</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            case MAIN:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case BACKGROUND:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>invokeSubscriber</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          - 反射拿到字节码clazz 反射调用方法，就收到消息了</span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>end.</p>
]]></content>
      
        
        <tags>
            
            <tag> EventBus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eventbus 源码分析（上篇）]]></title>
      <url>/2018/10/08/Eventbus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>可用于应用内的消息事件传递，方便快捷，耦合性低</p>
<h1 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class EventBusMain extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.content_main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        EventBus.getDefault().register(this);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  - 订阅的事件 onEvent1</span><br><span class="line">    @Subscribe</span><br><span class="line">    public void onEvent1(RemindBean bean)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">- 订阅的事件 onEvent2</span><br><span class="line">    @Subscribe</span><br><span class="line">    public void onEvent2(UserInfo bean)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要发送消息传递的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new RemindBean())</span><br></pre></td></tr></table></figure></p>
<h1 id="2-源码解读"><a href="#2-源码解读" class="headerlink" title="2.源码解读"></a>2.源码解读</h1><p>放上官网的一张原理图，感觉挺清晰的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-6624ab6edcfd5d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>发布消息的一方(<code>Publisher</code>)，只需要 <code>post</code> 一个 <code>event</code> 之后就不用管了，<code>EventBus</code> 内部会将<code>event</code>逐一分发给订阅此 <code>event</code> 的订阅者（<code>Subscriber</code>）. 不错就是这样一个东西。</p>
<p>还记得以往我要实现两个不同的<code>activity</code> 之间要传递一些数据的时候，我都是通过定义一个<code>interface</code>的形式完成，时间一长，定义的接口一堆，在回顾查看代码也确实不够美观。好了话不多说，看下大家都在用的<code>Eventbus</code>.</p>
<h1 id="3-首先"><a href="#3-首先" class="headerlink" title="3.首先"></a>3.首先</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure>
<p><code>getDefault()</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EventBus 是一个单例模式，懒汉式，双重判断</span><br><span class="line"> /** Convenience singleton for apps using a process-wide EventBus instance. */</span><br><span class="line">    public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance == null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance == null) &#123;</span><br><span class="line">                    defaultInstance = new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>register</code> 是什么意思呢，就是就跟你订阅报纸一样，报社需要确定几个重要的问题：</p>
<ul>
<li>订阅者是谁（<code>Subscriber</code>）？</li>
<li>订阅的什么报纸(<code>Event</code>) ？</li>
</ul>
<p>就是我认为比较重要的，那么<code>register</code> 这一步就是<code>Subscriber</code> 告诉 报社，订阅的<code>event</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        - 1.先拿到这个订阅者(subscriber)类的字节码</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"></span><br><span class="line">        - 2. 通过这个类的字节码，拿到所有的订阅的 event,存放在List中</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          - 3. 循环遍历所有的订阅的方法，完成subscriber 和 subscriberMethod 的关联</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看下这个如何根据<code>subscriberClass</code> 找到这个订阅的 <code>method</code>的，<code>findSubscriberMethods</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">       - 1.先从缓存中取</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line"></span><br><span class="line">       - 2. 第一次肯定 null</span><br><span class="line">       if (subscriberMethods != null) &#123;</span><br><span class="line">           return subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       - 3. 查找默认也是false，感兴趣的可以看下</span><br><span class="line">       if (ignoreGeneratedIndex) &#123;</span><br><span class="line">           subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         - 4. 所以是走这里</span><br><span class="line">           subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">       &#125;</span><br><span class="line">       if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">           throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                   + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           - 5. 找到之后添加到缓存中，key是 subscriber ;value 是：methods</span><br><span class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">           return subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看下：<code>findUsingInfo(subscriberClass)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        - 1. 我认为就是准备一个查找结果得存储对象</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line"></span><br><span class="line">        - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass </span><br><span class="line">        同时赋值给clazz变量中,以下代码能够看出</span><br><span class="line">//      void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line"> //      this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">//&#125;</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line"></span><br><span class="line">        while (findState.clazz != null) &#123;进入循环中</span><br><span class="line">          //获取subscriberInfo 信息，返回null</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                  - 3. 进入到这里了</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            - 4. 查找父类中的方法</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>findUsingReflectionInSingleClass</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">       Method[] methods;</span><br><span class="line">       try &#123;</span><br><span class="line">           // This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">         - 1. 通过订阅者的字节码查找当前类中所有生命的方法</span><br><span class="line">           methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">       &#125; catch (Throwable th) &#123;</span><br><span class="line">           // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">           methods = findState.clazz.getMethods();</span><br><span class="line">           findState.skipSuperClasses = true;</span><br><span class="line">       &#125;</span><br><span class="line">         - 2. 循环遍历所有的方法</span><br><span class="line">       for (Method method : methods) &#123;</span><br><span class="line">           - 3. 获取方法的修饰符</span><br><span class="line">           int modifiers = method.getModifiers();</span><br><span class="line">     </span><br><span class="line">           - 4.判断修饰符，订阅方法的修饰符不能是private，static</span><br><span class="line">           if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">               - 5. 获取方法的所有的参数</span><br><span class="line">               Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">               - 6.判断参数的个数，只能有1个参数，订阅方法中</span><br><span class="line">               if (parameterTypes.length == 1) &#123;</span><br><span class="line">               - 7.获取方法上具有subscribe 注解</span><br><span class="line">                   Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line"></span><br><span class="line">                   - 8.含有subscribe注解的方法，就是该类订阅的方法，其它不符合的可能就是普通的方法</span><br><span class="line">                   if (subscribeAnnotation != null) &#123;</span><br><span class="line"></span><br><span class="line">                     - 9. 获取第一个参数eventType</span><br><span class="line">                       Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                         </span><br><span class="line">                       if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                         - 10. 获取注解的mode，就是我们在注解上标识的，</span><br><span class="line">                     有mainThread,Posting,background,async</span><br><span class="line">                           ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line"></span><br><span class="line">                         - 11. 将订阅方法的一系列信息（方法名称，threadMode,优先级，是否是粘性等）添加到集合subscriberMethods中去</span><br><span class="line">                           findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">             - 12. 参数是多个的时候抛出异常</span><br><span class="line">                   String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                   throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                           &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">           - 13. 方法的修饰符不是public的，抛出异常                </span><br><span class="line"></span><br><span class="line">             String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">               throw new EventBusException(methodName +</span><br><span class="line">                       &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们将所有信息都保存到<code>findState</code> 类中去了。再回头看我们原先那个方法,到第三步了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        - 1. 我认为就是准备一个查找结果得存储对象</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line"></span><br><span class="line">        - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass </span><br><span class="line">        同时赋值给clazz变量中,以下代码能够看出</span><br><span class="line">//      void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line"> //      this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">//&#125;</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line"></span><br><span class="line">        while (findState.clazz != null) &#123;进入循环中</span><br><span class="line">          //获取subscriberInfo 信息，返回null</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                  - 3. 进入到这里了，上面已经分析所有信息保存到findState中</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            - 4. 查找父类中的方法</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个<code>getMethodsAndRelease(findState)</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">        - 1. 取出里面的subscriberMethods</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">        findState.recycle();</span><br><span class="line">        synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">            for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = findState;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      - 2. 返回集合</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们知道了根据订阅者（<code>subscriber</code>）的<code>clazz</code> 找到了所有订阅的方法事件<br> <code>methods</code> </p>
<p>回到最初的第一步<code>register</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        - 2. 完成</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            - 3.循环遍历所有的订阅方法和订阅者之间建立关联</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>subscribe(subscriber, subscriberMethod)</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// Must be called in synchronized block</span><br><span class="line">    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        - 1. 订阅方法的eventType的字节码</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">        - 2. 订阅者和订阅方法封装成一个Subscription 对象</span><br><span class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line"></span><br><span class="line">        - 3. subscriptionsByEventType 第一次也是null ,根据eventType</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"></span><br><span class="line">        - 4. 第一次肯定为null</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            - 5. key 为 eventType, value 是subscriptions对象</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          - 抛出异常</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      - 6. 获取所有添加的subscriptions</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">          - 7. 会判断每个订阅方法的优先级，添加到这个 subscriptions中，按照优先级</span><br><span class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">      - 8.获取订阅的方法集合</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents == null) &#123;</span><br><span class="line">            subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">          - 9. 为空添加到 typesBySubscriber</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        - 10. 订阅事件添加到subscribedEvents集合中去</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">        - 11. 判断是否是粘性事件的关联</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，如果你跟着我一步步看到这里，应该大概明白一些了，还有一部分没完，就是<code>register</code> 前半部分完成订阅，存储等工作；剩下<code>post(event)</code> 方法就是将<code>event</code> 分发给相应订阅过此事件的订阅者了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[AsyncTask源码解读]]></title>
      <url>/2018/09/19/AsyncTask%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>屡思路</p>
<h1 id="1-初始-AsyncTask"><a href="#1-初始-AsyncTask" class="headerlink" title="1. 初始 AsyncTask"></a>1. 初始 AsyncTask</h1><p><code>AsyncTask</code> 这个类的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>是一个抽象类<br><code>Params</code> 表示输入参数的类型<br><code>Progress</code> 表示后台任务的执行进度<br><code>Result</code> 表示返回结果的类型</p>
<h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><blockquote>
<p>在 <code>AsyncTask</code> 这个类的顶部有一些代码注释，里面讲述了如何使用一个 <code>AsyncTask</code>,如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;Here is an example of subclassing:&lt;/p&gt;</span><br><span class="line"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span><br><span class="line"> * private class DownloadFilesTask extends AsyncTask&amp;lt;URL, Integer, Long&amp;gt; &#123;</span><br><span class="line"> *     protected Long doInBackground(URL... urls) &#123;</span><br><span class="line"> *         int count = urls.length;</span><br><span class="line"> *         long totalSize = 0;</span><br><span class="line"> *         for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line"> *             totalSize += Downloader.downloadFile(urls[i]);</span><br><span class="line"> *             publishProgress((int) ((i / (float) count) * 100));</span><br><span class="line"> *             // Escape early if cancel() is called</span><br><span class="line"> *             if (isCancelled()) break;</span><br><span class="line"> *         &#125;</span><br><span class="line"> *         return totalSize;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     protected void onProgressUpdate(Integer... progress) &#123;</span><br><span class="line"> *         setProgressPercent(progress[0]);</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     protected void onPostExecute(Long result) &#123;</span><br><span class="line"> *         showDialog(&quot;Downloaded &quot; + result + &quot; bytes&quot;);</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">//user</span><br><span class="line">&lt;p&gt;Once created, a task is executed very simply:&lt;/p&gt;</span><br><span class="line"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span><br><span class="line"> * new DownloadFilesTask().execute(url1, url2, url3);</span><br><span class="line"> * &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="3-内部重要方法"><a href="#3-内部重要方法" class="headerlink" title="3. 内部重要方法"></a>3. 内部重要方法</h1><ul>
<li><code>onPreExecute()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">  protected void onPreExecute() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在主线程中运行，异步任务之前会被调用，一般用于做一些准备工作；</p>
<ul>
<li><code>doInBackground()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line"> protected abstract Result doInBackground(Params... params);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在线程池中运行，此方法一般用于执行异步任务，通过<code>publishProgress</code> 方法来更新进度；</p>
<ul>
<li><code>onProgressUpdate()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">    protected void onProgressUpdate(Progress... values) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主线程中运行，当通过<code>publishProgress</code> 方法调用后，<code>onProgressUpdate()</code> 方法会被调用；</p>
<ul>
<li><code>onPostExecute()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">    protected void onPostExecute(Result result) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主线程中运行，将返回的结果展示。</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h1><p>从它的 <code>execute</code> 方法开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line">    public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">      //sDefaultExecutor 定义如下，线程池</span><br><span class="line">        return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">    public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">            Params... params) &#123;</span><br><span class="line">      //首先判断是不是 PENDING</span><br><span class="line">        if (mStatus != Status.PENDING) &#123;</span><br><span class="line">            switch (mStatus) &#123;</span><br><span class="line">                case RUNNING:</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                            + &quot; the task is already running.&quot;);</span><br><span class="line">                case FINISHED:</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                            + &quot; the task has already been executed &quot;</span><br><span class="line">                            + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      //将状态设置为 RUNNING 状态</span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line">      //1.调用了 onPreExecute() 方法</span><br><span class="line">        onPreExecute();</span><br><span class="line">      //将参数封装到 mWorker.mParams 中去了</span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        //调用execute 将mFuture 传进去了</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了弄明白整体流程，首页要搞明白上面的 <code>mWorker</code>  <code>mFuture</code> 是干嘛的。</p>
<ul>
<li><code>mWorker</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> private final WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line">//抽象类 并且实现了Callable 接口</span><br><span class="line">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</span><br><span class="line">        Params[] mParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    private static class AsyncTaskResult&lt;Data&gt; &#123;</span><br><span class="line">        final AsyncTask mTask;</span><br><span class="line">        final Data[] mData;</span><br><span class="line"></span><br><span class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">            mData = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//在AsyncTask 的构造方法中，分别对 mWorker, mFuture 进行了初始化</span><br><span class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : new Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">          //实现 了 call 方法</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">              //设置调用了为 true</span><br><span class="line">                mTaskInvoked.set(true);</span><br><span class="line">              //</span><br><span class="line">                Result result = null;</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                 //设置线程的优先级</span><br><span class="line">   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    //noinspection unchecked</span><br><span class="line">                    //将 2. doInBackground的结果存储到 result 中</span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; catch (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(true);</span><br><span class="line">                    throw tr;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  //最后执行postResult</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">              //返回结果</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>postResult(result)</code> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">               new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">       message.sendToTarget();</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>发送一条 <code>MESSAGE_POST_RESULT</code> 的消息，并且将<code>result</code> 存入到了 <code>AsyncTaskResult</code>中的 <code>mData</code> 中去了，<br>其中 <code>AsyncTaskResult</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    private static class AsyncTaskResult&lt;Data&gt; &#123;</span><br><span class="line">        final AsyncTask mTask;</span><br><span class="line">        final Data[] mData;</span><br><span class="line"></span><br><span class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">            mData = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getHandler</code> 获取一个 <code>Handler</code> ,我们看下 <code>handleMessage</code> 的<code>MESSAGE_POST_RESULT</code> 对这条消息的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">       public InternalHandler(Looper looper) &#123;</span><br><span class="line">           super(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">               case MESSAGE_POST_RESULT:</span><br><span class="line">                 //是他是他 就是他</span><br><span class="line">                   // There is only one result</span><br><span class="line">                   result.mTask.finish(result.mData[0]);</span><br><span class="line">                   break;</span><br><span class="line">               case MESSAGE_POST_PROGRESS:</span><br><span class="line">                   result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>result</code> 是 <code>AsyncTaskResult</code> 类型，前面我们见到过的，<code>mTask</code> 当时我们传的是 <code>this</code> 也就是当前的 <code>AsyncTask</code> ,调用<code>finish</code> 方法，将<code>mData</code> 返回的结果传入进去，还记得我们前面看过的吗，将返回的结果存入<code>AsyncTaskResult.mData</code>中去了。</p>
<p>下面看下 <code>finish</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">      //判断是否取消，如果取消了，就不执行onPostExecute 了</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //4. 就执行onPostExecute 方法了</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">      // 将状态标志为 finish</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ok ，上述都是 <code>mWorker</code> 工作的，接下来是我们一开始说的 <code>mFuture</code></p>
<ul>
<li><code>mFuture</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private final FutureTask&lt;Result&gt; mFuture;</span><br><span class="line"></span><br><span class="line">//初始化也是在AsyncTask 构造方法中执行的，在mWorker 之下，并且将mWorder 传入</span><br><span class="line">mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>postResultIfNotInvoked(get());</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void postResultIfNotInvoked(Result result) &#123;</span><br><span class="line">        final boolean wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">      //wasTaskInvoked 为true ,之前在 mWorker 中设置了为true</span><br><span class="line">//mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">//            public Result call() throws Exception &#123;</span><br><span class="line"> //               mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">        if (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>FutureTask</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">我们知道mWorker implement Callable 接口，传入赋值给了callable 变量</span><br><span class="line"> public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">        if (callable == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.callable = callable;</span><br><span class="line">        this.state = NEW;       // ensure visibility of callable</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">        if (state != NEW ||</span><br><span class="line">            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">          //callable 变量又赋值给了 c</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                boolean ran;</span><br><span class="line">                try &#123;</span><br><span class="line">                  //这里调用c.call 实际上就是调用 mWorker.call 方法</span><br><span class="line">//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = true;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    result = null;</span><br><span class="line">                    ran = false;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                if (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // runner must be non-null until state is settled to</span><br><span class="line">            // prevent concurrent calls to run()</span><br><span class="line">            runner = null;</span><br><span class="line">            // state must be re-read after nulling runner to prevent</span><br><span class="line">            // leaked interrupts</span><br><span class="line">            int s = state;</span><br><span class="line">            if (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ok ，这是 <code>mFuture</code>,还剩下最后一个：</p>
<p><code>exec.execute(mFuture);</code></p>
<p><code>exec</code> 就是 <code>sDefaultExecutor</code>  ,其实 就是 <code>SerialExecutor</code>,如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br></pre></td></tr></table></figure></p>
<p><code>SerialExecutor</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">       final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">       Runnable mActive;</span><br><span class="line"></span><br><span class="line">       public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">           mTasks.offer(new Runnable() &#123;</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       r.run();</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       scheduleNext();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">         //第一次肯定为null ，执行 scheduleNext</span><br><span class="line">           if (mActive == null) &#123;</span><br><span class="line">               scheduleNext();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected synchronized void scheduleNext() &#123;</span><br><span class="line">         //给 mActivie 赋值，mTasks.poll 会从第一个开始取</span><br><span class="line">           if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">               THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们将 <code>mFuture</code> 传入，实际就是 <code>r</code>.<br><code>mTask</code> 是 <code>ArrayDeque&lt;Runnable&gt;</code> 姑且认为它是这个排队序列的吧。看下<code>offer</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">      插入一个 element 在队尾</span><br><span class="line">     * Inserts the specified element at the end of this deque.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is equivalent to &#123;@link #offerLast&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param e the element to add</span><br><span class="line">     * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)</span><br><span class="line">     * @throws NullPointerException if the specified element is null</span><br><span class="line">     */</span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        return offerLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>看注释，也就是说是每次执行一个任务，都是在当前 <code>deque</code> 的队尾开始排队的。并且执行是串行的，因为当第二个线程过来的时候，判断 <code>mActive</code> 不为 <code>null</code> 将不会执行 <code>scheduleNext</code>.(我这个是8.0)源码，其实在 <code>android 3.0</code> 之后 <code>AsyncTask</code> 都是采用串行执行任务的。</p>
<p>各个版本的不同如下：<br><code>android 1.6</code>之前 ——  串行<br><code>android 1.6-3.0</code> 之间 —– 并行<br><code>android 3.0</code> 之后 —– 串行</p>
<p>尽管如此，我们仍然可以通过 调用 <code>executeOnExecutor</code> 来并行执行任务。</p>
<p>ok ， 回到那个 <code>execute</code> 方法中，我们说调用了 <code>r.run</code> 实际山就是 调用 <code>mFuture.run</code> 方法：<br>上面我们展示过在 <code>mFuture.run</code> 方法中如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">                  //这里调用c.call 实际上就是调用 mWorker.call 方法</span><br><span class="line">//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = true;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    result = null;</span><br><span class="line">                    ran = false;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用<code>mWorker.call</code>  方法，而在 <code>mWorker.call</code> 方法中，我们完成一系列的任务，调用了 <code>doInBackground</code> <code>onPostExecute</code> 完成了整个的调用过程。</p>
<p>有的人可能已经注意到了 还差一个 <code>onProgressUpdate</code> 方法还没被调用，我们知道只有调用那个 <code>publishProgress</code> 方法的时候才能调用 <code>onProgressUpdate</code> ,那下面我们卡夏 <code>publishProgress</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">    protected final void publishProgress(Progress... values) &#123;</span><br><span class="line">        //如果没取消</span><br><span class="line">        if (!isCancelled()) &#123;</span><br><span class="line">    //会发送一个 MESSAGE_POST_PROGRESS 的消息            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">        public InternalHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case MESSAGE_POST_RESULT:</span><br><span class="line">                    // There is only one result</span><br><span class="line">                    result.mTask.finish(result.mData[0]);</span><br><span class="line">                    break;</span><br><span class="line">                case MESSAGE_POST_PROGRESS://是他是他 就是他</span><br><span class="line">                    //3. 调用了 onProgressUpdate 方法了</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>会调用 <code>AsyncTask</code> 的 <code>onProgressUpdate</code> 方法了。结束。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p><code>AsyncTask</code> 实现原理就内部维护了2个线程池+Handlder，2个线程池分别为：任务队列 线程池（SerialExecutor）,执行 线程池（Thread_pool_executor）真正执行具体的线程任务，任务完成最后通过 <code>InternalHandler</code> 发送消息 ，将执行任务的结果<code>post</code> 到主线程中。此线程池中执行任务的顺序，根据不同 <code>api</code> 版本的不同顺序略有不同，在<code>android 1.6</code>之前，是串行执行任务，在 <code>Android 1.6-3.0</code> 之间通过并行执行任务，<code>Android 3.0</code>之后就是默认串行执行任务了，当然我们也可以通过调用<code>executeOnExecuteor</code> 并行执行。</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Service 启动过程]]></title>
      <url>/2018/09/11/Service%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>看完 <code>Activity</code> 的启动过程，发现 <code>Service</code> 的启动过程相对来说就比较简单了。</p>
</blockquote>
<p>要说起启动过程，就得从 <code>startService</code> 开始：</p>
<h1 id="1-startService"><a href="#1-startService" class="headerlink" title="1.startService"></a>1.startService</h1><p>根据源码的跳转，发现跳转到 <code>ContextWrapper</code> 这个类中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        return mBase.startService(service);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>mBase</code> 是类型是：<code>Context</code> 类型，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而我们又知道 <code>Context</code> 是一个抽象类 ，实现者是 <code>ContextImpl</code> ,所以我们应该是查看<code>ContextImpl</code> 这个类中的 <code>startService(service)</code> 方法。</p>
<p><code>ContextImpl</code> 中的方法定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        return startServiceCommon(service, false, mUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>startService</code> 中又调用了 <code>startServiceCommon(service,(requirForeground:false),mUser)</code> 这个方法，继续跟进：</p>
<h1 id="2-startServiceCommon"><a href="#2-startServiceCommon" class="headerlink" title="2.startServiceCommon"></a>2.startServiceCommon</h1><p><code>startServiceCommon</code> 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private ComponentName startServiceCommon(Intent service, boolean requireForeground,</span><br><span class="line">            UserHandle user) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //校验要启动的service</span><br><span class="line">            validateServiceIntent(service);</span><br><span class="line">            service.prepareToLeaveProcess(this);</span><br><span class="line">            ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                            getContentResolver()), requireForeground,</span><br><span class="line">                            getOpPackageName(), user.getIdentifier());</span><br><span class="line">            if (cn != null) &#123;</span><br><span class="line">                if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                    throw new SecurityException(</span><br><span class="line">                            &quot;Not allowed to start service &quot; + service</span><br><span class="line">                            + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">                &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                    throw new SecurityException(</span><br><span class="line">                            &quot;Unable to start service &quot; + service</span><br><span class="line">                            + &quot;: &quot; + cn.getClassName());</span><br><span class="line">                &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123;</span><br><span class="line">                    throw new IllegalStateException(</span><br><span class="line">                            &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return cn;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面有几个需要说明一下：</p>
<ul>
<li><code>ActivityManager.getService()</code>  点进去查看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    public static IActivityManager getService() &#123;</span><br><span class="line">        return IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected IActivityManager create() &#123;</span><br><span class="line">                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    return am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先是返回的类型是 <code>IActivityManager</code> 类型，其中在<code>create</code> 方法中，拿到远程服务的<code>Binder</code> 对象，其中<code>IActivityManager.Stub.asInterface(b)</code> 不知道大家有没有想起<code>AIDL</code> 这就很熟悉了，就是拿到远程服务的代理对象：<code>IActivityManager</code>,通过代理对象调用远程的方法，是应用进程与服务进程通信的媒介，如果没猜错的话就是在<code>ActivityManagerService</code> 中实现了，查看<code>ActivityManagerService</code> 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityManagerService extends IActivityManager.Stub</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>果然不出所料，<code>AMS extend  IActivityManager.Stub</code>  .</p>
<ul>
<li><code>mMainThread.getApplicationThread()</code> 首先明白 <code>mMainThread</code> 是 <code>ActivityThread</code> 类的实例变量，通过<code>getApplicationThread()</code> 方法拿到一个 <code>ApplicationThread</code> 类的实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ApplicationThread getApplicationThread()</span><br><span class="line">    &#123;</span><br><span class="line">        return mAppThread;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>而<code>ApplicationThread</code> 类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现 <code>ApplicationThread</code> 是 <code>ActivityThread</code> 的一个内部类.并且实现了 <code>IApplicationThread.Stub</code> ,而我们又把这个类型传入给了<code>AMS</code>,相当于远程服务拿到了一个访问应用进程的代理，类型为：<code>IApplicationThread</code></p>
<blockquote>
<p>总结：到目前为止，客户端拿到了远程服务的代理<code>（IActivityManager）</code>, 服务端拿到了客户端的代理<code>（IApplicationThread）</code>,它们互相拿到各自进程的代理类，是它们进行进程间通信的基础。</p>
</blockquote>
<p>ok ,我们回到最初那个地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                            getContentResolver()), requireForeground,</span><br><span class="line">                            getOpPackageName(), user.getIdentifier());</span><br></pre></td></tr></table></figure></p>
<p>通过前面的分析我们知道：<code>ActivityManager.getService().</code> 实际就是 <code>AMS</code> 远程代理，最终在<code>AMS</code> 中完成，我们去 <code>AMS</code> 代码中查看下 <code>startService</code> 代码：</p>
<h1 id="3-ActivityManagerService-startService"><a href="#3-ActivityManagerService-startService" class="headerlink" title="3.ActivityManagerService.  startService"></a>3.ActivityManagerService.  startService</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">            String resolvedType, boolean requireForeground, String callingPackage, int userId)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">        // Refuse possible leaked file descriptors</span><br><span class="line">        if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (callingPackage == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground);</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            final int callingPid = Binder.getCallingPid();</span><br><span class="line">            final int callingUid = Binder.getCallingUid();</span><br><span class="line">            final long origId = Binder.clearCallingIdentity();</span><br><span class="line">            ComponentName res;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 又调用了startServiceLocked 方法</span><br><span class="line">                res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                        resolvedType, callingPid, callingUid,</span><br><span class="line">                        requireForeground, callingPackage, userId);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>startServiceLocked</code> 方法很复杂，大概如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">            int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">ServiceRecord r = res.record;//启动service的信息保存在 serviceRecord 中</span><br><span class="line">....</span><br><span class="line">   ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">        return cmp;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部又调用了：<code>startServiceInnerLocked</code> 方法</p>
<h1 id="4-startServiceInnerLocked"><a href="#4-startServiceInnerLocked" class="headerlink" title="4.startServiceInnerLocked"></a>4.startServiceInnerLocked</h1><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">            boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">...</span><br><span class="line">  String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又调用： <code>bringUpServiceLocked</code></p>
<h1 id="5-bringUpServiceLocked"><a href="#5-bringUpServiceLocked" class="headerlink" title="5.bringUpServiceLocked"></a>5.bringUpServiceLocked</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">            boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">realStartServiceLocked(r, app, execInFg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后又调用了 <code>realStartServiceLocked(r, app, execInFg);</code> </p>
<h1 id="6-realStartServiceLocked"><a href="#6-realStartServiceLocked" class="headerlink" title="6.realStartServiceLocked"></a>6.realStartServiceLocked</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">      ....</span><br><span class="line">          app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.repProcState);</span><br><span class="line">      ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>app.thread</code>  是 <code>IApplicationThread</code> 类型，就是远程调用客户端进程里的方法，<code>scheduleCreateService</code> ,而我们又知道 <code>ApplicationThread</code> 实现了 <code>IApplicationThread</code>，所以就查看 <code>ApplicationThread</code> 类中的 <code>scheduleCreateService</code>方法，前面我们说过<code>ApplicationThread</code> 是 <code>ActivityThread</code> 的一个内部类，查看：</p>
<h1 id="7-ApplicationThread-scheduleCreateService"><a href="#7-ApplicationThread-scheduleCreateService" class="headerlink" title="7.ApplicationThread.scheduleCreateService"></a>7.ApplicationThread.scheduleCreateService</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">                ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">            updateProcessState(processState, false);</span><br><span class="line">            CreateServiceData s = new CreateServiceData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.info = info;</span><br><span class="line">            s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">            sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>发现内部通过发送一个 <code>CREATE_SERVICE</code> 的消息，<code>H</code> 是 <code>Handle</code>,继续查看：<br><code>handleMessage</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case CREATE_SERVICE:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">                    handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>到 <code>handleCreateService</code> 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">        // If we are getting ready to gc after going to the background, well</span><br><span class="line">        // we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                data.info.applicationInfo, data.compatInfo);</span><br><span class="line">        Service service = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">            service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line">          //创建context</span><br><span class="line">            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">            context.setOuterContext(service);</span><br><span class="line">          //创建Application</span><br><span class="line">            Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">  //通过attach 方法，将context application ，service 连接起来</span><br><span class="line">            service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                    ActivityManager.getService());</span><br><span class="line">          //调用service oncreate方法</span><br><span class="line">            service.onCreate();</span><br><span class="line">            mServices.put(data.token, service);</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>service.onCreate();</code> ok ，调用了 <code>onCreate</code> 方法，至此，<code>service</code>的启动过程的就完成了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[TransitionDrawable]]></title>
      <url>/2018/08/16/TransitionDrawable/</url>
      <content type="html"><![CDATA[<ul>
<li>1.首先创建一个<code>xml</code> 在 <code>drawable</code> 目录下</li>
</ul>
<p><code>transition_image</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;transition xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/first"</span> /&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/two"</span> /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.在xml中引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:drawable=<span class="string">"@drawable/transition_image"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.在<code>Activity</code>中使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImageView mImageView = (ImageView) findViewById(R.id.iv); </span><br><span class="line">TransitionDrawable transitionDrawable = (TransitionDrawable) mImageView.getDrawable(); </span><br><span class="line">transitionDrawable.startTransition(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<h1 id="另外一种写法实现多张图片效果"><a href="#另外一种写法实现多张图片效果" class="headerlink" title="另外一种写法实现多张图片效果"></a>另外一种写法实现多张图片效果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransitionDrawable transitionDrawable = <span class="keyword">new</span> TransitionDrawable(<span class="keyword">new</span> Drawable[]&#123;getResources().getDrawable(R.drawable.first),getResources().getDrawable(R.drawable.two)&#125;);</span><br><span class="line">mImageView.setImageDrawable(transitionDrawable);</span><br><span class="line">transitionDrawable.startTransition(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 两个Drawable之间淡入淡出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序的爬坑之路]]></title>
      <url>/2018/07/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>近期由于项目需要，需要编写小程序，遇到一些问题，记录下来，也是给自己开发的一个总结。</p>
</blockquote>
<h1 id="1-关于模板-template"><a href="#1-关于模板-template" class="headerlink" title="1.关于模板 template"></a>1.关于模板 template</h1><p>在看完 <a href="&quot;https://developers.weixin.qq.com/miniprogram/dev/index.html&quot;">官方文档</a> 里的说明之后，我并没有成功使用，按照它那个设置完成后，一直说找不到，最后在知道，原来除了实例那些之外，还要在当前 <code>wxml</code> 中 <code>import</code> 进来。</p>
<ul>
<li>1.先建一个 <code>template</code> 的文件夹，新建 <code>wxml</code>,根据具体的路径引入进来，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import src=&quot;../template/line.wxml&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还有一个就是如果有相对应的 <code>wxss</code>文件，可在 <code>app.wxss</code>文件中引用，这样整个项目都不需要引用这个样式文件了。</p>
<p><strong>注意：模板拥有自己的作用域，只能使用 data 传入的数据以及模版定义文件中定义的 <wxs> 模块。</wxs></strong></p>
<h1 id="2-关于水平居中，垂直居中"><a href="#2-关于水平居中，垂直居中" class="headerlink" title="2. 关于水平居中，垂直居中"></a>2. 关于水平居中，垂直居中</h1><p>一开始感觉这啥玩意，不听话啊，让居中也不居中，就是不动啊，很是郁闷，后来发现了一些规律。</p>
<p><strong>2.1 水平居中</strong></p>
<ul>
<li>首先如果是行内元素，例如 <text> 这样的，如果想水平居中，使用<code>text-align:center</code> 你会发现不好使啊，纹丝不动，原因是因为行内元素长度随内容变化，所以它不能让你在一行的中间，因为它的长度就是文字长度。</text></li>
</ul>
<p><strong>解决方案：</strong>可以换成<code>view</code> 控件，或者使用：<code>display:block</code> + <code>text-align:center</code></p>
<ul>
<li>其它元素可以使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">======3个一起使用==========</span><br><span class="line">text-align:center;</span><br><span class="line">align-items:center;</span><br><span class="line">justify-content: center;</span><br><span class="line">==================</span><br><span class="line">margin:auto # 子容器在父容器中居中,单独使用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2.2 垂直居中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//可使用如下</span><br><span class="line">display:flex;</span><br><span class="line">align-items:center;</span><br><span class="line">justify-content:center;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-关于几个控件平分整个屏幕宽度问题"><a href="#3-关于几个控件平分整个屏幕宽度问题" class="headerlink" title="3.关于几个控件平分整个屏幕宽度问题"></a>3.关于几个控件平分整个屏幕宽度问题</h1><blockquote>
<p>一开始我还想着获取屏幕的宽和高，然后再动态给控件设置具体的值，后来发现有更简单的做法</p>
</blockquote>
<p>例如：像这样一行排四个<br><img src="https://upload-images.jianshu.io/upload_images/1948557-35b5b4254918c3fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>解决方案：</strong>设置控件的宽度为 ：25%，这样就自动平分啦。当然还有其它的方式，但是我认为百分比的这种写法感觉很直观。</p>
<h1 id="4-flex-布局"><a href="#4-flex-布局" class="headerlink" title="4. flex 布局"></a>4. flex 布局</h1><p>熟练掌握 <code>flexbox</code> 布局，可以更轻松的编写任何常见的布局，可以查看相关专业的文章。</p>
<p>未完待续…..</p>
]]></content>
      
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin-可观察属性]]></title>
      <url>/2018/06/27/Kotlin-%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>类似于观察者模式，当所监测的对象发生改变时，能够收到回调通知。</p>
</blockquote>
<p>例如：我们监测一个变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str: String by Delegates.observable(<span class="string">"qianqian"</span>,&#123;</span><br><span class="line">        property: KProperty&lt;*&gt;, oldValue: String, newValue: String -&gt;</span><br><span class="line">        Log.i(<span class="string">"xx"</span>,<span class="string">"改变的属性名称：$&#123;property.name&#125; --- $&#123;oldValue&#125; -- $&#123;newValue&#125;"</span> )</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//点击一个按钮，改变str的值</span></span><br><span class="line">     <span class="function">fun <span class="title">foo</span><span class="params">(view : View)</span></span>&#123;</span><br><span class="line">        str = <span class="string">"haha"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们会发现，当改变<code>str</code> 的值的时候，会打印信息，也就是收到回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改变的属性名称：str --- qianqian -- haha</span><br></pre></td></tr></table></figure></p>
<p>再比如：检测对象里的其中一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    var name: String by Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">        prop, old, <span class="keyword">new</span> -&gt;</span><br><span class="line">        println(<span class="string">"$old -&gt; $new"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    val user = User()</span><br><span class="line">    user.name = <span class="string">"first"</span></span><br><span class="line">    user.name = <span class="string">"second"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;no name&gt; -&gt; first</span><br><span class="line">first -&gt; second</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin let with run also apply区分]]></title>
      <url>/2018/04/28/Kotlin-let-with-run-also-apply%E5%8C%BA%E5%88%86/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1948557-701b869e22eff1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>它与其它特殊之处在于，它返回本省对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;().apply &#123;</span><br><span class="line">            add(<span class="string">"qq"</span>)</span><br><span class="line">            add(<span class="string">"mi"</span>)</span><br><span class="line">        &#125;.let &#123;<span class="comment">//this-&gt;ArrayList本身</span></span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"list==="</span>+it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list===[qq, mi]</span><br></pre></td></tr></table></figure>
<p>这里<code>T</code> 就是 <code>ArrayList&lt;String&gt;()</code> 返回对象本身，也就是<code>ArrayList</code></p>
<ul>
<li><p>内部是 <code>this</code> 还是 <code>it</code> 这个倒没什么，编辑器一般都会有提示，如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-f6a5a83174af7964.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1540798437731.png"></p>
</li>
</ul>
<p><code>apply</code> 是 <code>this</code> , <code>also</code> 是 <code>it</code> </p>
<h1 id="run"><a href="#run" class="headerlink" title="run"></a>run</h1><ul>
<li><p><code>run</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; R): R &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>返回最后一行，传入<code>block</code> 返回 最后一行，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;().run &#123;</span><br><span class="line">            add(<span class="string">"lala"</span>)</span><br><span class="line">            add(<span class="string">"kaka"</span>)</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;.let &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"返回：："</span>+it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回：：kaka</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也是返回最后一行，但是它内部不能调用对象的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">letGo</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="string">"qianqian"</span>.let &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,it)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>letGO</code> 返回 <code>1</code> </p>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><p>类似于：<code>apply</code> + <code>let</code> 的结合</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(ArrayList&lt;String&gt;())&#123;</span><br><span class="line">            add(<span class="string">"haha"</span>)</span><br><span class="line">            add(<span class="string">"heihei"</span>)</span><br><span class="line">            <span class="keyword">this</span><span class="comment">//最后返回ArrayList对象</span></span><br><span class="line">        &#125;.let &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"list==="</span>+it)<span class="comment">//打印：[haha,heihei]</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> let </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取手机屏幕的密度]]></title>
      <url>/2018/04/24/%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AF%86%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>目前有两种方式，一种是根据手机的分辨率计算，另外一种是通过代码获取。</p>
<h1 id="第一种：根据手机分辨率进行计算-计算得出实际的dpi"><a href="#第一种：根据手机分辨率进行计算-计算得出实际的dpi" class="headerlink" title="第一种：根据手机分辨率进行计算(计算得出实际的dpi)"></a>第一种：根据手机分辨率进行计算(计算得出实际的dpi)</h1><p>比如我的手机魅族分辨率是：1920*1080，屏幕尺寸大小是：5.5寸的，那么计算：<br>(宽的平方+高的平方之后开根号，最后除以屏幕的尺寸)<br>dpi  = (√1920^2+1080^2 ) / 5.5 ≈ 401</p>
<p>参照下图：</p>
<pre><code>ldpi（低）~120dpi density=0.75
mdpi（中）~160dpi density=1
hdpi（高）~240dpi density=1.5
xhdpi（超高）~320dpi density=2
xxhdpi（超超高）~480dpi density=3
xxxhdpi（超超超高）~640dpi density=4
</code></pre><p>对应图片的目录应该是：xxhdpi</p>
<h1 id="第二种：通过代码方式-系统定义的dpi"><a href="#第二种：通过代码方式-系统定义的dpi" class="headerlink" title="第二种：通过代码方式(系统定义的dpi)"></a>第二种：通过代码方式(系统定义的dpi)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line"><span class="keyword">float</span> ydpi = getResources().getDisplayMetrics().ydpi;</span><br></pre></td></tr></table></figure>
<p>不同手机获取的<code>xdpi ydpi</code> 值有的一模一样，有的有些差异，但是相差不会太大，两者获取的值近乎一样。</p>
<p>两者计算出的结果并不完全相同，因为你们想，实际计算得出的<code>dpi</code> 很容易根据屏幕尺寸的不同，得出不同的<code>dpi</code> ，这样的话得到的值很多，无法适配。我查阅网上相关介绍，就是每个手机初始有一个固定的<code>dpi</code> ，分别是上述的：120，160，240，320，480，640，安卓实际进行缩放的时候按照的是系统定义的这些，而不是实际计算得出的<code>dpi</code>,这一点需要注意。</p>
]]></content>
      
        
        <tags>
            
            <tag> dpi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EventBus 为什么订阅的方法必须是public？]]></title>
      <url>/2018/04/08/EventBus-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A2%E9%98%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在看了源码之后发现是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities </span></span><br><span class="line">            <span class="comment">//获取所有声明的方法</span></span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//获取方法的标识符</span></span><br><span class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">            <span class="comment">//方法的标识符必须是public </span></span><br><span class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">              <span class="comment">//否则抛出异常 ，说这个方法必须加上@Subscribe ,并且是public 的，不能是静态的，抽象的</span></span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就没有然后了，之前怀疑<code>private</code> 修饰的方法，反射后不能被其他类调用，后来查了相关资料，发现可以，后来去网上寻找无果，后来在我微信关注的公众号里，群主伯特说：虽然可以反射调用<code>private</code> 的方法，但是必须通过<code>setAccess</code>来修改访问权限。说是修改，实则破坏了<code>java</code>中的作用域，迫不得已不推荐这么做。<code>EventBus</code> 作为三方库，显然不会在你设置为<code>private</code> 时，好心办坏事，强制访问。</p>
<p>仅此而已，仅此而已。分享给还不知道的童鞋。</p>
]]></content>
      
        
        <tags>
            
            <tag> EventBus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity状态保存与恢复]]></title>
      <url>/2018/03/23/Activity%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      <content type="html"></content>
      
        
        <tags>
            
            <tag> Activity状态保存与恢复 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[四大组件是什么与它们的生命周期（及Fragment）]]></title>
      <url>/2018/03/22/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%8F%8AFragment%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>首先当我们一开始学习安卓的时候想必就是四大组件了以及它们的生命周期，现在就来复习回想下。</p>
</blockquote>
<p>四大组件有：<code>Activity</code>, <code>ContentProvider</code>, <code>BroadcastReceiver</code>, <code>Service</code></p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><blockquote>
<p>提供与用户交互的界面或者可以说是一个窗口</p>
</blockquote>
<p>下面我是从官方文档中关于<code>Activity生命周期</code> 的一张图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-eea2764dbf62c03a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lifetcycle.jpg"></p>
<p>正常启动时：<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code>    </p>
<ul>
<li><p>而后我们看到当 <code>Another activity comes into the foreground</code> 执行 <code>onPause()</code> 方法<br>当按 <code>home</code> 键的时候： 当前<code>Activity</code> 已经不可见了，所以执行：<code>onPause() -&gt; onStop()</code>    </p>
</li>
<li><p>当重新回到<code>app</code>时，分为两种情况就是：①是app还在后台，执行：<code>onRestart() -&gt; onStart() -&gt; onResume()</code>; ②是app被系统杀死了，则执行：<code>onCreate() -&gt; onStart() &gt; onResume()</code>    </p>
</li>
<li><p>当在<code>app</code> 里 从 <code>A -&gt; B</code> 此时<code>A隐藏，B显示</code>，当重新返回<code>A</code> 时，执行：<code>onPause() -&gt; onResume()</code>,这种应用场景一般是比如需要返回做刷新操作的，可以将刷新方法写在<code>onResume()</code> 方法中执行。</p>
</li>
<li><p>最后当退出应用程序的时候执行 <code>onDestroy()</code></p>
</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><blockquote>
<p>服务，有前台服务和后台服务，一般提供需在后台长期运行的服务，例如：音乐播放器等</p>
</blockquote>
<p>它的生命周期如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-cf5c1a9d2dddaaca.png" alt="lifetcycle.jpg"></p>
<p>因为启动服务的方法有两个：<code>startService() 和 bindService()</code> 两者的生命周期略有不同。    </p>
<ul>
<li><p>首先来看：<code>startService()</code> 方式<br>启动：<code>onCreate() -&gt; onStartCommand()</code> 调用<code>stopServcie()</code> 停止服务，随后执行 <code>onDestroy()</code>    </p>
</li>
<li><p>其次是：<code>bindService()</code> 方式<br>启动：<code>onCreate() -&gt; onBind()</code> 服务启动起来了，调用<code>unbindService()</code> 停止服务，随后执行 <code>onUnbind() -&gt; onDestroy()</code></p>
</li>
</ul>
<h1 id="Broadcastreceiver"><a href="#Broadcastreceiver" class="headerlink" title="Broadcastreceiver"></a>Broadcastreceiver</h1><blockquote>
<p>广播，可以接受来自应用内或者应用外的广播，分为两个角色：广播发送者，广播接收者</p>
</blockquote>
<ul>
<li>广播的注册方式有两种：一种是代码注册，一种是清单文件注册，代码注册的优先级要比清单文件注册的优先级要高；</li>
<li>广播的发送可以是有序广播也可以是无序广播，有序广播接收到广播的顺序按照优先级的顺序；</li>
<li>注意广播接收器<code>onReceive()</code> 方法运行在 <code>UI</code> 线程中，不可以做耗时操作，否则会导致<code>ANR</code>异常；</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><blockquote>
<p>内容提供者，应用内数据共享</p>
</blockquote>
<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><blockquote>
<p>一般和 <code>viewpager</code> 配合使用，不能单独使用，要配合<code>Activity</code>使用，但是有自己的生命周期</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160420203710750" alt="fragment"></p>
<p>一般在<code>onAttach()</code>中获取参数值一些，<code>onCreateView()</code>中创建布局，布局加载完成后在<code>onActivityCreated()</code>中执行一些初始化操作，随后<code>onStart(),onResume().onPause(),onStop(),</code> fragment 销毁，<code>onDestroyView() -&gt; onDestroy() -&gt;onDetach()</code></p>
]]></content>
      
        
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android知识点总结]]></title>
      <url>/2018/03/22/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>网上别人列出一些来，我把它拿过来了，需要自己一项一项复习查阅，以后有会继续添加新的，特此总结。</p>
</blockquote>
<ul>
<li><p><a href="/2018/03/22/四大组件是什么与它们的生命周期（及Fragment）">四大组件是什么与它们的生命周期（及Fragment）</a>;</p>
</li>
<li><p><a href="/2018/01/09/Activity启动模式">Acitivty的四种启动模式与特点</a>。</p>
</li>
<li><p><a href="/2018/04/24/获取手机屏幕的密度">获取手机屏幕的密度</a></p>
</li>
<li><p>Activity状态保存与恢复。</p>
</li>
<li><p>Service的生命周期，启动方法，有什么区别。</p>
</li>
<li><p>service和activity怎么进行数据交互。</p>
</li>
<li><p>怎么保证service不被杀死。</p>
</li>
<li><p>广播使用的方式和场景以及广播的几种分类。</p>
</li>
<li><p>Intent的使用方法，可以传递哪些数据类型。</p>
</li>
<li><p>ContentProvider使用方法。</p>
</li>
<li><p>ContentProvider、ContentResolver、ContentObserver 之间的关系。</p>
</li>
<li><p>Thread、AsycTask、IntentService的使用场景与特点。</p>
</li>
<li><p>FrameLayout 、 LinearLayout 、 RelativeLayout 各自特点及绘制效率对比。</p>
</li>
<li><p>Android的数据存储形式。</p>
</li>
<li><p>Android两种序列化的区别和作用。</p>
</li>
<li><p>Sqlite的基本操作。</p>
</li>
<li><p>Android中的MVC、MVP模式。</p>
</li>
<li><p>Merge、ViewStub的作用。</p>
</li>
<li><p>动画有哪几类，各有什么特点？</p>
</li>
<li><p>Handler、Loop消息队列模型，各部分的作用。</p>
</li>
<li><p>Android的消息机制，子线程更新UI的方法和原理。</p>
</li>
<li><p>Android怎么加速启动Activity。</p>
</li>
<li><p>App的启动过程。</p>
</li>
<li><p>Android优化方法。</p>
</li>
<li><p>如何防止内存泄漏？</p>
</li>
<li><p>Android中弱引用与软引用的应用场景。</p>
</li>
<li><p>Bitmap的四种属性，如何加载大图（inJustDecodeBounds）。</p>
</li>
<li><p>View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。</p>
</li>
<li><p>View刷新机制和绘制流程。</p>
</li>
<li><p>Activity、Window、View的联系和理解。</p>
</li>
<li><p>invalidate和requestLayout的区别及使用。</p>
</li>
<li><p>Touch事件分发机制和冲突处理。</p>
</li>
<li><p>Android IPC:Binder原理。</p>
</li>
<li><p>Android5.0（UI库）、6.0（权限）、7.0特性、8.0特性。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android知识点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin 传递数据]]></title>
      <url>/2018/03/14/Kotlin-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天在掘金看到使用 <code>Kotlin</code> 高阶函数传递<code>Intent</code> 数据很简洁，觉着可以试试，并应用到项目中去，自己再加以理解，记录笔记，方便查阅。掘金原文章地址：<a href="https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw</a></p>
</blockquote>
<p>传统的<code>Intent</code> 数据传递我就不介绍了，只介绍<code>Kotlin</code>实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标 假设叫`KTestActivity4`  定义   </span></span><br><span class="line">object IntentOptions&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> val MSG_KEY = <span class="string">"key for message"</span></span><br><span class="line"></span><br><span class="line">        var Intent.message: String?</span><br><span class="line">            get() = getStringExtra(MSG_KEY)</span><br><span class="line">            set(message) &#123;</span><br><span class="line">                putExtra(MSG_KEY,message)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//跳转时 </span></span><br><span class="line">with(KTestActivity4.IntentOptions)&#123;</span><br><span class="line">            intent = Intent(<span class="keyword">this</span><span class="meta">@KTestActivity</span>5,KTestActivity4::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">            <span class="title">intent</span>.<span class="title">message</span> </span>= <span class="string">"I am KTestActivity5"</span></span><br><span class="line">             startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">with(IntentOptions)&#123;</span><br><span class="line">            var message= intent.message</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="meta">@KTestActivity</span>4,<span class="string">"显示信息："</span>+message,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设有多个数据传递：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">object IntentOptions&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> val MSG_KEY = <span class="string">"key for message"</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> val MSG_ID = <span class="string">"ID for message"</span></span><br><span class="line"></span><br><span class="line">        var Intent.message: String?</span><br><span class="line">            get() = getStringExtra(MSG_KEY)</span><br><span class="line">            set(message) &#123;</span><br><span class="line">                putExtra(MSG_KEY,message)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 再多增加一条即可</span></span><br><span class="line">          var Intent.id: String?</span><br><span class="line">              get() = getStringExtra(MSG_ID)</span><br><span class="line">              set(id) &#123;</span><br><span class="line">                putExtra(MSG_ID,id)</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 传递时</span></span><br><span class="line">with(KTestActivity4.IntentOptions)&#123;</span><br><span class="line">            intent = Intent(<span class="keyword">this</span><span class="meta">@KTestActivity</span>5,KTestActivity4::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">            <span class="title">intent</span>.<span class="title">message</span> </span>= <span class="string">"I am KTestActivity5"</span></span><br><span class="line">             intent.id = <span class="string">"I am id"</span></span><br><span class="line">             startActivity(intent)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>还有另外一种传递方式：委托机制，不是特别明白。国外大神封装的<code>github</code>地址：<a href="https://github.com/Takhion/android-extras-delegates">https://github.com/Takhion/android-extras-delegates</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Kotlin#Intent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里巴巴Android开发手册]]></title>
      <url>/2018/03/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Android%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<blockquote>
<p>摘自阿里巴巴Android开发手册</p>
</blockquote>
<h1 id="强制要求的"><a href="#强制要求的" class="headerlink" title="强制要求的"></a>强制要求的</h1><ul>
<li><strong>1.</strong> Activity 间的数据通信，对于数据量比较大的，避免使用 <code>intent + Parcelable</code> 的方式，可以考虑 <code>EventBus</code>等替代方案，以免造成 <code>TransationTooLargeException</code></li>
<li><strong>2.</strong> <code>Activity</code> 间通过隐士 <code>Intent</code>的跳转，在发出 <code>Intent</code> 之前必须通过 <code>resolveActivity</code> 检查，避免找不到合适的调用组件，造成 <code>ActivityNotFoundException</code> 的异常。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">viewUrl</span><span class="params">(String url, String mimeType)</span> </span>&#123;</span><br><span class="line"> Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">	intent.setDataAndType(Uri.parse(url), mimeType);</span><br><span class="line">	<span class="keyword">if</span> (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_</span><br><span class="line">ONLY) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> startActivity(intent);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 找不到指定的 Activity</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>而不应该：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.example.DemoIntent "</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> startActivity(intent);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>3.</strong> 避免在<code>Service#onStartCommand/onBind()</code>方法中执行耗时操作，如果确实有需求，应采用<code>IntentService</code> 或采用其他异步机制完成。<br>正例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"> setContentView(R.layout.main);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startIntentService</span><span class="params">(View source)</span> </span>&#123;</span><br><span class="line"> Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService.class);</span><br><span class="line"> startService(intent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">......</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>4.</strong> 避免在 <code>BroadcastReceive#onReceive()</code>中执行耗时操作，如果有耗时工作，应该创建 <code>IntentService</code>完成，而不应该在<code>BroadcastReceiver</code> 内创建子线程去做。    </p>
</li>
</ul>
<p>说明：<br>由于该方法是在主线程执行，如果执行耗时操作会导致 <code>UI</code> 不流畅，可以使用 <code>IntentService</code>,创建 <code>HanlderThread</code> 或者调用 <code>Context#registerReceiver(BroadcastReceiver,IntentFitter,String,Handler)</code> 方法等方式，在其他 <code>Worker</code> 线程执行 <code>onReceive</code>.<code>BroadcastReceiver#onReceive()</code> 方法耗时超过10秒钟，可能会被系统杀死。<br>正例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(LOGIN_SUCCESS);</span><br><span class="line"><span class="keyword">this</span>.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"> Intent userHomeIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"> userHomeIntent.setClass(<span class="keyword">this</span>, UserHomeService.class);</span><br><span class="line"> <span class="keyword">this</span>.startService(userHomeIntent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mBroadcastReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"> MyDatabaseHelper myDB = <span class="keyword">new</span> MyDatabaseHelper(context);</span><br><span class="line"> myDB.initData();</span><br><span class="line"> <span class="comment">// have more database operation here</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>5.</strong> 避免使用隐士 <code>Intent</code> 广播敏感信息，信息可能被其他注册了对应 <code>BroadcastReceiver</code> 的App接收。</li>
</ul>
<p>说明：<br>通过<code>Context#sendBroadcast()</code>发送的隐士广播会被感兴趣的 <code>receiver</code> 接收，恶意应用注册监听该广播的 <code>receiver</code>可能会获取到 <code>Intent</code> 中传递的敏感信息，并进行其他危险操作。如果发送的广播为使用 <code>Context#sendOrderedBroadcast()</code>方法发送的有序广播，优先级较高的恶意 <code>receiver</code>可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。</p>
<p>如果广播仅限于应用内，则可以是iyong<code>LocalBroadcastManager#sendBroadcast()</code>实现，避免敏感信息外泄和intent拦截的风险。</p>
<p>正例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"my-sensitive-event"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"event"</span>, <span class="string">"this is a test event"</span>);</span><br><span class="line">LocalBroadcastManager.getInstance(<span class="keyword">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>
<p>反例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">v1.setAction(<span class="string">"com.sample.action.server_running"</span>);</span><br><span class="line">v1.putExtra(<span class="string">"local_ip"</span>, v0.h);</span><br><span class="line">v1.putExtra(<span class="string">"port"</span>, v0.i);</span><br><span class="line">v1.putExtra(<span class="string">"code"</span>, v0.g);</span><br><span class="line">v1.putExtra(<span class="string">"connected"</span>, v0.s);</span><br><span class="line">v1.putExtra(<span class="string">"pwd_predefined"</span>, v0.r);</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(v0.t)) &#123;</span><br><span class="line"> v1.putExtra(<span class="string">"connected_usr"</span>, v0.t);</span><br><span class="line">&#125;</span><br><span class="line">context.sendBroadcast(v1);</span><br></pre></td></tr></table></figure></p>
<p>以上广播可能被其他应用的如下 <code>receiver</code> 接收导致敏感信息泄露：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.getAction() != <span class="keyword">null</span>) &#123;</span><br><span class="line"> String s = intent.getAction();</span><br><span class="line"> <span class="keyword">if</span> (s.equals(<span class="string">"com.sample.action.server_running"</span>) &#123;</span><br><span class="line"> String ip = intent.getStringExtra(<span class="string">"local_ip"</span>);</span><br><span class="line"> String pwd = intent.getStringExtra(<span class="string">"code"</span>);</span><br><span class="line"> String port = intent.getIntExtra(<span class="string">"port"</span>, <span class="number">8888</span>);</span><br><span class="line"> <span class="keyword">boolean</span> status = intent.getBooleanExtra(<span class="string">"connected"</span>, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 阿里巴巴Android开发手册规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[监听键盘显示与隐藏]]></title>
      <url>/2018/03/08/%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>项目中有时候需要监听<code>keyboard</code>的显示与隐藏，特此备注，方便使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyboardWatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener;</span><br><span class="line">    <span class="keyword">private</span> View rootView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> viewSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShowing = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> OnKeyboardListener onKeyboardListener;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyboardWatcher</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        rootView = activity.getWindow().getDecorView().getRootView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyboardWatcher <span class="title">register</span><span class="params">(OnKeyboardListener listener)</span></span>&#123;</span><br><span class="line">        onKeyboardListener = listener;</span><br><span class="line">        <span class="keyword">if</span>(onGlobalLayoutListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            onGlobalLayoutListener = <span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Rect r = <span class="keyword">new</span> Rect();</span><br><span class="line">                    rootView.getWindowVisibleDisplayFrame(r);</span><br><span class="line">                    <span class="keyword">int</span> viewHeight = r.bottom - r.top;</span><br><span class="line">                    <span class="keyword">if</span>(viewSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        viewSize = viewHeight;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(viewHeight != viewSize)&#123;</span><br><span class="line">                        <span class="comment">// 大于100dp才算变化</span></span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(viewHeight - viewSize) &gt; dpToPx(rootView.getContext(),<span class="number">100</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (viewHeight &lt; viewSize &amp;&amp; !isShowing) &#123;</span><br><span class="line">                                onKeyboardListener.onShow(viewHeight);</span><br><span class="line">                                isShowing = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isShowing)&#123;</span><br><span class="line">                                onKeyboardListener.onHide();</span><br><span class="line">                                isShowing = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        viewSize = viewHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rootView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                viewSize = rootView.getHeight();</span><br><span class="line">                rootView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rootView.getViewTreeObserver().removeGlobalOnLayoutListener(onGlobalLayoutListener);</span><br><span class="line">        rootView = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnKeyboardListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onShow</span><span class="params">(<span class="keyword">int</span> viewSize)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onHide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dpToPx</span><span class="params">(Context context,<span class="keyword">int</span> dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) TypedValue.applyDimension(</span><br><span class="line">                TypedValue.COMPLEX_UNIT_DIP, dp, context.getResources().getDisplayMetrics()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KeyBoardWatcher keyboardWatcher = <span class="keyword">new</span>  KeyboardWatcher()</span><br><span class="line">keyboardWatcher.register(<span class="keyword">this</span>)<span class="comment">//实现KeyboardWatcher.OnKeyboardListener接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法onShow() , onHide(),对应键盘的显示与隐藏</span></span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> keyboard </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment 懒加载]]></title>
      <url>/2018/02/28/Fragment-%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<blockquote>
<p>因为项目中经常用到tabLayout + viewpager 结合使用，页面切换时要用到延迟加载的情况，所以单独写出一个demo，方便查看和便于使用</p>
</blockquote>
<h1 id="1-首先新建一个BaseLazyFragment"><a href="#1-首先新建一个BaseLazyFragment" class="headerlink" title="1.首先新建一个BaseLazyFragment"></a>1.首先新建一个<code>BaseLazyFragment</code></h1><pre><code>/**
 * Created by xuqianqian on 2018/2/28.
 */
public  abstract class BaseLazyFragment extends Fragment {

    protected View mRootView;
    public Context mContext;
    protected boolean isVisible;
    private boolean isPrepared;
    private boolean isLoad = false;

    //最先执行
    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
        if (getUserVisibleHint()) {//当前显示
            isVisible = true;
            if(!isLoad){
                lazyLoad();
            }
        } else {
            isVisible = false;
            //onInvisible();
        }
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mContext = getActivity();
        setHasOptionsMenu(true);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        if (mRootView == null) {
            mRootView = getLayout();
        }
        return mRootView;
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        isPrepared = true;
        //如果已经加载过了，就无需再重新加载
        if(!isLoad){
            lazyLoad();
        }
    }

    /**
     * 懒加载
     */
    protected void lazyLoad() {
        if (!isPrepared || !isVisible) {
            return;
        }
        isLoad = true;
        initData();
    }

//    protected void onInvisible() {
//
//    }
    //初始化布局View
    public abstract View getLayout();

    public abstract void initData();
}
</code></pre><h1 id="2-让你的fragment-extend-BaseLazyFragment"><a href="#2-让你的fragment-extend-BaseLazyFragment" class="headerlink" title="2.让你的fragment extend BaseLazyFragment"></a>2.让你的<code>fragment extend BaseLazyFragment</code></h1><pre><code>public class GankFragment extends BaseLazyFragment {

String type;
public static GankFragment newInstance(String type) {
    GankFragment gankFragment = new GankFragment();
    Bundle bundle = new Bundle();
    bundle.putString(&quot;type&quot;, type);
    gankFragment.setArguments(bundle);
    return gankFragment;
}
//加载布局
@Override
public View getLayout() {

    type = getArguments().getString(&quot;type&quot;);
    TextView tv = new TextView(getActivity());
    tv.setText(type);
    tv.setGravity(Gravity.CENTER);
    return tv;
}

@Override
public void initData() {

    //初始化一些控件，加载网络数据
}

}
</code></pre><h1 id="3-剩下的就是FragmentPagerAdapter了"><a href="#3-剩下的就是FragmentPagerAdapter了" class="headerlink" title="3.剩下的就是FragmentPagerAdapter了"></a>3.剩下的就是FragmentPagerAdapter了</h1><pre><code>public class TitleAdapter extends FragmentPagerAdapter {

private List&lt;Fragment&gt; fragments;

private List&lt;String&gt; types;

public TitleAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments, List&lt;String&gt; types) {
    super(fm);
    this.fragments = fragments;
    this.types = types;
}

@Override
public Fragment getItem(int position) {
    return fragments.get(position);
}

@Override
public int getCount() {
    return fragments.size();
}

@Override
public CharSequence getPageTitle(int position) {
    return types.get(position);
}
}
</code></pre><p><code>MainActivity.java</code></p>
<pre><code>private List&lt;String&gt; titles = new ArrayList&lt;&gt;();

private List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;();
TitleAdapter titleAdapter;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    TabLayout tablayout = findViewById(R.id.tablayout);
    ViewPager viewpager = findViewById(R.id.viewpager);

    titles.add(&quot;android&quot;);
    titles.add(&quot;ios&quot;);
    titles.add(&quot;web&quot;);
    titles.add(&quot;java&quot;);

    fragments.add(GankFragment.newInstance(&quot;android&quot;));
    fragments.add(GankFragment.newInstance(&quot;ios&quot;));
    fragments.add(GankFragment.newInstance(&quot;web&quot;));
    fragments.add(GankFragment.newInstance(&quot;java&quot;));

    titleAdapter = new TitleAdapter(getSupportFragmentManager(), fragments, titles);
    viewpager.setAdapter(titleAdapter);
    tablayout.setTabMode(TabLayout.MODE_FIXED);
    tablayout.setupWithViewPager(viewpager);
}
</code></pre><p><a href="https://github.com/QQabby/LazyFragmentApplication" title="源码地址">https://github.com/QQabby/LazyFragmentApplication</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 懒加载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dialog]]></title>
      <url>/2018/02/28/Dialog/</url>
      <content type="html"><![CDATA[<h1 id="快速初始化materialDialog"><a href="#快速初始化materialDialog" class="headerlink" title="快速初始化materialDialog"></a>快速初始化materialDialog</h1><pre><code>new MaterialDialog.Builder(mContext)
                    .title(&quot;title&quot;)
                    .content(&quot;I&apos;m a content&quot;)
                    .negativeText(&quot;cancel&quot;)
                    .negativeColorRes(R.color.colorNegative)
                    .positiveText(&quot;ok&quot;)
                    .positiveColorRes(R.color.colorPositive)
                    .onPositive(new     MaterialDialog.SingleButtonCallback() {
                            @Override
                            public void onClick(@NonNull MaterialDialog     dialog, @NonNull DialogAction which) {
                            showMsg(&quot;click dialog ok&quot;);
                            ...
                    }
                })
                .show();
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> materialDialog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序速查笔记]]></title>
      <url>/2018/01/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这个微信小程序也出来好长时间了，一直想做一个属于自己的小程序，这不说动手就动手实现一个吧，比较简易，中间也遇到不少问题，记录一下，方便以后自己查阅。</p>
</blockquote>
<h1 id="微信小程序的结构"><a href="#微信小程序的结构" class="headerlink" title="微信小程序的结构"></a>微信小程序的结构</h1><p><img src="http://upload-images.jianshu.io/upload_images/1948557-4007311aabb448cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<p>默认没有这么些文件夹的，只有<code>index</code> ，然后这个标识 <code>app</code> 开头的文件都是一些全局的设置。可以自己查看下，都有注释，就从这个配置开始说。</p>
<h1 id="修改启动页面"><a href="#修改启动页面" class="headerlink" title="修改启动页面"></a>修改启动页面</h1><p>默认启动页面是<code>index</code>页面，如果要修改，打开<code>app.json</code>配置文件，在顶部你会发现有一个<code>pages</code>的配置，如下：</p>
<pre><code>&quot;pages&quot;: [

&quot;pages/home/home&quot;
</code></pre><p>只需要将我们的想要显示的页面的路径写在 <strong>第一个</strong> 就可以成为启动页，特别注意路径一定要正确。</p>
<p>当然你会新建很多页面，所有的页面都必须写在这个里面，不然跳转的时候会找不到。</p>
<h1 id="底部tab栏切换"><a href="#底部tab栏切换" class="headerlink" title="底部tab栏切换"></a>底部tab栏切换</h1><p>就是底部<code>tab</code>栏切换,同样还是在<code>app.json</code> 配置文件中修改如下：</p>
<pre><code>  &quot;tabBar&quot;: {
  &quot;color&quot;: &quot;#333333&quot;,
  &quot;selectedColor&quot;: &quot;#2B91D8&quot;,
  &quot;backgroundColor&quot;: &quot;#eee&quot;,
  &quot;borderStyle&quot;: &quot;white&quot;,
      &quot;list&quot;: [
    {
  &quot;pagePath&quot;: &quot;pages/home/home&quot;,
  &quot;text&quot;: &quot;首页&quot;,
  &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_home_nor.png&quot;,
  &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_home_pre.png&quot;
    },
    {
  &quot;pagePath&quot;: &quot;pages/myCenter/myCenter&quot;,
  &quot;text&quot;: &quot;我的&quot;,
  &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_center_nor.png&quot;,
  &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_center_pre.png&quot;
    }
  ]
},
</code></pre><p>这里的 <code>pagePath</code> 就是页面的路径，<code>text</code>文字，<code>iconPath</code>图标，注意图片一定要带后缀，<code>selectedIconPath</code>点击态的图标，各自换成你自己的就行，问题不会太大。</p>
<h1 id="加载中"><a href="#加载中" class="headerlink" title="加载中"></a>加载中</h1><p>如下：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-8f82d095641d4734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<p>有标签可以直接显示这个,在<code>wxml</code>文件中编写：</p>
<pre><code>&lt;loading hidden=&quot;{{hidden}}&quot; bindchange=&quot;loadingChange&quot;&gt;  
       加载中...  
&lt;/loading&gt;  
</code></pre><p>   <code></code> 可以控制显示还是隐藏，在<code>.js</code>文件中可以控制：</p>
<pre><code>data: {
    hidden: false,
  }
</code></pre><p> 可以在<code>data</code> 底下配置默认值，<code>hidden: false</code> 默认不显示，赋值的时候必须在这里面写：</p>
<pre><code>that.setData({
    hidden: true
  })
</code></pre><h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><pre><code> wx.request({
//网络请求地址url
url: &apos;https://xx&apos;,
header: {
  // &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;
  &apos;content-type&apos;: &apos;application/json&apos;
  // &apos;content-type&apos;: &apos;text/xml&apos;
},
//请求头参数配置
data: {
  page: pageNo,
  timestamp: timeStamps

},
method: &quot;POST&quot;,

success: function (res) {

  //xmlstring2json  是我使用第三方xml转json的一个库
  var xml2json = require(&apos;..//lib/xmlstring2json/dist/xml2json&apos;);
  var json = JSON.stringify(xml2json(res.data), null, 4);


  var jsonObject = xml2json(res.data);
  var jokeObject = jsonObject.root.joke
  //timestamp
  if(pageNo == 0){
    timeStamps = jsonObject.root.timestamp.text
  }


 // console.log(&apos;json::&apos; + jsonObject.root.timestamp.text)
  // var data = new Array();
  // for (var i = 0; i &lt; jokeObject.length;i++){
  //   var text = JSON.stringify(jokeObject[i].text).replace(&quot;#&quot;, &quot;&quot;)
  //   //JSON.parse(text).text
  //   var value = JSON.parse(text).text;
  //   data.push(value)
  // }
  // console.log(&apos;data::：&apos; + jokeObject[0].text.text );

  // var l =  jokeObject;
  var l;
  if(pageNo == 0){
    l = jokeObject

  }else{
    var l = that.data.list;
    for (var i = 0; i &lt; jokeObject.length; i++) {
      l.push(jokeObject[i])
    } 
  }
    //页面绑定的数据赋值
  that.setData({
    list: l
  })

  pageNo++

  that.setData({
    hidden: true
  })
},
fail : function(s){
  wx.showModal({
    title: &apos;提示&apos;,
    content: &apos;请求接口失败&apos; + JSON.stringify(s)
  })
}
</code></pre><p>要进行网络请求，首先测试阶段可以将开发工具里的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948557-8bed851f43caa7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后一个选项勾选上，不校验…,同时管理员还需在后台配置网络请求的域名，两个缺一不可。</p>
]]></content>
      
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何给TextView上的drawable上的图片添加动画？]]></title>
      <url>/2018/01/24/%E5%A6%82%E4%BD%95%E7%BB%99TextView%E4%B8%8A%E7%9A%84drawableEnd%E7%AD%89%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>可能你遇到过这样的场景，就是在 <code>xml</code> 里，给<code>TextView</code>添加了一个<code>drawableLeft</code>或者<code>drawableRight</code>等，你想给这个图片添加一个动画，然而你会发现当你给这个<code>TextView</code>加动画吧并不是我们想要的，我们只想要那个图片做动画，文字不需要做任何动画，目前可以有两种做法。</p>
<h1 id="第一种做法"><a href="#第一种做法" class="headerlink" title="第一种做法"></a>第一种做法</h1><blockquote>
<p>也是比较通俗的方法，说这个<code>drawable 单独弄成ImageView</code>不就好了，在<code>xml</code>里新增一个<code>ImageView</code> 是吧，干嘛非要加在一个标签里面，要相信布局都是很强大的，肯定可以实现效果。</p>
</blockquote>
<h1 id="第二种做法"><a href="#第二种做法" class="headerlink" title="第二种做法"></a>第二种做法</h1><blockquote>
<p>你说真的没办法，必须写在一个里面，也是有办法的，那就不能在<code>xml</code>里设置<code>drawableLeft</code>了，代码设置，如下：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable d = (AnimationDrawable) getResources().getDrawable(R.drawable.animation_draw);  </span><br><span class="line">d.setBounds(0,0,d.getIntrinsicWidth(),d.getIntrinsicHeight());</span><br><span class="line"> messageText.setCompoundDrawables(d, null, null, null);</span><br></pre></td></tr></table></figure>
<p>这个具体的动画在这个<code>animation_draw</code>里，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">                android:oneshot=&quot;false&quot;</span><br><span class="line">       &gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/ic_launcher&quot;</span><br><span class="line">           android:duration=&quot;500&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个帧动画，里面可以放很多的<code>item</code>,从而形成动画,碰到了这种情况记录下，方便以后查阅。</p>
]]></content>
      
        
        <tags>
            
            <tag> add animation to drawable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android O 新特性 AutoSizing]]></title>
      <url>/2018/01/16/Android-O-%E6%96%B0%E7%89%B9%E6%80%A7-AutoSizing/</url>
      <content type="html"><![CDATA[<h1 id="自动调整TextView的大小的使用autoSizing"><a href="#自动调整TextView的大小的使用autoSizing" class="headerlink" title="自动调整TextView的大小的使用autoSizing"></a>自动调整TextView的大小的使用autoSizing</h1><blockquote>
<p>Android 8.0允许根据TextView的大小自动设置文本展开或收缩的大小,这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。</p>
</blockquote>
<p>在之前看 <a href="https://juejin.im/post/5a56f70cf265da3e5468fa59" target="_blank" rel="noopener">文字太多？控件太小？试试 TextView 的新特性 Autosizing 吧！</a> 作者写到关于这个属性的所有用法，在这里我就不多说什么了，用法其实挺简单，关键是我在用的时候遇到了一些小问题，导致一直出不来。</p>
<p><a href="https://developer.android.com/guide/topics/ui/look-and-feel/autosizing-textview.html" target="_blank" rel="noopener">官方文档</a> 点击即可查看，可以看别人讲解的同时也可自行查阅文档，双方对比着看，感觉会好一点。</p>
<p>如下图可以简单明了的说明该特性：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fe2fd1fa4e936?w=469&amp;h=713&amp;f=gif&amp;s=764107" alt=""></p>
<p>具体最简单的使用有两种：</p>
<h1 id="1-一种就是api-gt-api-26的可以直接在xml里面该属性："><a href="#1-一种就是api-gt-api-26的可以直接在xml里面该属性：" class="headerlink" title="1.一种就是api &gt;= api 26的可以直接在xml里面该属性："></a>1.一种就是api &gt;= api 26的可以直接在xml里面该属性：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:autoSizeTextType=&quot;uniform&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此需要注意的是：使用这个<code>autoSizeTextType</code>的时候，控件的<code>layout_width</code> <code>layout_height</code> 不能使用这个<code>wrap_content</code>否则看不出什么效果，要使用具体可衡量的。这个也不难理解，因为它要计算，你设置一个模糊的宽和高，就算不出来了。</p>
</blockquote>
<h1 id="2-api-lt-26-的低设备-的兼容写法"><a href="#2-api-lt-26-的低设备-的兼容写法" class="headerlink" title="2. api&lt;26 的低设备 的兼容写法"></a>2. api&lt;26 的低设备 的兼容写法</h1><blockquote>
<p>官方文档里也明确说明了兼容低版本<code>The library provides support to Android 4.0 (API level 14) and higher.</code> 也就是兼容到4.0以上，写法有些不同，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;TextView</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;200dp&quot;</span><br><span class="line">      tools:ignore=&quot;MissingPrefix&quot;</span><br><span class="line">      app:autoSizeTextType=&quot;uniform&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这个<code>app</code>是这个<code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code> 我们在自定义控件的时候经常遇到它，<code>tools</code>是这个<code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code> 当然以上写法都支持动态编码，具体可查阅文档</p>
<h1 id="敲黑板重点"><a href="#敲黑板重点" class="headerlink" title="敲黑板重点"></a>敲黑板重点</h1><p>你会发现你写完之后编译是报错的，错误类似是这样的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fe486f97e25be?w=888&amp;h=158&amp;f=png&amp;s=18247" alt=""></p>
<p>找不到！！！</p>
<p>在写那篇文章作者的帮助下，发现首先要兼容低版本，<code>module</code> 的 <code>build.gradle</code> 文件添加依赖时候 就是这个<code>com.android.support:appcompat-v7:xx</code> 后面的版本号要26以上，你看看你自己项目里有哪个版本你就写上哪个，还要在<code>project</code> 的 <code>build.gradle</code> 文件里添加：<br><code>maven{
            url &#39;https://maven.google.com&#39;
        }</code>添加到对应的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        //添加如下内容</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &apos;https://maven.google.com&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此我发现我的项目终于不报错了，可以运行起来并进行下一步的实践操作了，大家如果在项目中也遇到这样的问题，按我那样改应该没啥问题了，顺便把我写的代码上传到<code>github</code> 上了，又需要的可以下载看看：<br><a href="&quot;https://github.com/QQabby/AutoSizingDemo&quot;">demo</a></p>
<p>另外在查看 <code>Android O</code>新特性中发现一个比较好玩的东西：现在，<code>findViewById()</code> 函数的全部实例均返回 <t extends="" view=""> T，而不是 View。以后就可以这么写啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EditText et =  findViewById(R.id.et);</span><br></pre></td></tr></table></figure></t></p>
<p>就是那样，无需强转了，当然了使用了<code>Kotlin</code>的话就忽略吧，因为<code>Kotlin</code>连<code>findViewById</code>也不用写，哈哈。更多好玩特性可查看 <a href="https://developer.android.com/about/versions/oreo/android-8.0.html#fvbi-signature" target="_blank" rel="noopener">文档</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Android O </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修改自动生成get/set方法模板代码]]></title>
      <url>/2018/01/11/%E4%BF%AE%E6%94%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get-set%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今天看到<br><a href="https://juejin.im/post/5a55c8896fb9a01caf374e93" target="_blank">面对接口脏数据你还在V层if str==null else setText?</a><br> 一文，觉着写得挺好，开发过程中多思考多动手，会带来意想不到的效果。底下评论大家也都说了各自的方法和见解，文中有一些问题作者后来也解决了，看到评论里有人说：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b35580365?w=658&amp;h=389&amp;f=png&amp;s=25367" alt="image.png"></p>
<p>说到配置as,就可以实现在创建bean时自动生成<code>return xx==null?&quot;&quot;:xx;</code> 觉着很好，因为我觉着这是一种挺简单的方法，但是就如同底下人问了怎么配置呀，我也不知道，于是我就在自己<code>as</code>工具里新建了一个bean对象，按住<code>alt+insert</code>添加<code>get/set</code>方法，发现了解决办法。如下图：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b3568a2be?w=389&amp;h=636&amp;f=png&amp;s=16071" alt="image.png"></p>
<p>平时手快也没注意，今天仔细看了看，那上面的意思不就是，<code>get</code> 方法模块，<code>set</code>方法模板吗，后面跟着 <code>IntelliJ Default</code>大概就是默认的生成模板吧，点击后面的三个点<br>按钮进去看看，如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b531389d1?w=787&amp;h=609&amp;f=png&amp;s=47221" alt="image.png"></p>
<p>这是<code>set</code>的，<code>get</code>方法也类似是这样的，大概也能看懂，想着是不是可以直接模板就好了，发现无法修改，后来又发现左上角的<code>+</code>号，原来是自己可以新建一个模板，然后再生成的时候选择自己的模板就好了，如我们在<code>get</code>模板中新建一个自己的模板：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b3c7e8344?w=431&amp;h=149&amp;f=png&amp;s=7606" alt="image.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b357e2825?w=262&amp;h=269&amp;f=png&amp;s=4331" alt="image.png"></p>
<p>我们知道我们只需要改一下最后<code>get</code>方法<code>return</code>那个地方的代码，也就是这儿：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b38fb2a31?w=1240&amp;h=679&amp;f=png&amp;s=129573" alt="image.png"></p>
<p>不确定是不是，我们可以在后面跟着一个“#”号试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">  return $field.name+&quot;#&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在生成的时候选择我们自定义的模板：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b56ef9685?w=394&amp;h=643&amp;f=png&amp;s=17595" alt="image.png"></p>
<p>发现最后生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getAge() &#123;</span><br><span class="line">    return age + &quot;#&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(String age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样证明确定是这样的，那么我么可以继续进行真正的判断了：<br>我们先把这个默认里的<code>get</code>方法代码拷贝到 <code>MyGetter</code>中，我们再根据我们自己的需要修改模板代码,其它地方不变，就修改需要修改的地方：<br>我们想要实现这样的：<code>return xx==null?&quot;&quot;:xx</code>,Ok ，那么我认为大概是这么写的，首先判断是否是字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">	#if(field.String)&#123;</span><br><span class="line">		return $field.name == null ? &quot;&quot; : $field.name;</span><br><span class="line">	&#125;</span><br><span class="line">	#else</span><br><span class="line">		return $field.name;</span><br><span class="line">	#end </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们对比一个<code>default</code>的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">  return $field.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，我们再继续生成一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getAge() &#123;</span><br><span class="line">        return age == null ? &quot;&quot; : age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(String age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，达成效果，耶，居然还可以这么玩，以后可根据自己需求自行修改，谢谢大家。</p>
]]></content>
      
        
        <tags>
            
            <tag> get/set.template </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity启动模式]]></title>
      <url>/2018/01/09/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>  ● standard 标准模式<br>​    简述：对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。<br>例如：A启动A，A再接着启动A,A再接着启动A,，然后再分别出栈，如图所示：<br>​<br><img src="http://upload-images.jianshu.io/upload_images/1948557-bf56470a07ad09ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>  ● singleTop<br>简述：当活动的启动模式指定为 singleTop ,在启动活动时如果发现返回栈的栈顶已经<br>是该活动，则认为可以直接使用它，不会再创建新的活动实例。<br>例如：如果快速点击一个按钮，进入Activity，要保证启动的Activity不为多个，可以使用<br>将Activity的启动模式改为 singleTop，就不会启动多个了。如图所示：<br>​<br><img src="http://upload-images.jianshu.io/upload_images/1948557-d5f43b4894e1a4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>  ● singleTask<br>简述：当活动的启动模式指定为singleTask，每次启动该活动时候，它会先在系统中查找属性值taskaffinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，他就会这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了“singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</p>
<p>如果设置了“singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。</p>
<p>每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948557-9133171e9085b6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">                             </p>
<blockquote>
<p>当栈底部的 <code>A</code> 重新被启动打开时，会执行<code>onNewIntent()</code>  <code>onStart()</code> 方法。</p>
</blockquote>
<p>使用场景：应用主页面一般是 <code>singleTask</code> </p>
<p>  ● singleInstance（单独任务栈）<br>简述：使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都会共用同一个返回栈，也就解决了共享活动实例的问题。<br>​<br><img src="http://upload-images.jianshu.io/upload_images/1948557-358424952cd1bed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>返回的页面顺序是：C-B-A</p>
]]></content>
      
        
        <tags>
            
            <tag> launchMode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AIDL实例]]></title>
      <url>/2018/01/08/AIDL%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>说到进程间通信，一般首先就会想到<code>AIDL</code>，也看了很多文章，做下笔记，记录一下，方便以后查阅。</p>
</blockquote>
<p>对于  <code>AIDL</code> 我是这样理解的，首先进程间是无法通信的，那要通信就得有一个媒介或者说两个进程有统一对外的接口可以相互识别，从这个 <code>AIDL</code>全程的名字<code>Android Interface Definition Language</code> (android 接口定义语言) 来看不难看出它就是我们进程间通信的媒介，它可以实现我们想要的通信。</p>
<p>在翻阅网上各类文章的讲解后，我认为一个比较好的实例可以更好理解这个东西，具体如下：</p>
<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>我们新创建两个<code>module</code>，代表我们两个进程，进程名称默认就是我们程序的包名：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-2622b4af0ef4f45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p>
<h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>我们先编写<code>service</code>这个<code>module</code>里的代码，先定义一个  <code>Person</code>的一个<code>bean</code>对象，记住一定要<code>implements Parcelable</code> 接口，大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-2be1461f1e8c1cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        mName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\nPerson&#123;"</span> +</span><br><span class="line">                <span class="string">"mName='"</span> + mName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们再新建一个文件夹：<code>aidl</code>,新建一个包名和<code>Person</code>类一模一样的包名和与之对应的<code>aidl</code>,还有一个我们对外提供获取<code>person</code>集合的一个<code>aidl</code>:<br><img src="http://upload-images.jianshu.io/upload_images/1948557-44cd8f26c62f570f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br> 在<code>Person.aidl</code>里，我们序列化我们<code>java</code>里的 <code>Person</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还要和声明的实体类在一个包里，同时注意不要新建aidl文件，因为你会发现，新建不了，</span></span><br><span class="line"><span class="comment">//提示你名称唯一，此时你新建一个file,名字为Person.aidl就可以，需要特别注意下</span></span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure>
<p><code>IMyAidl.aidl</code> 文件提供对外方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// IMyAidl.aidl</span><br><span class="line">package com.example.service.bean;</span><br><span class="line">//特别注意一定要手动导包，不会自动导包</span><br><span class="line">import com.example.service.bean.Person;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">//可以理解为通信媒介</span><br><span class="line">interface IMyAidl &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">         * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出)</span><br><span class="line">         */</span><br><span class="line">        void addPerson(in Person person);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; getPersonList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在我们的<code>java文件</code>里，新建一个<code>MyAidlService</code>,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAidlService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String  TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Person&gt; mPersons;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建生成本地的binder ,实现AIDL的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mIBinder = <span class="keyword">new</span> IMyAidl.Stub()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mPersons.add(person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mPersons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端与服务端绑定时的回调，返回IBinder对象后客户端就可以通过它远程调用服务端的方法，即实现了通讯</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        mPersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> mIBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后别忘了在清单文件中注册<code>MyAidlService</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">            android:name=<span class="string">"com.example.service.MyAidlService"</span></span><br><span class="line">            android:enabled=<span class="string">"true"</span></span><br><span class="line">            android:exported=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>到此，我们完成了<code>service</code>端的工作：</p>
<h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>将我们刚才创建好的<code>aidl</code>文件夹拷贝到 <code>app</code> <code>module</code>下<code>main</code>文件夹下，在<code>MainActivity</code>中绑定服务，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.service"</span>,<span class="string">"com.example.service.MyAidlService"</span>));</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure></p>
<p>其中这个<code>mConnection</code>可以让我们拿到<code>IMyAidl</code>对象的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;</span><br><span class="line"></span><br><span class="line">            mAidl = IMyAidl.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName componentName) &#123;</span><br><span class="line">            mAidl = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过返回的<code>IBinder</code> 拿到这个<code>IMyAidl</code>，此时我们就可以通信了，例如我们调用<code>IMyAidl</code>中的<code>addPerso</code>n方法，再调用<code>getPersonList</code>看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       Person person = <span class="keyword">new</span> Person(<span class="string">"qian"</span>+random.nextInt(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           mAidl.addPerson(person);</span><br><span class="line">           List&lt;Person&gt; mPersons = mAidl.getPersonList();</span><br><span class="line"></span><br><span class="line">           tvName.setText(mPersons.toString());</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>打印发现list 返回了我们添加的<code>Person</code>，完成了<code>app</code>与<code>service</code>两个进程间的通信。<br><code>demo</code>地址：<a href="https://github.com/QQabby/AIDLDemo">https://github.com/QQabby/AIDLDemo</a></p>
]]></content>
      
        
        <tags>
            
            <tag> AIDL实例 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写文件相关]]></title>
      <url>/2017/12/28/%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="向sd卡根目录中写入文件"><a href="#向sd卡根目录中写入文件" class="headerlink" title="向sd卡根目录中写入文件"></a>向sd卡根目录中写入文件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先判断是否存在sd卡</span></span><br><span class="line"><span class="keyword">if</span>(Environment.getExternalStorageState().equals(</span><br><span class="line">                Environment.MEDIA_MOUNTED))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取外部设备</span></span><br><span class="line">    File file=<span class="keyword">new</span> File(Environment.getExternalStorageDirectory(),<span class="string">"qianqian.txt"</span>);</span><br><span class="line">    FileOutputStream outStream=<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">     <span class="comment">//写入文件</span></span><br><span class="line">    outStream.write(content.getBytes());</span><br><span class="line">    outStream.close();  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="读取assets下的文件路径"><a href="#读取assets下的文件路径" class="headerlink" title="读取assets下的文件路径"></a>读取assets下的文件路径</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式如下</span></span><br><span class="line">file:<span class="comment">///android_asset/myVideo.html</span></span><br><span class="line">file:<span class="comment">///android_asset/xx(文件名称)</span></span><br></pre></td></tr></table></figure>
<h1 id="读取assets下的文件转化为String"><a href="#读取assets下的文件转化为String" class="headerlink" title="读取assets下的文件转化为String"></a>读取assets下的文件转化为String</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFromAssets</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStreamReader inputReader = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    getResources().getAssets().open(fileName));</span><br><span class="line">            BufferedReader bufReader = <span class="keyword">new</span> BufferedReader(inputReader);</span><br><span class="line">            String line = <span class="string">""</span>;</span><br><span class="line">            String Result = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufReader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">                Result += line;</span><br><span class="line">            <span class="keyword">return</span> Result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 向sd卡写入文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LRU算法还一知半解？]]></title>
      <url>/2017/12/19/lru/</url>
      <content type="html"><![CDATA[<blockquote>
<p>某年某月某日，糖葫芦同学在掘金app上看了几篇文章，偶然看到了一篇熟悉的词LRU算法，脑海里就想这不是经常说的嘛，就那么回事，当天晚上睡觉，LRU算法是啥来着，好像是什么最近最少使用的，白天在地铁上看的文章也不少，但是到晚上想想好像啥也没记住，就记得LRU算法，我发现人大多数是这样的啊，对于自己熟悉的部分呢还能记着点，不熟悉或者不会的可能真的是看过就忘啊~既然这样还不如先把熟悉的弄明白。</p>
</blockquote>
<p><strong>第二天来到公司，我觉着还是有必要看一下这个LRU的源码，到底是怎么回事，嗯，糖葫芦同学刷刷得看，下面我们将进入正题，请戴眼镜的同学把眼镜擦一擦，哈哈哈</strong></p>
<h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><p>先看源码，再用具体的demo加以验证，我们先看一下这个LruCache这个类的大致结构和方法，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-45d318e41e5b213e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这又是 get(K)，put(K,V), remove(K) 的方法的 给人的感觉就像是一个Map的集合嘛，又有Key ，又有value 的，再看下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Size of this cache in units. Not necessarily the number of elements. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> createCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> evictionCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hitCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> missCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize for caches that do not override &#123;<span class="doctag">@link</span> #sizeOf&#125;, this is</span></span><br><span class="line"><span class="comment">     *     the maximum number of entries in the cache. For all other caches,</span></span><br><span class="line"><span class="comment">     *     this is the maximum sum of the sizes of the entries in this cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到开头，我们就明白了，哦原来这个LruCache类中维护一个LinkedHashMap的一个集合，缓存我们这个对象，而且构造方法里需要我们传入一个<code>maxSize</code>的一个值，根据上面的注释我们就明白了这个就是我们LruCache缓存对象的最大数目。</p>
<h1 id="有什么用呢？"><a href="#有什么用呢？" class="headerlink" title="有什么用呢？"></a>有什么用呢？</h1><p>根据惯性思维，我们可以认为，在<code>put</code>新的缓存对象的时候，根据我们设定的最大值<code>remove</code>集合里的某些缓存对象，进而添加新的缓存对象。</p>
<h1 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h1><p>根据我们的分析，我们有必要去看一下这个<code>put</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Caches &#123;<span class="doctag">@code</span> value&#125; for &#123;<span class="doctag">@code</span> key&#125;. The value is moved to the head of</span></span><br><span class="line"><span class="comment"> * the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value mapped by &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码量也不是特别多，我们看下这个，在这个<code>synchronized</code>同步代码块里，我们看到这个 <code>size</code>,是对put进来缓存对象个数的累加，然后调用集合的<code>map.put</code>方法，返回一个对象 <code>previous</code> ，就是判断这个集合中是否添加了这个缓存对象，如果不为null,就对<code>size</code>减回去。</p>
<p>最后又调用一个 <code>trimToSize(maxSize)</code>方法，上面都是对添加一些逻辑的处理，那么不可能无限制添加啊，肯定有移除操作，那么我们推测这个逻辑可能在这个<code>trimToSize(maxSize)</code> 里处理。</p>
<p>源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove the eldest entries until the total of remaining entries is at or</span></span><br><span class="line"><span class="comment">     * below the requested size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span></span><br><span class="line"><span class="comment">     *            to evict even 0-sized elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                            + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//只要当前size&lt;= maxSize 就结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取这个对象，然后从map中移除掉，保证size&lt;=maxSize</span></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注释：<code>Remove the eldest entries until the total of remaining entries is at or below the requested size</code> 大概意思是说：清除时间最久的对象直到剩余缓存对象的大小小于设置的大小。没错是我们想找的。</p>
<p><strong>这里说明一下：maxSize就是我们在构造方法里传入的，自己设置的</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样LruCache的核心方法 <code>trimToSize</code>方法我们就说完了，接下来我将通过实例再次验证下：</p>
<h1 id="设置场景"><a href="#设置场景" class="headerlink" title="设置场景"></a>设置场景</h1><blockquote>
<p>假设我们设置maxSize 为2，布局里显示3个imageView,分别代表3张我们要显示的图片，我们添加3张图片，看看会不会显示3张？</p>
</blockquote>
<p>xml布局显示如下（代码就不贴了，很简单）：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-18f522db17aec271?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>activity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_lru);</span><br><span class="line"></span><br><span class="line">        ImageView iv1 = (ImageView) findViewById(R.id.iv1);</span><br><span class="line">        ImageView iv2 = (ImageView) findViewById(R.id.iv2);</span><br><span class="line">        ImageView iv3 = (ImageView) findViewById(R.id.iv3);</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),R.drawable.bg);</span><br><span class="line">        Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(),R.drawable.header_img);</span><br><span class="line">        Bitmap bitmap3 = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);</span><br><span class="line"></span><br><span class="line">        LruCache&lt;String,Bitmap&gt; lruCache = <span class="keyword">new</span> LruCache&lt;&gt;(MAX_SIZE);</span><br><span class="line">        lruCache.put(<span class="string">"1"</span>,bitmap1);</span><br><span class="line">        lruCache.put(<span class="string">"2"</span>,bitmap2);</span><br><span class="line">        lruCache.put(<span class="string">"3"</span>,bitmap3);</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = lruCache.get(<span class="string">"1"</span>);</span><br><span class="line">        iv1.setImageBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">        Bitmap b2 = lruCache.get(<span class="string">"2"</span>);</span><br><span class="line">        iv2.setImageBitmap(b2);</span><br><span class="line"></span><br><span class="line">        Bitmap b3 = lruCache.get(<span class="string">"3"</span>);</span><br><span class="line">        iv3.setImageBitmap(b3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-fd26e11dddac2ae8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bg.png"><img src="http://upload-images.jianshu.io/upload_images/1948557-2aa9e1e0c1e34387?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="header_img.png"><img src="http://upload-images.jianshu.io/upload_images/1948557-8d33912205bfd6e8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ic_launcher.png"></p>
<p>我们可以先尝试分析一下：因为我们设置的MaxSize 是2 ，那么在put第三个Bitmap的时候，在<code>trimToSize</code>方法中，发现这个size是3 ，maxSize 是2，会继续向下执行,不会break,结合下面代码看下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                            + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次循环：此时 size 是3，maxSize 是 2</span></span><br><span class="line">                <span class="comment">//第二次循环，此时 size 是 2 ，maxSize 是 2 ，满足条件，break,结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//获取最先添加的第一个元素</span></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">              <span class="comment">//移除掉第一个缓存对象</span></span><br><span class="line">                map.remove(key);</span><br><span class="line">              <span class="comment">// size = 2,减去移除的元素</span></span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>safeSizeOf</code> 是调用<code>sizeOf</code>方法。</p>
<p>那么也就是说，我们在<code>put</code>第三个<code>bitmap</code>的时候，<code>LruCache</code> 会自动帮我们移除掉第一个缓存对象，因为第一个最先添加进去，时间也最长，当然后添加的<code>bitmap</code>就是新的，最近的，那么我们推断这个<code>iv1</code>是显示不出图片的，因为被移除掉了，其它剩余两个可以显示，分析就到这里，看下运行结果是不是跟我们分析的一样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948557-abc32df8ceb0fda9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result.png"></p>
<p>哇！真的跟我们想的一样耶，证明我们想的是对的。这里我们思考一下就是为什么<code>LruCache</code>使用了这个<code>LinkedHashMap</code>,为什么<code>LinkedHashMap</code>的创造方法跟我们平时创建的不太一样，源码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里说一下在掘金发布的评论里 <code>藏地情人</code>评论是：<code>new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true)</code>这句代码表示，初始容量为零，<code>0.75</code>是加载因子，表示容量达到最大容量的<code>75%</code>的时候会把内存增加一半。最后这个参数至关重要。表示访问元素的排序方式，<code>true</code>表示按照访问顺序排序，<code>false</code>表示按照插入的顺序排序。这个设置为<code>true</code>的时候，如果对一个元素进行了操作<code>(put、get)</code>，就会把那个元素放到集合的最后。</p>
</blockquote>
<p>确实也是这样的，我们看下<code>LinkedHashMap</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>里面这个<code>assessOrder</code> 注释里也说的很明白：<code>the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for
access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</code> -&gt; <code>true</code> 呢就表示会排序，<code>false</code> 就代表按照插入的顺序。<br>默认不传就是 <code>false</code>  ,而且我们每次  <code>get(K) put(K,V)</code> 的时候 会根据这个变量调整元素在集合里的位置。而这么做的目的也只有一个：保留最近使用的缓存对象，举个例子说明一下：</p>
<p>   我们向这个集合里添加了三种元素</p>
<pre><code>LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE);(MAX_SIZE=2)
lruCache.put(&quot;1&quot;, bitmap1);
lruCache.put(&quot;2&quot;, bitmap2);
lruCache.put(&quot;3&quot;, bitmap3);
</code></pre><p>   此时它们在集合里的顺序是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-336a0efa4167a370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="order.png"></p>
<p>那比如说我们在<code>put</code> 3 元素之前，使用了1元素，就是调用了<code>get(&quot;1&quot;)</code>方法，我们知道LinkedHashMap就会改变链表里元素的存储顺序，代码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lruCache.put(<span class="string">"1"</span>, bitmap1);</span><br><span class="line">lruCache.put(<span class="string">"2"</span>, bitmap2);</span><br><span class="line">lruCache.get(<span class="string">"1"</span>);</span><br><span class="line">lruCache.put(<span class="string">"3"</span>, bitmap3);</span><br></pre></td></tr></table></figure></p>
<pre><code>那么此时对应链表里的顺序就是：
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1948557-dea6180979615101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p>
<p>当我们再调用显示的时候，循环遍历就会优先把第一个位置的<code>key = &quot;2&quot;</code> 的缓存对象移除掉，保证了最近使用的原则，当然了因为把这个<code>max_size = 2</code>所以在我们执行<code>lruCache.put(&quot;3&quot;, bitmap3);</code> 时，集合最终会变成这样：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-334107b8260732f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="result.png"></p>
<p>集合里只剩下 <code>1 ,3</code>对应的缓存对象。</p>
<p>至此，LruCache就说完了，如果看完的你有不明白的地方可以留言，一起讨论下~</p>
]]></content>
      
        
        <tags>
            
            <tag> Lru </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/11/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
