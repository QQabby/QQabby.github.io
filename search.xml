<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap 高并发导致的死循环]]></title>
    <url>%2F2018%2F12%2F07%2FHashMap-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j];//src 表示原table while(null != e) &#123; //此处表示取出下一个位置的Entry(键值对) Entry&lt;K&lt;V&gt; next = e.next; //计算得出在扩容后新数组table中的下标，因为扩容后要重新计算下标 //未扩容前下标:index = hash(key) &amp; (length-1) int i= indexFor(e.hash,newCapacity); //根据下标取出在新表newTable中的Entry&lt;K,V&gt; e.next = newTable[i]; //将当前e 赋值给newTable[i](Entry&lt;K,V&gt;) newTable[i] = e; //将下一个next.Entry 赋值给当前的e e = next; &#125;&#125; 举例说明下： 原 table的信息排列是： 再次添加新元素的时候就需要扩容了，此时我们来类比下上述的代码： 12345678910111213141516171819for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j];//src 表示原table while(null != e) &#123; //next = Entry2 Entry&lt;K&lt;V&gt; next = e.next; //假设计算结果为3；循环第二次：假设Entry2计算的位置也是3 int i= indexFor(e.hash,newCapacity); //第一次Entry1.next = newTable[3]，此时newTable[3]还为null；所以是Entry1.next地址指向null //循环第二次：Entry2.next = Entry1 e.next = newTable[i]; //newTable[3] = Entry1, 此时e是 Entry1; //循环第二次： newTable[3] = Entry2 newTable[i] = e; //Entry1 = Entry2,e 指向了Entry2,好再次循环; //循环第二次：e = null,跳出循环 e = next; &#125;&#125; 变成如下： 上述是属于正常情况的那种，假设我们现在有两个线程同时去 put 元素，二者均发现需要做扩容处理，那么又会出现什么情况呢？ 参考阅读网上的博客+自己理解记录 当线程一 和 线程二 同时进行插入的时候刚好达到扩容的条件，然后同时开始进行 Resize 操作。 1234567891011for (int j = 0; j &lt; src.length; ++j) &#123; //src 表示原table Entry&lt;K,V&gt; e = src[j]; while(null != e) &#123; Entry&lt;K&lt;V&gt; next = e.next;//假设线程一执行到这里就被调度挂起了 int i= indexFor(e.hash,newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125;&#125; 线程一挂起，线程二继续操作，变成如下： 线程二是 rehash 之后的样子，如上图： 当前线程一来说： e 是: key(3) next 是： key(7) 线程一来了，被调度回来了，该人家执行了： 123456789101112131415161718while(null != e) &#123;//再次循环，e:key(7) next:key(3) //假设线程一执行到这里就被调度挂起了,开始继续执行 //第二次循环：next = key(3),next 指向key(3) //e:key(3) next:null Entry&lt;K&lt;V&gt; next = e.next; int i= indexFor(e.hash,newCapacity);//根据线程二的计算不难推出线程一计算的i = 3 //key(7).next 指向 key(3) //key(3).next 指向 key(7) e.next = newTable[i]; //first : newTable[3] = key(3) //second ： newTable[3] = key(7) //third : newTable[3] = key(3) newTable[i] = e; //e 指向key(7) //e = key(3) //e = null//退出循环 e = next 这样就产生死循环了。 12key(7).next 指向 key(3)key(3).next 指向 key(7) 当我们取出一个key(5) 的一个值时，恰巧也是 int i = 3 , 这样去取，就陷入key(3),key(7) 的死循环中去了。 为了更清晰的展示每一次循环，我决定分开来展示： 第一次：要从这个线程一恢复运行开始说起吧： e: key(3) ; next: key(7) 123456789101112while(null != e) &#123; Entry&lt;K&lt;V&gt; next = e.next;//第一次的时候，线程一被卡住在这里，当时状态是：e:key(3),next:key(7) 这应该都没什么问题 //根据线程二的计算，这个值也应该是int i = 3 int i= indexFor(e.hash,newCapacity); //key(3).next = newTable[3], 此时newTable[3]为null, key(3).next指向null e.next = newTable[i]; //newTable[3] = key(3) newTable[i] = e; //e = key(7),e指向key(7) e = next&#125; OK, 由于e = key(7) 不为null ,循环继续： 第二次循环：经过上述循环，此时 e: key(7),next: key(3) 由于线程二已经改变了这个整体table 的结构，当遍历到key(7) 时， next: key(3) 123456789101112while(null != e) &#123;//e:key(7) //next = key(3) Entry&lt;K&lt;V&gt; next = e.next; //int i = 3 int i= indexFor(e.hash,newCapacity); //key(7).next = key(3) , key(7).next指向key(3) e.next = newTable[i]; //newTable[3] = key(7) newTable[i] = e; //e = key(3) e指向key(3),不为null,循环继续 e = next&#125; 第三次循环：e : key(3) next:null 123456789101112while(null != e) &#123;//e:key(3) //next = null next指向null Entry&lt;K&lt;V&gt; next = e.next; //int i = 3 int i= indexFor(e.hash,newCapacity); //key(3).next = key(7) key(3).next指向key(7) e.next = newTable[i]; //newTable[3] = key(3) newTable[i] = e; //e = null, 循环结束 e = next&#125; 此时 e : null, next:null. 12//key(7).next指向key(3)//key(3).next指向key(7) 这里产生死循环 图就是这样的：最后newTable[3] = key(3) over.]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap基本知识]]></title>
    <url>%2F2018%2F12%2F06%2FHashMap%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[自我总结 什么是 HashMap?首先看下类继承关系： HashMap 是存储键值对的集合，一个 key–value , 这样的键值对也称为 Entry ，这些键值对分散存储于数组当中，组成 HashMap 的主干。 特点 其中 key 可为 null ；非线程安全； 其中 put 方法 和 get 方法比较重要。 put 方法 12345678910111213public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); ..... &#125; 首先根据 key 计算 hash 值 , 如何算出在 Node 数组中具体的下标呢？从上面代码我们可以大概看出： 1i = (n-1) &amp; hash 就是数组的长度 -1 &amp; key 的hash 值。 得到数组下标后，再把这个键值对放入进去，完成了 put 操作。 假设我们： put(“qq”,”糖葫芦”) hash(&quot;qq&quot;) = 2, 下标为2，那么结果如下： Entry1====&gt; [key = &quot;qq&quot;, value= &quot;糖葫芦&quot;] 但是总会有那么一种情况，就是不同 key 计算的 hash 之后是相同的，假如我们新 put(&quot;mi&quot;,value=&quot;milo&quot;) index = hash(&quot;mi&quot;) = 2 也是数组下标为2，那么此时在下标为2的位置就会通过 链表 的形式存储相应的键值对。 HashMap 数组的每一个元素不止是一个Entry 对象，也是一个链表的头节点。每一个Entry对象通过 Next 指针指向它的下个 Entry 节点。当再有新的 Entry 映射到这个冲突位置时，也就是计算出 hash 值也是2，只需要插入到对应的链表当中去即可，注意：新插入的会在之前的前面，称为 头插入， 被新 put 进入的新元素可能被用到的概率大一些。 get 方法 了解了 put 方法，get 好理解些 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; 第一步：同样 根据 key 算出 hash 值； 第二步：根据 hash值和数组的长度 计算数组的下标 index 第三步：假设我们取出我们 get(&quot;qq&quot;) 对应的值，我们知道下标是2，且是一个链表，我们需要循环遍历整个链表，找到 key = &quot;qq&quot; 的Entry。 HashMap的默认长度是多少？为什么要那么定义？ HashMap 默认长度是16，也可以自定义长度必须是2幂次方。之所以选择16，是为了方便于 key 映射 index 的算法。 为了实现一个均匀的 HashMap ,数组的长度必须是 2 的幂次方，将 index = hash(key) &amp; (length-1) 这样做的效率也更高，通过位运算的方式。 举例：book 的 hashcode,结果为十进制的 3029737，二进制：1011100011101011101001；假定 HashMap 长度是默认的16， length-1 = 15,二进制： 1111； index = hash(key) &amp; (length-1) 计算结果如下图： 二进制：1001；十进制：就是index= 9。 那么假设我们自定义长度设置为：10. 那length-1=9, 二进制就是：1001，我们重新计算下index`, 如下图： 二进制为：1001 ；十进制就是： index = 9 然后我们再尝试一个新的 HashCode: 结果还是：1001； 然后我们继续来一个新的 HashCode: 结果还是：1001，index= 9. 也就是说，当 HashMap 长度为 10 的时候，多个 不同的key生成的 index 可能是相同的，相同的概率比较大，这样，显然不符合 Hash 算法均匀分布的原则。 反观长度为16或者2的幂次方，length-1 的值是所有二进制全为1，这种情况下，index 的结果等同于HashCode 的后几位值，只有输入的 HashCode 本身分布均匀，Hash 算法的结果也是均匀的。]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView更清晰地观察缓存]]></title>
    <url>%2F2018%2F11%2F28%2FRecycleView%E6%9B%B4%E6%B8%85%E6%99%B0%E5%9C%B0%E8%A7%82%E5%AF%9F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[为了更清晰的观察 recycleView 缓存复用，在看到有一篇文章是打印缓存相关信息后，觉着确实是一种办法，比打断点更合适查看缓存的变化情况，就尝试自己写了写。 这里我主要利用反射观察的是：mCachedViews 和 recycleViewPool 里面的变化情况。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public void getInfo()&#123; try&#123; Class&lt;?&gt; class1 = Class.forName("android.support.v7.widget.RecyclerView"); Field field = class1.getDeclaredField("mRecycler"); field.setAccessible(true); RecyclerView.Recycler recycler = (RecyclerView.Recycler) field.get(recyclerView); Field field1 = recycler.getClass().getDeclaredField("mCachedViews"); field1.setAccessible(true); ArrayList&lt;RecyclerView.ViewHolder&gt; mCachedViews = (ArrayList&lt;RecyclerView.ViewHolder&gt;) field1.get(recycler); for(int i=0;i&lt;mCachedViews.size();i++)&#123; Log.i("xx","mCachedViews::"+mCachedViews.get(i)); &#125; RecyclerView.RecycledViewPool viewPool = recyclerView.getRecycledViewPool(); //这里之所以能获取到 RecycledViewPool中的mScrpa，需要新建一个android.support.v7.widget包，将该类放入该包下即可访问到。 SparseArray&lt;RecyclerView.RecycledViewPool.ScrapData&gt; list = viewPool.mScrap; //这里传入的类型type 是我在adapter中定义的，如下： //@Override //public int getItemViewType(int position) &#123; //return 666; //&#125; RecyclerView.RecycledViewPool.ScrapData spra = list.get(666); Field field2 = spra.getClass().getDeclaredField("mScrapHeap"); ArrayList&lt;RecyclerView.ViewHolder&gt; mScrapHeap= (ArrayList&lt;RecyclerView.ViewHolder&gt;) field2.get(spra); for(int i=0;i&lt;mScrapHeap.size();i++)&#123; Log.i("xx","mScrapHeapInfo::"+mScrapHeap.get(i)); &#125; Log.i("xx","================================================="); &#125;catch (Exception e) &#123; Log.i("xx", "error"); e.printStackTrace(); &#125; &#125; 需要注意的是：反射获取 然后在 recycleView 滚动的时候，显示信息： 12345678910recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy);// int recycleCount = recyclerView.getRecycledViewPool().getRecycledViewCount(666);// Log.i("xx","recyclePoolCount::"+recycleCount); getInfo(); &#125; &#125;); 还有可以在 adapter 重写方法： onViewRecycled(ViewHOlder holder) 方法，可以查看最新被回收的位置ViewHolder ： 12345@Override public void onViewRecycled(ViewHolder holder) &#123; Log.i("xx","holder被回收了"+holder);//可以拿到被回收holder的相关信息 super.onViewRecycled(holder); &#125; 这样我们就可以通过日志的方式来近距离查看 recyclerView 复用回收。 我们假设这样一个场景：总共假设有20个item ,使用 GrideLayoutManager 每行显示5个，一个屏幕差不多显示两行，如下图所示： 我们在 adapter 的 onCreateViewHolder 和 onBindViewHolder 方法的地方都打印日志，并且重写 onViewRecycled 方法，查看 View 的回收情况。 当我们向下滑动，将第一行的数据滑出屏幕后，我们发现打印日志如下： 我们发现 2，3，4卡位的 ViewHolder 被回收了。这里的被回收是指添加到 RecycleViewPool 当中了。此时 mCachedViews 中的缓存信息如下： 从日志上来看，它缓存了：1，0，15，16，17，18，19共7个卡位的数据。 这里补充一下：mCachedViews 的大小在源码定义中默认是:static final int DEFAULT_CACHE_SIZE = 2;（当然也可以自己设置，通过 RecyclerView #setItemViewCacheSize，一般不设置）经过我的多次实验观察，当每行设置为5列时，mCachedViews.size == 2+ 5 = 7,当每行是4时，mCachedViews.size == 2+ 4 = 6，所以此时就是mCachedView.size 是7。 问题1：为什么mCachedViews 缓存的卡位是1，0，15，16，17，18，19？要回答这个问题，首先应该明白当我们在滑动第三行展示的时候，此时 RecyclerView 创建了第四行的 ViewHolder,即 15，16，17，18，19因为它们未曾展示到屏幕上，所以被 mCachedViews 缓存，继续滑动，第一行数据移出屏幕之外，也要回收了，0，1，2，3，4，5 这5个是将要被缓存，但是mCachedVIews 已经缓存了5个，势必只能再添加两个，两外三个卡位的 ViewHolder 将要被回收，GrideLayoutManager 默认从右往左回收： 第一次回收4，3卡位如图： 第二次回收2卡位如图： 因为此时缓存数量已到最大值7了，所以再次添加时，会移除第一个。代码如下： 12345int cachedViewSize = mCachedViews.size(); if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; 日志： 新缓存的2卡位被插入index = 1 的位置。如此，我们就可以知道当1卡位会回收时，mCachedViews 中缓存的信息应该是，先移除第0个，也就是position= 3 的 ViewHolder,插入到 index = 1 的位置，顺序应该是：2，1，15，16，17，18，19，好我们看下日志： 是的，不出我们所料，至此到最后我们就知道了，当0卡位被回收时，mCachedViews 的缓存信息就是：1，0，15，16，17，18，19. 被移除的ViewHolder 被添加到了 RecycleViewPool 当中了，从 RecycleViewPool 当中取出的 ViewHolder 类似于全新的，但是不会重新调用 onCreateViewHolder,会重新调用 onBindViewHolder 重新绑定数据。]]></content>
      <tags>
        <tag>recycleView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap 原理]]></title>
    <url>%2F2018%2F11%2F22%2FConcurrentHashMap-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景知识：我们知道 HashMap 是线程不安全的，多线程情况下，进行put 操作会引起死循环，导致CPU 利用率比较高，所以在并发情况下不能使用 HashMap ; 而 Hashtable 是线程安全的，其实就是在 put 操作的时候加了 syncronized, 但是当一个线程在进行put 操作时，其它的线程连 get 操作也不能进行，导致阻塞或者轮询状态，所以竞争越来越激烈，效率低下。 锁分段技术 Hashtable 在多并发的情况下效率低下，是因为很多线程争夺同一把锁，而假如容器内有多把锁，每一把锁用于锁容器内的一部分数据，当多线程访问容器内不同段的数据时，线程间就不会存在锁竞争，从而有效的提高并发访问效率。]]></content>
      <tags>
        <tag>concurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合随笔]]></title>
    <url>%2F2018%2F11%2F21%2F%E9%9B%86%E5%90%88%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[1. ArrayList 和 HashMap 是否线程安全？ Collection ArrayList HashMap HashSet 都是非同步的，线程是不安全的 集合中：Vector 和 HashTable 是线程安全的 Collection —-&gt; 线程安全：Collections.synchronizedCollection() ArrayList —–&gt; Collections.synchronizedList() HashMap ——&gt; Collections.synchronizedMap() HashSet ——-&gt; Collections.synchronizedSet()]]></content>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler 相关总结]]></title>
    <url>%2F2018%2F11%2F21%2FHandler-%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先一个线程中是可以创建多个 Handler 的，互不影响，默认在 ActivityThread 当中也创建了一个 Handler H ,我们还是可以在 MainActivity 中创建我们自己的 Handler, 互不影响； 一个线程 对应一个 Looper ,一个 Looper 对应一个 MessageQueue ;]]></content>
      <tags>
        <tag>handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化]]></title>
    <url>%2F2018%2F11%2F21%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化 减少布局层次，单一可以用LinearLayout 解决的页面不用 RelativeLayout,如果布局复杂，则用RelativeLayout 更好，毕竟比起布局嵌套，这种会好些 &lt;include&gt; 标签使用，主要用于布局重用 需要注意的是：此标签内，如果外面指定了 id 里面跟布局也定义id 以外部定义为准。同时如果里面定义了 类似于 android:layout_width=&quot;wrap_content&quot; 的属性，需配套 android:layout_height=&quot;wrap_content&quot; 同时使用。 &lt;merge&gt; 标签一般和 &lt;include&gt; 标签配合使用。一般如果当前根布局例如是：LinearLayout ,include 的布局也是 LinearLayout ,那么 include 的根布局就可以使用 &lt;merge&gt; 标签代替LinearLayout. &lt;ViewStub&gt; 标签，意义为按需加载，轻量级，宽和高都是0，在实际开发中，有很多布局在正常情况下不会显示，比如网络异常的布局，这个时候没有必要在布局加载时就加载进来，通过&lt;ViewStub&gt; 就可以在需要用到的时候再加载，提高程序初始化的性能。 绘制优化 在 onDraw() 中不要创建新的局部对象，这是因为 onDraw() 可能会频繁的调用，这样就会在一瞬间产生大量的临时对象，这不仅占用过多的内存而且会导致系统频繁的gc, 降低程序的执行效率; 另外也不能做一些耗时的任务。 内存泄漏优化 静态变量导致的内存泄漏 例如： 123456789private static Context mContext; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_combine); mContext = this; &#125; 单例模式导致的内存泄漏 属性动画导致的内存泄漏 Android 3.0 之后，提供了属性动画，如果开启无限循环动画，隐藏后，未调用 animator,cancel() 来停止动画，也会发生内存泄漏，因为这个时候 Activity 的 View 被动画所持有，而 View 又持有 Activity, 最终Activity 无法释放。0- 响应速度优化和ANR日志 响应速度优化的核心是避免在主线程做耗时操作， Activity 5s 未做出响应， Service 10s未做出响应，就会出现 ANR ,查看 \data\anr 目录下的 trace,txt 文件分析产生 ANR 的原因 线程优化 线程优化一般都是采用线程池，避免程序中存在大量的 Thread, 线程池可重用内部的线程，从而避免线程的创建和销毁所带来的性能开销。]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效使用RxJava]]></title>
    <url>%2F2018%2F11%2F20%2F%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8RxJava%2F</url>
    <content type="text"><![CDATA[Question 场景一：在页面保存时，需要对页面所填写的一些列信息进行判断，确定正确无误后方可保存。 例如：页面上中需要填写：姓名，性别，职业，年薪，住址等信息。 按照常规做法,我们有可能会这么写： 12345678910if(Util.checkempty(mUserName))&#123;//判断用户名是否为空 return;&#125;if(Util.checkempty(mSex))&#123;//判断性别是否为空 return;&#125;.....if(Util.checkempty(mAddress))&#123;//判断住址是否为空 return;&#125; 而用 Rxjava.combineLatest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//构建被观察者Observable userNameObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; subscriber) &#123; tv.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subscriber.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;); Observable sexObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; subscriber) &#123; sex.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subscriber.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;); Observable.combineLatest(userNameObservable, sexObservable, new Func2&lt;String,String,Boolean&gt;() &#123; @Override public Boolean call(String userName, String sex) &#123; //判断用户名 boolean isUserInvalid = !TextUtils.isEmpty(userName); //判断性别 boolean isSexInvalid = !TextUtils.isEmpty(sex); return isUserInvalid &amp;&amp; isSexInvalid; &#125; &#125;).subscribe(new Action1() &#123; @Override public void call(Object o) &#123;//只有都满足条件后才会执行到这里 Log.i("xx","信息："+o);//可以保存信息了 &#125; &#125;); 场景二：搜索输入，避免多次调用搜索接口，搜索优化 12345678910111213141516171819202122232425262728293031323334353637383940414243Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(final Subscriber&lt;? super String&gt; subscriber) &#123; tv.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subscriber.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; &#125;).filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; return !TextUtils.isEmpty(s);//过滤为空的 &#125; &#125;).debounce(1,TimeUnit.SECONDS) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i("xx","搜索字符串：："+s); &#125; &#125;);]]></content>
      <tags>
        <tag>rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2F2018%2F11%2F19%2FRxJava%2F</url>
    <content type="text"><![CDATA[1. 变换 map() 它是一对一的 123456789101112Observable.just("image/logo.png")//输入类型String,图片地址 .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; return getBitmap(filePath);//转换为bitmap &#125; &#125;).subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; showBitmap(bitmap);//显示bitmap &#125; &#125;); flatMap() 多对多转换 假如有这样一个场景，我们需要打印每个学生所修的课程，学生是一个集合，课程也是一个集合，如果按照map() 的做法如下： 这里我选用我项目里随意一个bean 对象，意思不变 12345678910111213141516UserInfo[] userInfos = new UserInfo[3];Observable.from(userInfos) .map(new Func1&lt;UserInfo, List&lt;AppInfo&gt;&gt;() &#123; @Override public List&lt;AppInfo&gt; call(UserInfo userInfo) &#123; return userInfo.getAppInfos(); &#125; &#125;).subscribe(new Action1&lt;List&lt;AppInfo&gt;&gt;() &#123; @Override public void call(List&lt;AppInfo&gt; appInfos) &#123; for(AppInfo info : appInfos)&#123; Log.i("xx",info.getAppName()); &#125; &#125; &#125;); 有种情况就是假如我不想要循环遍历呢，而是直接拿到 AppInfo 对象，显然 map() 是无法实现的，map() 我们前面也说过是 一对一的转换，而现在是一对多，那此时就应该用 flatMap(). 使用flatMap() 的话，如下： 12345678910111213141516171819202122Observable.from(userInfos) .flatMap(new Func1&lt;UserInfo, Observable&lt;AppInfo&gt;&gt;() &#123; @Override public Observable&lt;AppInfo&gt; call(UserInfo userInfo) &#123; return Observable.from(userInfo.getAppInfos()); &#125; &#125;).subscribe(new Subscriber&lt;AppInfo&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(AppInfo appInfo) &#123; Log.i("xx","appInfo.name::"+appInfo.getAppName()); &#125; &#125;); 上述是用 flatMap() 编写的，去除了 for 循环，flatMap() 和 map() 有一个相同点：它们都是把传入的参数转化之后返回另一个对象。但需要注意的是，和map() 不同的是，flatMap() 中返回的是 Observable 对象。 flatMap() 原理如下： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable 对象，而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable,而这个 Observale 负责将这些事件统一交给 Subscriber 的回调方法。]]></content>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[衡量代码的好坏，包括两个非常重要的指标： 运行时间 占用空间 由于运行环境和输入规模的影响，代码的绝对执行时间是无法估计的，但是我们却可以预估代码的基本执行次数。 常见的时间复杂度有如下： T(n) = O(n) T(n) = O(logn) T(n) = O(1) T(n) = O(n²) 这四种时间复杂度谁用时更长，更节省时间呢？ O(1) &lt; O(logn) &lt; O(n) &lt; O(n²)]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生产者消费者模式]]></title>
    <url>%2F2018%2F11%2F19%2Fjava%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Producter.java 生产者： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 生产者 */public class Producter extends Thread &#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; int i = 0; public Producter(String name,Queue&lt;Integer&gt; queue,int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true)&#123; synchronized (queue)&#123; while(queue.size() == maxSize)&#123; try&#123; System.out.println("Queue is full,Productr["+name+" ]thread waiting for"); //等待 queue.wait(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; System.out.println("["+name+"] producting value:+"+i ); queue.offer(i++); queue.notifyAll(); try&#123; Thread.sleep(new Random().nextInt(1000)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Consumer.java 12345678910111213141516171819202122232425262728293031323334353637383940public class Consumer extends Thread &#123; private Queue&lt;Integer&gt; queue; String name; int maxSize; public Consumer(String name,Queue&lt;Integer&gt; queue,int maxSize)&#123; super(name); this.name = name; this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true)&#123; synchronized (queue)&#123; while (queue.isEmpty())&#123; try&#123; System.out.println("Queue is empty,Consumer ["+name+"] thread is waiting for Producer"); //如果为空，就等待 queue.wait(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; int x = queue.poll(); System.out.println("["+name+" Consumer value : "+x); queue.notifyAll(); try&#123; Thread.sleep(new Random().nextInt(1000)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; main.java: 123456789101112131415161718public static void main(String args[])&#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Thread product1 = new Producter("p-1",queue,5); Thread product2 = new Producter("p-2",queue,5); Thread consumer1 = new Consumer("C1",queue,5); Thread consumer2 = new Consumer("C2",queue,5); Thread consumer3 = new Consumer("C3",queue,5); product1.start(); product2.start(); consumer1.start(); consumer2.start(); consumer3.start(); &#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点三]]></title>
    <url>%2F2018%2F11%2F15%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1. RecycleView 如何设置分割线的？ 它是读取系统自带的属性 R.attr.listDivider 属性，来设置分割线的，支持横向和纵向。 2. RecycleView 分割线的样式如何修改？ 第一种办法：因为 R.attr.listDivider 定义在系统样式中，那么我们可以重写这个属性修改，如下： 在styles.xml 中添加该属性： 12345&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; .... &lt;item name="android:listDivider"&gt;@drawable/drawable_bg&lt;/item&gt; &lt;/style&gt; 其中 drawable_bg 为自定义分割线的drawable. 第二种办法：可以通过自带的 setDrawable() 改变，如下： 1234DividerItemDecoration itemDecoration = new DividerItemDecoration(this,DividerItemDecoration.VERTICAL); Drawable drawable = getResources().getDrawable(R.drawable.drawable_bg); itemDecoration.setDrawable(drawable); recyclerView.addItemDecoration(itemDecoration); 3. RecycleView 缓存 缓存涉及三个类，分别是： Recycler RecycledViewPool ViewCachedExtension Recycler : 用于管理已经废弃或者与 RecyclerView 分离的 ViewHolder mChangedScrap : 与 RecyclerView 分离的 ViewHolder 列表 mAttachedScrap : 未与 RecyclerView 分离的 ViewHolder 列表 mCachedViews : ViewHolder 缓存列表 RecycledViewPool : ViewHolder 缓存池 ViewCachedExtension : 开发者可以控制的 ViewHolder 缓存的帮助类 获取缓存里的 ViewHolder 的关键方法是： tryGetViewHolderForPositionByDeadline 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Nullable ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123; throw new IndexOutOfBoundsException("Invalid item position " + position + "(" + position + "). Item count:" + mState.getItemCount() + exceptionLabel()); &#125; boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there // 0) 如果需要改变废弃的view，从这里查找 if (mState.isPreLayout()) &#123; //这里是 mChangedScrap 集合中取出 holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; // 1) Find by position from scrap/hidden list/cache // 1） 这是从 mAttachedScrap 集合中查找 if (holder == null) &#123; holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) &#123; if (!validateViewHolderForOffsetPosition(holder)) &#123; // recycle holder (and unscrap if relevant) since it can't be used if (!dryRun) &#123; // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; recycleViewHolderInternal(holder); &#125; holder = null; &#125; else &#123; fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123; throw new IndexOutOfBoundsException("Inconsistency detected. Invalid item " + "position " + position + "(offset:" + offsetPosition + ")." + "state:" + mState.getItemCount() + exceptionLabel()); &#125; final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap/cache via stable ids, if exists // 2）从 mCachedViews 集合中查找缓存 if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; // We are NOT sending the offsetPosition because LayoutManager does not // know it. // 3 从mViewCacheExtension 获取 final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); if (holder == null) &#123; throw new IllegalArgumentException("getViewForPositionAndType returned" + " a view which does not have a ViewHolder" + exceptionLabel()); &#125; else if (holder.shouldIgnore()) &#123; throw new IllegalArgumentException("getViewForPositionAndType returned" + " a view that is ignored. You must call stopIgnoring before" + " returning this view." + exceptionLabel()); &#125; &#125; &#125; if (holder == null) &#123; // fallback to pool if (DEBUG) &#123; Log.d(TAG, "tryGetViewHolderForPositionByDeadline(" + position + ") fetching from shared pool"); &#125; // 4）从缓存池中获取 recycledViewPool holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123; // abort - we have a deadline we can't meet return null; &#125; //如果都没有 就重新创建 createViewHolder holder = mAdapter.createViewHolder(RecyclerView.this, type); ..... &#125; &#125; &#125; 总结缓存的机制如下： 1.从 mChangedScrap 或 mAttachScrap 中获取 2.从 mCacheViews 3.从 mRecycledViewPool 缓存池中获取 4. RecycleView 刷新闪屏一般刷新： 1adapter.notifyItemChanged(0); 参数：position 实际上会全部刷新，局部刷新应使用： 1adapter.notifyItemChanged(0,"q"); 参数： position,payload 并且在 adapter 中重写方法： `onBindViewHolder(RecyclerView.ViewHolder holder, int position, List payloads)方法` payloads 的 size 始终为1. 123456789@Overridepublic void onBindViewHolder(ViewHolder holder, int position, List&lt;Object&gt; payloads) &#123; if(payloads.isEmpty())&#123; onBindViewHolder(holder,position); &#125;else&#123; String type = payloads.get(0);//获取为 q holder.name.setText(list.get(position)); &#125; &#125; 5. RecycleView 和 listView//https://zhuanlan.zhihu.com/p/23339185 缓存层级不同 recycleView 比 listView 多两级缓存，支持开发者自定义缓存处理，支持多个recycleView共用同一个 recycleViewPool(缓存池) listView 缓存（两级缓存）： 是否需要回调createView 是否需要回调bindVIew 生命周期 备注 mActiveViews 否 否 onLayout函数周期内 用于屏幕内itemView快速重用 mScrapViews 否 是 与mAdapter一致，当Adapter被更换时，mScrapViews即被清空 RecycrleView 缓存( 四级缓存)： 是否回调createView 回调bindVIew 生命周期 备注 mAttachedScrap 否 否 onLayout 用于屏幕内itemView快速重用 mCacheViews 否 否 与mAdapter一致，当Adapter被更换时,mCacheVIews被缓存到mRecyclerPool 默认缓存大小是2 mViewCacheExtension 用户自定义实现 mRecyclerPool 否 是 与自身生命周期一致，不再引用时被释放 默认大小是5 ListView 和 RecyclerView 缓存机制： mActiveViews 和 mAttachedScrap 功能相似，意义在于快速重用屏幕上可见的列表项 itemView,而不需要重新createView 和 bindView mScrapView 和 mCachedViews + mRecyclerViewPool 功能相似，意义在于缓存离开屏幕的itemView,目的是让即将进入屏幕的 itemView 重用 RecycleView 的优势在于 mCacheVIews 的使用，可以做到屏幕外的列表项itemView 进入屏幕内时也无须bindView 快速重用； mRecycleViewPool 可以供多个recycleView 共同使用，在特定场景下，如viewpager 加多个列表页有优势。 6. RecycleView 的回收复用机制的内部实现都是哪个类完成的？ RecycleView 的回收复用机制都是由内部类 Recycler 类，核心方法：tryGetViewHolderForPositionByDeadline() 方法中完成的。 随笔源码记录： 复用机制1234567891011121314151617public View getViewForPosition(int position) &#123; return getViewForPosition(position, false); &#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125;@NullableViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //复用机制的原理 - 1.mCacheView - 2.recyclerViewPool - 3.扩展 - 4.都没有，重新创建一个ViewHolder(createViewHolder) ...&#125; 回收机制 也是 Recycler 类中的，核心方法：recycleViewHolderInternal(holder) 123456789101112131415public void recycleView(View view) &#123; // This public recycle method tries to make view recycle-able since layout manager // intended to recycle this view (e.g. even if it is in scrap or change cache) ViewHolder holder = getChildViewHolderInt(view); if (holder.isTmpDetached()) &#123; removeDetachedView(view, false); &#125; if (holder.isScrap()) &#123; holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; //回收的内部实现 recycleViewHolderInternal(holder); &#125; 回收的逻辑：由 LayoutManager 来遍历移出屏幕的卡位，然后对每个卡位进行回收操作，回收时，都是把 viewHolder 放在 mCachedViews 里面，如果mCachedViews 满了，那就在mCachedViews 里拿一个ViewHolder 扔到 ViewPool 缓存里，然后mCachedViews 就可以空出位置来放新回收的ViewHolder 了。 mCachedViews 里存放的 ViewHolder 只有原本位置的卡位才能复用 参考链接：https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/79946425 =================================================================================== updateViewCacheSize() 12345void updateViewCacheSize() &#123; int extraCache = mLayout != null ? mLayout.mPrefetchMaxCountObserved : 0; mViewCacheMax = mRequestedCacheMax + extraCache; .... &#125; 在第一次向上滑动]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点总结二]]></title>
    <url>%2F2018%2F11%2F14%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1. Canvas.save() 跟 Canvas.restore()的调用时机 save: 用来保存 Canvas 的状态。save 之后，可以调用Canvas 的平移，放缩，旋转等操作。 restore: 用来恢复canvas 之前保存的状态。防止save 后对Canvas 执行的操作对后续的绘制有影响。 2. Android P(9.0) 的新特性 支持WiFi室内定位 适配刘海屏 通知栏改进：可以显示对话，附加照片和表情等 多摄像头api 对于非 http 连接，将直接拦截，推荐使用https Android 8.0 PHONE 权限组新增加两个权限 ANSWER_PHONE_CALLS:允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 assceptRingingCall() 函数 READ_PHONE_NUMBERS: 权限允许您的应用读取设备中存储的电话号码 通知适配 为了更好的管理通知的提醒，不想一些不重要的通知打扰用户，新增加用户渠道，用户可根据渠道屏蔽一些不重要的通知 安装apk 在 AndroidManifest 文件中添加未知来源应用的权限： &lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt; 这样系统会自动询问用户完成授权。 也可以通过 canRequestPackageInstalls 查询是否有此权限，如果没有的话就使用 Settings.ACTION_MANAGE_UNKNOW_APP_SOURCE 引导用户安装未知应用权限去授权。 123456789101112131415161718if(Build,VERSION&gt;SDK_INT &gt;= 26)&#123; Boolean isInstall = getPackageManager().canRequestPackageInstalls();//26以上 if(isInstall)&#123; //有此权限，安装应用 &#125;else&#123; //跳转到 安装未知应用 权限界面，引导用户开启权限 Uri selfPackageUri = Uri.parse("package:" + this.getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri); startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP)&#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123; //如果权限开启，则开始安装应用 &#125; &#125; 静态广播无法正常接受 Android N(7.0) 的新特性 私有文件外部将不能访问，通过FileProvider 可解决 SharedPreferences 进程间通信模式闪退，SecurityException Android 6.0 运行时权限的申请 https 的推荐 3. APK 内容 assets 存放需要打包到 APK 中的静态文件 lib 目录 native库 res 目录 存放应用程序的资源 META-INF 存放应用程序签名和证书的目录 AndroidManifest.xml classes.dex resources.arsc 资源配置文件 4. Binder 机制的优点 Linux 中使用的 IPC 通信机制有：pipe(管道)，signal(信号量)，Socket socket:是一个通用接口，传输效率低，开销比较大； 管道和消息队列：采用存储转发方式，所以至少需要拷贝2次数据，效率低，共享内存虽然在传输时没有拷贝数据，但其控制机制复杂，而 Binder 更好传输性能。 安全性更高，可以建立私有通道，有身份标识（UID/PID） 另外一个优点就是，通过binder 可以很方便的调用server 端的方法，犹如调用本地方法一样。 5. Gradle 的生命周期 1.初始化 初始化主要是读取 settings.gragle 文件，用于确定哪些项目参与构建，并创建Project 实例 2.配置 配置阶段主要是为每个 build.gradle 文件配置 project 对象 3.执行 主要根据 gradle 命令和传入参数创建并执行任务]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔记录Android]]></title>
    <url>%2F2018%2F11%2F13%2F%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95Android%2F</url>
    <content type="text"><![CDATA[1. Android中数据存储的方式 FIle SharedPreference Sqlite 网络 ContentProvider FileProvider : 继承于 ContentProvider 的子类，可以用于解决Android7.0中禁止我们的应用对外部公开file://的问题。 2. SharedPreference 是进程同步的吗 sharedPreference 默认不是线程同步的，可以设置模式为：MODE_MULTI_PROCESS 做到进程同步，系统默认也是有缓存的，有很多问题，在Android N（7.0）以上废弃不能使用了，会抛出异常。推荐使用 ContentProvider sharedPreference 四种模式： MODE_PRIVATE MODE_MULTI_PROCESS MODE_WORLD_READABLE MODE_WORLD_WRITEABLE 3.Shareferences commit 和 apply 的区别 在很早的sdk当中，一般都使用 commit 方法，同步，直接写入磁盘，并且有返回结果 boolean 类型，而 apply 是异步, 先写入内存，然后异步写入磁盘。 如果操作频繁的话，apply 的性能优于 commit. 在阿里巴巴开发手册中也记录到： SharedPreference 提 交 数 据 时 ， 尽 量 使 用 Editor#apply()，而非Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使用 Editor#commit()。 4. View 的 measureSpec 由谁决定的 View的MeasureSpec 由这个父控件的MeasureSpec 和自身的 LayoutParams 决定 顶级 DecorView 由窗口尺寸和自身的 LayoutParams 共同确定 5.ACTION_CANCEL 事件 一般来说，如果一个子视图接受了父视图分发给它的 ACTION_DOWN 事件，那么与ACTION_DOWN 事件相关的事件都要分发给这个子视图，但是如果父视图希望拦截其中的一些事件，不再继续转发事件给这个子视图的话，那么就需要给子视图一个ACTION_CANCEL 事件。 6. View的invalidate postInvalidate requestLayout区别 invalidate 会调用 onDraw 进行重绘，只能在主线程 postIncalidate 可以在其它线程，如子线程 requestLayout 会调用 onLayout 和 onMeasure ,不一定会调用 onDraw 7. View 的生命周期 Creation 创建（从xml中加载或者layout 文件中定义加载） onFinishInflate() 从xml中加载完成 Layout 布局 onMeasure() onLayout() Drawing 绘制 onDraw() Event processing 事件处理 Focus 聚焦 onFocusChanged() onWindowFocusChanged() Attaching 附上 onAttachingToWindow() onDetachedFromWindow() onVisibiltyChanged() onWindowVisibiltyChanged()]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础二]]></title>
    <url>%2F2018%2F11%2F13%2Fjava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1. HashMap1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; .....&#125; 未完待续….仍需要查阅大量资料学习…. 2.Java 内存分配 栈区：方法区内的局部变量，对象的引用等 优点：速度快，缺点：大小和生命周期必须是确定的。 堆区：new出来的对象，垃圾回收器回收的是堆区的内存 方法区（静态区）：静态变量，常量，保存类信息 3.垃圾 什么是垃圾？要通过科学的方法才能判断是否是为垃圾，有两种方法 引用计数法：可能会导致内部循环 可达性分析：是否可达 借助一个图快速理解 引用计数法： 代码： 123456789101112/**循环问题*/public class Demo&#123; public Demo instance; public static void main(String[] args) &#123; Demo a=new Demo(); Demo b=new Demo(); a.instance=b; b.instance=a; a=null; b=null; &#125;&#125; 再看下这个 可达性分析 ： ObjD 和 ObjE 虽然内部存在引用，但是定点不可达，所以也是垃圾回收的对象。 4.垃圾回收的方法 标记-清除：减少停顿时间，但会造成内存碎片 标记-整理：可以解决内存碎片，但是会增加停顿时间 复制清除：从一个地方拷贝到另一个地方，适合有大量回收的场景，比如：新生代回收 优点：效率高于标记清除，活着的对象是整齐排列的，没有内存碎片 缺点： 浪费空间，毕竟如果按照1：1比例划分空间的话，那么将会有50%的空间被浪费。不过在jvm中，新生代空间并不是按照1：1来划分的，而是按照8：1：1的比例分为一个eden 区 和两个survivor(survivor0,survivor1) 区，然后一个eden 区，两个survivor 区。大部分对象在Eden 区中生成。回收时先将eden 区存活对象复制到一个survicor0 区，然后清空eden 区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1 区，然后清空eden 区和survivor0 区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，这样的过程也叫做Minor GC,每进行Minor GC 一次，存活着的对象的年龄就会+1，当存活着的对象的年龄到达15岁时，就会被送进年老代。 当然，当整个survivor1区不足以存放Eden和survivor0的存活对象时，也会将存活对象直接放到年老代。若是年老代也满了就会触发一次Full GC，也就是新生代，老年代都进行回收。 分代收集：把内存区域分成不同代，根据年代不同采取不同的策略； 新生代：存放新创建的对象，采用复制回收方法 年老代：这些对象垃圾回收的频率较低，采取标记整理法 永久代：存放Java本身的一些数据，当类不再使用时，也会被回收 手稿： 5. Full GC 触发的条件 调用 System.gc 时，系统建议执行Full GC 但是不必然执行 年老代或者永久代空间不足 6. 线程调度 wait() : object 方法，必须在同步代码块中使用，使当前线程处于等待状态，释放锁 notify() ： 和 wait 联合使用，通知一个线程，具体通知哪个由jvm 决定，使用不当可能发生死锁 notifyAll() ： 和wait 方法联合使用，通知所有线程，具体哪个线程获得运行权 jvm 决定 sleep() ： 睡眠状态 7.线程同步 Synchronzied 修饰 ThreadLocal : 每个线程都有一个局部变量的副本，互不干扰。一种以空间换时间的方式。 线程安全的容器和方法，可以实现线程同步，如： Collections.SynchronizedList() 将 List 转为线程同步；用ConurrentHashMap 实现hashmap 线程同步。 volatile 修饰的变量不会缓存在寄存器中，每次使用都会从主存器中读取；保证可见性，不保证原子性]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识]]></title>
    <url>%2F2018%2F11%2F12%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 如何实现对象克隆？有两种方式： 实现Cloneable 接口并重写 clone 方法（浅拷贝）； 实现Serializable ，通过对象的序列化和反序列化实现真正的深度克隆（深拷贝），代码如下： 12345678910111213141516171819202122232425262728public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static &lt;T&gt; T clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型界定，可以检查出要克隆对象是否支持序列化，这项检查是编译器完成的，不是运行时抛出异常，这种方案明显优于使用object类的clone方法克隆对象。让问题在编译的时候暴漏出来总是优于把问题留在运行时。 2. 内部类访问局部变量的时候，为什么加final? 内部类和局部变量的生命周期不同，方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类生命周期&gt;=局部变量 Java会在编译时在内部类的构造方法里边，将局部变量以参数形式传递给内部类 而如果局部变量发生改变，内部类不知情的场景，所以要加fianl ，保证引用不可改变 注意：在Java8中，可以不适用final关键字，但是如果我们修改了局部变量还是会发生错误，从而保证局部变量的引用不变。 3. transient 关键字 如果使用transient 修饰变量，当对象存储时，它的值不需要维持。换句话来说就是用transient 修饰的变量不参与序列化的过程。 4. String 和 StringBuild,StringBuffer的区别 String 是只读字符串,创建完成之后是不能修改，如果修改也是创建一个新对象，回收旧对象的过程，所以执行效率比较低，StringBuild 和 StringBuffer 可以改变，StringBuild 线程不安全，但是效率比较高，StringBuffter 线程安全 效率快慢：Stringbuilder&gt; StringBuffer&gt; String 5. String 为什么设计成不可变 安全性 本身是final 类不可修改，不可变极为安全 String 常被用来作为 HashMap 的key 如果可变会引来安全问题，例如两个key 相同 效率高 通过字符串池可以节省很多空间 每一个String 对应一个 hashcode ,再次使用不用重新计算 6. java 中的四种引用及应用场景 强引用 弱引用—-引用到达，不可达就会被回收，即便是内存充足，可用于图片Bitmap 缓存，当不再使用Bitmap 时，就会被回收 软引用—–内存不足时被回收，也可用于Bitmap回收，当内存不足时，可回收 虚引用—-它指向的对象回收时，它本身会被加入到引用队列中，这样我们就知道它指向的对象何时被销毁]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeakCannary原理分析]]></title>
    <url>%2F2018%2F11%2F07%2FLeakCannary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[上篇写到 leakcanary 的使用,这篇主要是了解LeakCannary 大概是如何工作的。 1.首先它是如何监听Activity 销毁的？因为我们知道只有当activity 销毁（onDestroy()）的时候，我们才能对这个activity 进行分析查看哪些对象可能存在内存泄漏。 发现了如下代码：12345public static RefWatcher install(Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall(); &#125; 在buildAndInstall() 中：1234567891011121314public RefWatcher buildAndInstall() &#123; .... if (refWatcher != DISABLED) &#123; if (watchActivities) &#123; //这是观察activity的 ActivityRefWatcher.install(context, refWatcher); &#125; if (watchFragments) &#123; FragmentRefWatcher.Helper.install(context, refWatcher); &#125; &#125; LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher; &#125; 12345678public final class ActivityRefWatcher &#123; .... public static void install(Context context, RefWatcher refWatcher) &#123; Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); //拿到application，注册activity的生命周期回调 application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks); &#125; 其中这个：lifecycleCallbacks 就是回调监听123456private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123;//监听activity销毁 @Override public void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity); &#125; &#125;; 那么我们也可以通过application 注册获取activity 的生命周期监听回调，如下是我写的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LifeCircleActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.life_layout); final Application application = (Application) getApplicationContext(); application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; Log.i("xx","activity is onActivityCreated..."); &#125; @Override public void onActivityStarted(Activity activity) &#123; Log.i("xx","activity is onActivityStarted..."); &#125; @Override public void onActivityResumed(Activity activity) &#123; Log.i("xx","activity is onActivityResumed..."); &#125; @Override public void onActivityPaused(Activity activity) &#123; Log.i("xx","activity is onActivityPaused..."); &#125; @Override public void onActivityStopped(Activity activity) &#123; Log.i("xx","activity is onActivityStopped..."); &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; Log.i("xx","activity is onActivitySaveInstanceState..."); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; application.unregisterActivityLifecycleCallbacks(this); Log.i("xx","activity is onDestroy..."); &#125; &#125;);&#125; 这样我们就可以监听我们当前这个类的生命周期了，可以运行打印日志就知道了。 2.内存泄漏的对象的引用路径这块使用到了 square 的另一个开源库 haha ,获取当前内存中的heap堆信息的snapshot]]></content>
      <tags>
        <tag>leakcannary</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F07%2F%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80-leakcannary%2F</url>
    <content type="text"><![CDATA[build gradle配置 1234debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.1'releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1'// Optional, if you use support library fragments:debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.1' 配置 application 12345678private RefWatcher refWatcher; public static RefWatcher getRefWatcher(Context context)&#123; HealthApplication application = (HealthApplication) context.getApplicationContext(); return application.refWatcher; &#125; 监测 12RefWatcher refWatcher = MyApplication.getRefWatcher(this);//1 refWatcher.watch(this); 例如：我们写一个泄漏的代码1234567891011121314151617181920212223242526@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_event_bus); RefWatcher refWatcher = MyApplication.getRefWatcher(this);//1 refWatcher.watch(this); Message message = Message.obtain(); message.obj = "qianqian"; message.what = 666; handler.sendMessageDelayed(message,600000); &#125; Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.i("xx","handle message"); &#125; &#125;; public void sendMessage(View view)&#123; finish(); &#125; 界面上一个按钮，点击按钮退出程序，在程序 onCreate 方法中我们发送了一个延时的消息，按照我们的分析，肯定会发生泄漏的。来我们看下leakcannary 给我们的提示： 我们知道当我们退出程序的时候 MessageQueue 中的消息还没执行完毕，MessageQueue.mMessages 这个变量持有的是Message 这个对象，而 Message.target中的 target持有的该Activity的 handler引用，所以此时finish 掉的 activity 并不会被回收，导致LeakActivity 发生内存泄漏。 其中一种解决办法呢，就是我们可以通过在点击或activity 退出时，removeMessage，例如：1234public void sendMessage(View view)&#123; handler.removeMessages(666); finish(); &#125; 这样就不会有警告了。 也可以通过静态内部类+弱引用的方式：123456789101112131415161718192021222324252627private static class MyHandler extends Handler &#123; private final WeakReference&lt;LeakActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;LeakActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; LeakActivityactivity = mActivity.get(); if (activity != null) &#123; ... &#125; &#125; &#125;private final MyHandler handler= new MyHandler(this); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_event_bus); Message message = Message.obtain(); message.obj = "qianqian"; message.what = 666; handler.sendMessageDelayed(message,600000); &#125;&#125; 在实际项目中，可以用这个工具筛查一遍。]]></content>
      <tags>
        <tag>leakcannary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus 源码分析（下篇）]]></title>
    <url>%2F2018%2F10%2F08%2FEventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上篇 EventBus 源码分析（上篇） 说到注册订阅的前半部分，此篇用来分析发送事件到接收事件这个过程。 1. 发送事件示例：1EventBus.getDefault().post(new RemindBean(&quot;2018-02-12&quot;,&quot;happy&quot;)); post:1234567891011121314151617181920212223242526272829/** Posts the given event to the event bus. */ public void post(Object event) &#123; - 1.获取当前线程的postingThreadState 对象 PostingThreadState postingState = currentPostingThreadState.get(); - 2. 获取里面那个事件队列 List&lt;Object&gt; eventQueue = postingState.eventQueue; - 3. 将事件添加到队列中去 eventQueue.add(event); - 4. 判断当前的event 是否在 posting if (!postingState.isPosting) &#123; - 5. 是否是主线程 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; - 6. 判断是否取消 if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; while (!eventQueue.isEmpty()) &#123;//不为空，进入循环 - 7.按照顺序，post一个 remove一个 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; PostingThreadState 大概看一眼12345678final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled; &#125; 再就是 postSingleEvent(eventQueue.remove(0), postingState); 方法：12345678910111213141516171819202122232425262728private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; - 1. 获取event的字节码（例如就是：RemindBean.class） Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123;//默认为true - 2. 根据eventClass 的字节码查找 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); - 3.循环遍历 for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); - 4.根据事件，字节码查找订阅者 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; postSingleEventForEventType:12345678910111213141516171819202122232425262728293031private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; - 1.根据字节码取出subscriptions,还记得我们之前在subscribe这个方法的时候，把subscrber,subscriberMethod 封装成一个subscription 对象。 subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; - 2. 取出每一个subscription 对象 postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; - 3. post到相应的线程中回调 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; postToSubscription: 根据定义的不同线程，调用相应的方法1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING://一般没定义的，这个就是post在哪个线程，响应就在哪个线程执行 invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125; &#125; invokeSubscriber:12345678910void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; - 反射拿到字节码clazz 反射调用方法，就收到消息了 subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(&quot;Unexpected exception&quot;, e); &#125; &#125; end.]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eventbus 源码分析（上篇）]]></title>
    <url>%2F2018%2F10%2F08%2FEventbus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[可用于应用内的消息事件传递，方便快捷，耦合性低 1.基本用法1234567891011121314151617181920212223242526272829public class EventBusMain extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.content_main); EventBus.getDefault().register(this); &#125; - 订阅的事件 onEvent1 @Subscribe public void onEvent1(RemindBean bean)&#123; &#125;- 订阅的事件 onEvent2 @Subscribe public void onEvent2(UserInfo bean)&#123; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125;&#125; 需要发送消息传递的时候：1EventBus.getDefault().post(new RemindBean()) 2.源码解读放上官网的一张原理图，感觉挺清晰的： 发布消息的一方(Publisher)，只需要 post 一个 event 之后就不用管了，EventBus 内部会将event逐一分发给订阅此 event 的订阅者（Subscriber）. 不错就是这样一个东西。 还记得以往我要实现两个不同的activity 之间要传递一些数据的时候，我都是通过定义一个interface的形式完成，时间一长，定义的接口一堆，在回顾查看代码也确实不够美观。好了话不多说，看下大家都在用的Eventbus. 3.首先1EventBus.getDefault().register(this); getDefault():123456789101112EventBus 是一个单例模式，懒汉式，双重判断 /** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; register 是什么意思呢，就是就跟你订阅报纸一样，报社需要确定几个重要的问题： 订阅者是谁（Subscriber）？ 订阅的什么报纸(Event) ？ 就是我认为比较重要的，那么register 这一步就是Subscriber 告诉 报社，订阅的event1234567891011121314public void register(Object subscriber) &#123; - 1.先拿到这个订阅者(subscriber)类的字节码 Class&lt;?&gt; subscriberClass = subscriber.getClass(); - 2. 通过这个类的字节码，拿到所有的订阅的 event,存放在List中 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; - 3. 循环遍历所有的订阅的方法，完成subscriber 和 subscriberMethod 的关联 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 我们看下这个如何根据subscriberClass 找到这个订阅的 method的，findSubscriberMethods: 1234567891011121314151617181920212223242526List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; - 1.先从缓存中取 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); - 2. 第一次肯定 null if (subscriberMethods != null) &#123; return subscriberMethods; &#125; - 3. 查找默认也是false，感兴趣的可以看下 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; - 4. 所以是走这里 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; - 5. 找到之后添加到缓存中，key是 subscriber ;value 是：methods METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 看下：findUsingInfo(subscriberClass)123456789101112131415161718192021222324252627282930private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; - 1. 我认为就是准备一个查找结果得存储对象 FindState findState = prepareFindState(); - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass 同时赋值给clazz变量中,以下代码能够看出// void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; // this.subscriberClass = clazz = subscriberClass;//&#125; findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123;进入循环中 //获取subscriberInfo 信息，返回null findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; - 3. 进入到这里了 findUsingReflectionInSingleClass(findState); &#125; - 4. 查找父类中的方法 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; findUsingReflectionInSingleClass 如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities - 1. 通过订阅者的字节码查找当前类中所有生命的方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; - 2. 循环遍历所有的方法 for (Method method : methods) &#123; - 3. 获取方法的修饰符 int modifiers = method.getModifiers(); - 4.判断修饰符，订阅方法的修饰符不能是private，static if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; - 5. 获取方法的所有的参数 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); - 6.判断参数的个数，只能有1个参数，订阅方法中 if (parameterTypes.length == 1) &#123; - 7.获取方法上具有subscribe 注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); - 8.含有subscribe注解的方法，就是该类订阅的方法，其它不符合的可能就是普通的方法 if (subscribeAnnotation != null) &#123; - 9. 获取第一个参数eventType Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; - 10. 获取注解的mode，就是我们在注解上标识的， 有mainThread,Posting,background,async ThreadMode threadMode = subscribeAnnotation.threadMode(); - 11. 将订阅方法的一系列信息（方法名称，threadMode,优先级，是否是粘性等）添加到集合subscriberMethods中去 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; - 12. 参数是多个的时候抛出异常 String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; - 13. 方法的修饰符不是public的，抛出异常 String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; 这样我们将所有信息都保存到findState 类中去了。再回头看我们原先那个方法,到第三步了：123456789101112131415161718192021222324252627282930private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; - 1. 我认为就是准备一个查找结果得存储对象 FindState findState = prepareFindState(); - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass 同时赋值给clazz变量中,以下代码能够看出// void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; // this.subscriberClass = clazz = subscriberClass;//&#125; findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123;进入循环中 //获取subscriberInfo 信息，返回null findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; - 3. 进入到这里了，上面已经分析所有信息保存到findState中 findUsingReflectionInSingleClass(findState); &#125; - 4. 查找父类中的方法 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 在这个getMethodsAndRelease(findState):123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; - 1. 取出里面的subscriberMethods List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; - 2. 返回集合 return subscriberMethods; &#125; 至此，我们知道了根据订阅者（subscriber）的clazz 找到了所有订阅的方法事件 methods 回到最初的第一步register:1234567891011public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); - 2. 完成 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; - 3.循环遍历所有的订阅方法和订阅者之间建立关联 subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; subscribe(subscriber, subscriberMethod) 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; - 1. 订阅方法的eventType的字节码 Class&lt;?&gt; eventType = subscriberMethod.eventType; - 2. 订阅者和订阅方法封装成一个Subscription 对象 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); - 3. subscriptionsByEventType 第一次也是null ,根据eventType CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); - 4. 第一次肯定为null if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); - 5. key 为 eventType, value 是subscriptions对象 subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; - 抛出异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; - 6. 获取所有添加的subscriptions int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; - 7. 会判断每个订阅方法的优先级，添加到这个 subscriptions中，按照优先级 if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; - 8.获取订阅的方法集合 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); - 9. 为空添加到 typesBySubscriber typesBySubscriber.put(subscriber, subscribedEvents); &#125; - 10. 订阅事件添加到subscribedEvents集合中去 subscribedEvents.add(eventType); - 11. 判断是否是粘性事件的关联 if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 到此，如果你跟着我一步步看到这里，应该大概明白一些了，还有一部分没完，就是register 前半部分完成订阅，存储等工作；剩下post(event) 方法就是将event 分发给相应订阅过此事件的订阅者了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask源码解读]]></title>
    <url>%2F2018%2F09%2F19%2FAsyncTask%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[屡思路 1. 初始 AsyncTaskAsyncTask 这个类的声明如下：1234public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; .....&#125; 是一个抽象类Params 表示输入参数的类型Progress 表示后台任务的执行进度Result 表示返回结果的类型 2.使用 在 AsyncTask 这个类的顶部有一些代码注释，里面讲述了如何使用一个 AsyncTask,如下：123456789101112131415161718192021222324252627282930* &lt;p&gt;Here is an example of subclassing:&lt;/p&gt; * &lt;pre class=&quot;prettyprint&quot;&gt; * private class DownloadFilesTask extends AsyncTask&amp;lt;URL, Integer, Long&amp;gt; &#123; * protected Long doInBackground(URL... urls) &#123; * int count = urls.length; * long totalSize = 0; * for (int i = 0; i &lt; count; i++) &#123; * totalSize += Downloader.downloadFile(urls[i]); * publishProgress((int) ((i / (float) count) * 100)); * // Escape early if cancel() is called * if (isCancelled()) break; * &#125; * return totalSize; * &#125; * * protected void onProgressUpdate(Integer... progress) &#123; * setProgressPercent(progress[0]); * &#125; * * protected void onPostExecute(Long result) &#123; * showDialog(&quot;Downloaded &quot; + result + &quot; bytes&quot;); * &#125; * &#125; * &lt;/pre&gt;//user&lt;p&gt;Once created, a task is executed very simply:&lt;/p&gt; * &lt;pre class=&quot;prettyprint&quot;&gt; * new DownloadFilesTask().execute(url1, url2, url3); * &lt;/pre&gt; 3. 内部重要方法 onPreExecute()123@MainThread protected void onPreExecute() &#123; &#125; 在主线程中运行，异步任务之前会被调用，一般用于做一些准备工作； doInBackground()12@WorkerThread protected abstract Result doInBackground(Params... params); 在线程池中运行，此方法一般用于执行异步任务，通过publishProgress 方法来更新进度； onProgressUpdate()123@MainThread protected void onProgressUpdate(Progress... values) &#123; &#125; 主线程中运行，当通过publishProgress 方法调用后，onProgressUpdate() 方法会被调用； onPostExecute()123@MainThread protected void onPostExecute(Result result) &#123; &#125; 主线程中运行，将返回的结果展示。 4.源码分析从它的 execute 方法开始：12345678 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; //sDefaultExecutor 定义如下，线程池 return executeOnExecutor(sDefaultExecutor, params); &#125;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 1234567891011121314151617181920212223242526@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; //首先判断是不是 PENDING if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; //将状态设置为 RUNNING 状态 mStatus = Status.RUNNING; //1.调用了 onPreExecute() 方法 onPreExecute(); //将参数封装到 mWorker.mParams 中去了 mWorker.mParams = params; //调用execute 将mFuture 传进去了 exec.execute(mFuture); return this; &#125; 为了弄明白整体流程，首页要搞明白上面的 mWorker mFuture 是干嘛的。 mWorker 1234567891011121314151617 private final WorkerRunnable&lt;Params, Result&gt; mWorker;//抽象类 并且实现了Callable 接口private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams; &#125; @SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//在AsyncTask 的构造方法中，分别对 mWorker, mFuture 进行了初始化public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; //实现 了 call 方法 public Result call() throws Exception &#123; //设置调用了为 true mTaskInvoked.set(true); // Result result = null; try &#123; //设置线程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked //将 2. doInBackground的结果存储到 result 中 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; //最后执行postResult postResult(result); &#125; //返回结果 return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; postResult(result) 方法1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 发送一条 MESSAGE_POST_RESULT 的消息，并且将result 存入到了 AsyncTaskResult中的 mData 中去了，其中 AsyncTaskResult12345678910@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;) private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125; &#125; getHandler 获取一个 Handler ,我们看下 handleMessage 的MESSAGE_POST_RESULT 对这条消息的处理：123456789101112131415161718192021private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: //是他是他 就是他 // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 其中 result 是 AsyncTaskResult 类型，前面我们见到过的，mTask 当时我们传的是 this 也就是当前的 AsyncTask ,调用finish 方法，将mData 返回的结果传入进去，还记得我们前面看过的吗，将返回的结果存入AsyncTaskResult.mData中去了。 下面看下 finish方法：1234567891011private void finish(Result result) &#123; //判断是否取消，如果取消了，就不执行onPostExecute 了 if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; //4. 就执行onPostExecute 方法了 onPostExecute(result); &#125; // 将状态标志为 finish mStatus = Status.FINISHED; &#125; ok ，上述都是 mWorker 工作的，接下来是我们一开始说的 mFuture mFuture123456789101112131415161718private final FutureTask&lt;Result&gt; mFuture;//初始化也是在AsyncTask 构造方法中执行的，在mWorker 之下，并且将mWorder 传入mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; postResultIfNotInvoked(get()); 如下：1234567891011private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); //wasTaskInvoked 为true ,之前在 mWorker 中设置了为true//mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;// public Result call() throws Exception &#123; // mTaskInvoked.set(true); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; FutureTask :123456789101112131415161718192021222324252627282930313233343536373839404142我们知道mWorker implement Callable 接口，传入赋值给了callable 变量 public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125;public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; //callable 变量又赋值给了 c Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; //这里调用c.call 实际上就是调用 mWorker.call 方法//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; ok ，这是 mFuture,还剩下最后一个： exec.execute(mFuture); exec 就是 sDefaultExecutor ,其实 就是 SerialExecutor,如下：123private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); SerialExecutor 如下：123456789101112131415161718192021222324252627private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); //第一次肯定为null ，执行 scheduleNext if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; //给 mActivie 赋值，mTasks.poll 会从第一个开始取 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 上面我们将 mFuture 传入，实际就是 r.mTask 是 ArrayDeque&lt;Runnable&gt; 姑且认为它是这个排队序列的吧。看下offer 方法：12345678910111213/** 插入一个 element 在队尾 * Inserts the specified element at the end of this deque. * * &lt;p&gt;This method is equivalent to &#123;@link #offerLast&#125;. * * @param e the element to add * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;) * @throws NullPointerException if the specified element is null */ public boolean offer(E e) &#123; return offerLast(e); &#125; 看注释，也就是说是每次执行一个任务，都是在当前 deque 的队尾开始排队的。并且执行是串行的，因为当第二个线程过来的时候，判断 mActive 不为 null 将不会执行 scheduleNext.(我这个是8.0)源码，其实在 android 3.0 之后 AsyncTask 都是采用串行执行任务的。 各个版本的不同如下：android 1.6之前 —— 串行android 1.6-3.0 之间 —– 并行android 3.0 之后 —– 串行 尽管如此，我们仍然可以通过 调用 executeOnExecutor 来并行执行任务。 ok ， 回到那个 execute 方法中，我们说调用了 r.run 实际山就是 调用 mFuture.run 方法：上面我们展示过在 mFuture.run 方法中如下： 12345678910try &#123; //这里调用c.call 实际上就是调用 mWorker.call 方法//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; 最终调用mWorker.call 方法，而在 mWorker.call 方法中，我们完成一系列的任务，调用了 doInBackground onPostExecute 完成了整个的调用过程。 有的人可能已经注意到了 还差一个 onProgressUpdate 方法还没被调用，我们知道只有调用那个 publishProgress 方法的时候才能调用 onProgressUpdate ,那下面我们卡夏 publishProgress 方法：12345678@WorkerThread protected final void publishProgress(Progress... values) &#123; //如果没取消 if (!isCancelled()) &#123; //会发送一个 MESSAGE_POST_PROGRESS 的消息 getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; 123456789101112131415161718192021private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS://是他是他 就是他 //3. 调用了 onProgressUpdate 方法了 result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 会调用 AsyncTask 的 onProgressUpdate 方法了。结束。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Service 启动过程]]></title>
    <url>%2F2018%2F09%2F11%2FService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[看完 Activity 的启动过程，发现 Service 的启动过程相对来说就比较简单了。 要说起启动过程，就得从 startService 开始： 1.startService根据源码的跳转，发现跳转到 ContextWrapper 这个类中，代码如下：1234@Override public ComponentName startService(Intent service) &#123; return mBase.startService(service); &#125; 其中 mBase 是类型是：Context 类型，如下：1234public class ContextWrapper extends Context &#123; Context mBase; ......&#125; 而我们又知道 Context 是一个抽象类 ，实现者是 ContextImpl ,所以我们应该是查看ContextImpl 这个类中的 startService(service) 方法。 ContextImpl 中的方法定义如下：12345@Override public ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser); &#125; 在 startService 中又调用了 startServiceCommon(service,(requirForeground:false),mUser) 这个方法，继续跟进： 2.startServiceCommonstartServiceCommon 方法如下：1234567891011121314151617181920212223242526272829private ComponentName startServiceCommon(Intent service, boolean requireForeground, UserHandle user) &#123; try &#123; //校验要启动的service validateServiceIntent(service); service.prepareToLeaveProcess(this); ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(&quot;!&quot;)) &#123; throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123; throw new SecurityException( &quot;Unable to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123; throw new IllegalStateException( &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; 这里面有几个需要说明一下： ActivityManager.getService() 点进去查看12345678910111213141516/** * @hide */ public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 首先是返回的类型是 IActivityManager 类型，其中在create 方法中，拿到远程服务的Binder 对象，其中IActivityManager.Stub.asInterface(b) 不知道大家有没有想起AIDL 这就很熟悉了，就是拿到远程服务的代理对象：IActivityManager,通过代理对象调用远程的方法，是应用进程与服务进程通信的媒介，如果没猜错的话就是在ActivityManagerService 中实现了，查看ActivityManagerService 类：1234public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;.....&#125; 果然不出所料，AMS extend IActivityManager.Stub . mMainThread.getApplicationThread() 首先明白 mMainThread 是 ActivityThread 类的实例变量，通过getApplicationThread() 方法拿到一个 ApplicationThread 类的实例：1234public ApplicationThread getApplicationThread() &#123; return mAppThread; &#125; 而ApplicationThread 类定义如下：123private class ApplicationThread extends IApplicationThread.Stub &#123;.....&#125; 发现 ApplicationThread 是 ActivityThread 的一个内部类.并且实现了 IApplicationThread.Stub ,而我们又把这个类型传入给了AMS,相当于远程服务拿到了一个访问应用进程的代理，类型为：IApplicationThread 总结：到目前为止，客户端拿到了远程服务的代理（IActivityManager）, 服务端拿到了客户端的代理（IApplicationThread）,它们互相拿到各自进程的代理类，是它们进行进程间通信的基础。 ok ,我们回到最初那个地方：1234ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), requireForeground, getOpPackageName(), user.getIdentifier()); 通过前面的分析我们知道：ActivityManager.getService(). 实际就是 AMS 远程代理，最终在AMS 中完成，我们去 AMS 代码中查看下 startService 代码： 3.ActivityManagerService. startService1234567891011121314151617181920212223242526272829303132@Override public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(&quot;startService&quot;); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;); &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res; try &#123; // 又调用了startServiceLocked 方法 res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return res; &#125; &#125; startServiceLocked 方法很复杂，大概如下：1234567891011ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId) throws TransactionTooLargeException &#123;.....ServiceRecord r = res.record;//启动service的信息保存在 serviceRecord 中.... ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); return cmp;.....&#125; 内部又调用了：startServiceInnerLocked 方法 4.startServiceInnerLocked如下：123456ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;... String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);...&#125; 又调用： bringUpServiceLocked 5.bringUpServiceLocked1234567 private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123;....realStartServiceLocked(r, app, execInFg);&#125; 而后又调用了 realStartServiceLocked(r, app, execInFg); 6.realStartServiceLocked12345678private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; .... app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); ....&#125; 其中 app.thread 是 IApplicationThread 类型，就是远程调用客户端进程里的方法，scheduleCreateService ,而我们又知道 ApplicationThread 实现了 IApplicationThread，所以就查看 ApplicationThread 类中的 scheduleCreateService方法，前面我们说过ApplicationThread 是 ActivityThread 的一个内部类，查看： 7.ApplicationThread.scheduleCreateService12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s); &#125; 发现内部通过发送一个 CREATE_SERVICE 的消息，H 是 Handle,继续查看：handleMessage 方法 12345case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; 到 handleCreateService 中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name); //创建context ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); //创建Application Application app = packageInfo.makeApplication(false, mInstrumentation); //通过attach 方法，将context application ，service 连接起来 service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); //调用service oncreate方法 service.onCreate(); mServices.put(data.token, service); try &#123; ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to create service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125; service.onCreate(); ok ，调用了 onCreate 方法，至此，service的启动过程的就完成了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[TransitionDrawable]]></title>
    <url>%2F2018%2F08%2F16%2FTransitionDrawable%2F</url>
    <content type="text"><![CDATA[1.首先创建一个xml 在 drawable 目录下 transition_image 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/first" /&gt; &lt;item android:drawable="@drawable/two" /&gt;&lt;/transition&gt; 2.在xml中引用 1android:drawable="@drawable/transition_image" 3.在Activity中使用 123ImageView mImageView = (ImageView) findViewById(R.id.iv); TransitionDrawable transitionDrawable = (TransitionDrawable) mImageView.getDrawable(); transitionDrawable.startTransition(3000) 另外一种写法实现多张图片效果123TransitionDrawable transitionDrawable = new TransitionDrawable(new Drawable[]&#123;getResources().getDrawable(R.drawable.first),getResources().getDrawable(R.drawable.two)&#125;);mImageView.setImageDrawable(transitionDrawable);transitionDrawable.startTransition(3000);]]></content>
      <tags>
        <tag>两个Drawable之间淡入淡出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的爬坑之路]]></title>
    <url>%2F2018%2F07%2F05%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[近期由于项目需要，需要编写小程序，遇到一些问题，记录下来，也是给自己开发的一个总结。 1.关于模板 template在看完 官方文档 里的说明之后，我并没有成功使用，按照它那个设置完成后，一直说找不到，最后在知道，原来除了实例那些之外，还要在当前 wxml 中 import 进来。 1.先建一个 template 的文件夹，新建 wxml,根据具体的路径引入进来，例如：1&lt;import src=&quot;../template/line.wxml&quot; /&gt; 还有一个就是如果有相对应的 wxss文件，可在 app.wxss文件中引用，这样整个项目都不需要引用这个样式文件了。 注意：模板拥有自己的作用域，只能使用 data 传入的数据以及模版定义文件中定义的 模块。 2. 关于水平居中，垂直居中一开始感觉这啥玩意，不听话啊，让居中也不居中，就是不动啊，很是郁闷，后来发现了一些规律。 2.1 水平居中 首先如果是行内元素，例如 这样的，如果想水平居中，使用text-align:center 你会发现不好使啊，纹丝不动，原因是因为行内元素长度随内容变化，所以它不能让你在一行的中间，因为它的长度就是文字长度。 解决方案：可以换成view 控件，或者使用：display:block + text-align:center 其它元素可以使用123456======3个一起使用==========text-align:center;align-items:center;justify-content: center;==================margin:auto # 子容器在父容器中居中,单独使用 2.2 垂直居中1234//可使用如下display:flex;align-items:center;justify-content:center; 3.关于几个控件平分整个屏幕宽度问题 一开始我还想着获取屏幕的宽和高，然后再动态给控件设置具体的值，后来发现有更简单的做法 例如：像这样一行排四个 解决方案：设置控件的宽度为 ：25%，这样就自动平分啦。当然还有其它的方式，但是我认为百分比的这种写法感觉很直观。 4. flex 布局熟练掌握 flexbox 布局，可以更轻松的编写任何常见的布局，可以查看相关专业的文章。 未完待续…..]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin-可观察属性]]></title>
    <url>%2F2018%2F06%2F27%2FKotlin-%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[类似于观察者模式，当所监测的对象发生改变时，能够收到回调通知。 例如：我们监测一个变量：123456789var str: String by Delegates.observable("qianqian",&#123; property: KProperty&lt;*&gt;, oldValue: String, newValue: String -&gt; Log.i("xx","改变的属性名称：$&#123;property.name&#125; --- $&#123;oldValue&#125; -- $&#123;newValue&#125;" ) &#125;) //点击一个按钮，改变str的值 fun foo(view : View)&#123; str = "haha" &#125; 这时候我们会发现，当改变str 的值的时候，会打印信息，也就是收到回调：1改变的属性名称：str --- qianqian -- haha 再比如：检测对象里的其中一个属性：1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable("&lt;no name&gt;") &#123; prop, old, new -&gt; println("$old -&gt; $new") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "first" user.name = "second"&#125; 打印信息：12&lt;no name&gt; -&gt; firstfirst -&gt; second]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin let with run also apply区分]]></title>
    <url>%2F2018%2F04%2F28%2FKotlin-let-with-run-also-apply%E5%8C%BA%E5%88%86%2F</url>
    <content type="text"><![CDATA[apply它与其它特殊之处在于，它返回本省对象： 1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;&#125; 例如： 123456ArrayList&lt;String&gt;().apply &#123; add("qq") add("mi") &#125;.let &#123;//this-&gt;ArrayList本身 Log.i("xx","list==="+it) &#125; 打印结果： 1list===[qq, mi] 这里T 就是 ArrayList&lt;String&gt;() 返回对象本身，也就是ArrayList 内部是 this 还是 it 这个倒没什么，编辑器一般都会有提示，如图： apply 是 this , also 是 it run run: 1public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;&#125; 返回最后一行，传入block 返回 最后一行，例如： 1234567ArrayList&lt;String&gt;().run &#123; add("lala") add("kaka") this.get(1) &#125;.let &#123; Log.i("xx","返回：："+it) &#125; 打印： 1返回：：kaka let1public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;&#125; 也是返回最后一行，但是它内部不能调用对象的方法： 123456fun letGo(): Int&#123; "qianqian".let &#123; Log.i("xx",it) return 1 &#125; &#125; 调用letGO 返回 1 with类似于：apply + let 的结合 1public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;&#125; 例如： 1234567with(ArrayList&lt;String&gt;())&#123; add("haha") add("heihei") this//最后返回ArrayList对象 &#125;.let &#123; Log.i("xx","list==="+it)//打印：[haha,heihei] &#125;]]></content>
      <tags>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取手机屏幕的密度]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AF%86%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[目前有两种方式，一种是根据手机的分辨率计算，另外一种是通过代码获取。 第一种：根据手机分辨率进行计算(计算得出实际的dpi)比如我的手机魅族分辨率是：1920*1080，屏幕尺寸大小是：5.5寸的，那么计算：(宽的平方+高的平方之后开根号，最后除以屏幕的尺寸)dpi = (√1920^2+1080^2 ) / 5.5 ≈ 401 参照下图： ldpi（低）~120dpi density=0.75 mdpi（中）~160dpi density=1 hdpi（高）~240dpi density=1.5 xhdpi（超高）~320dpi density=2 xxhdpi（超超高）~480dpi density=3 xxxhdpi（超超超高）~640dpi density=4 对应图片的目录应该是：xxhdpi 第二种：通过代码方式(系统定义的dpi)12float xdpi = getResources().getDisplayMetrics().xdpi;float ydpi = getResources().getDisplayMetrics().ydpi; 不同手机获取的xdpi ydpi 值有的一模一样，有的有些差异，但是相差不会太大，两者获取的值近乎一样。 两者计算出的结果并不完全相同，因为你们想，实际计算得出的dpi 很容易根据屏幕尺寸的不同，得出不同的dpi ，这样的话得到的值很多，无法适配。我查阅网上相关介绍，就是每个手机初始有一个固定的dpi ，分别是上述的：120，160，240，320，480，640，安卓实际进行缩放的时候按照的是系统定义的这些，而不是实际计算得出的dpi,这一点需要注意。]]></content>
      <tags>
        <tag>dpi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus 为什么订阅的方法必须是public？]]></title>
    <url>%2F2018%2F04%2F08%2FEventBus-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A2%E9%98%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在看了源码之后发现是这样的：12345678910111213141516171819202122232425262728293031323334353637383940private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities //获取所有声明的方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; //获取方法的标识符 int modifiers = method.getModifiers(); //方法的标识符必须是public if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; //否则抛出异常 ，说这个方法必须加上@Subscribe ,并且是public 的，不能是静态的，抽象的 String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125; &#125; 然后就没有然后了，之前怀疑private 修饰的方法，反射后不能被其他类调用，后来查了相关资料，发现可以，后来去网上寻找无果，后来在我微信关注的公众号里，群主伯特说：虽然可以反射调用private 的方法，但是必须通过setAccess来修改访问权限。说是修改，实则破坏了java中的作用域，迫不得已不推荐这么做。EventBus 作为三方库，显然不会在你设置为private 时，好心办坏事，强制访问。 仅此而已，仅此而已。分享给还不知道的童鞋。]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity状态保存与恢复]]></title>
    <url>%2F2018%2F03%2F23%2FActivity%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Activity状态保存与恢复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件是什么与它们的生命周期（及Fragment）]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%8F%8AFragment%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先当我们一开始学习安卓的时候想必就是四大组件了以及它们的生命周期，现在就来复习回想下。 四大组件有：Activity, ContentProvider, BroadcastReceiver, Service Activity 提供与用户交互的界面或者可以说是一个窗口 下面我是从官方文档中关于Activity生命周期 的一张图 正常启动时：onCreate() -&gt; onStart() -&gt; onResume() 而后我们看到当 Another activity comes into the foreground 执行 onPause() 方法当按 home 键的时候： 当前Activity 已经不可见了，所以执行：onPause() -&gt; onStop() 当重新回到app时，分为两种情况就是：①是app还在后台，执行：onRestart() -&gt; onStart() -&gt; onResume(); ②是app被系统杀死了，则执行：onCreate() -&gt; onStart() &gt; onResume() 当在app 里 从 A -&gt; B 此时A隐藏，B显示，当重新返回A 时，执行：onPause() -&gt; onResume(),这种应用场景一般是比如需要返回做刷新操作的，可以将刷新方法写在onResume() 方法中执行。 最后当退出应用程序的时候执行 onDestroy() Service 服务，有前台服务和后台服务，一般提供需在后台长期运行的服务，例如：音乐播放器等 它的生命周期如下图： 因为启动服务的方法有两个：startService() 和 bindService() 两者的生命周期略有不同。 首先来看：startService() 方式启动：onCreate() -&gt; onStartCommand() 调用stopServcie() 停止服务，随后执行 onDestroy() 其次是：bindService() 方式启动：onCreate() -&gt; onBind() 服务启动起来了，调用unbindService() 停止服务，随后执行 onUnbind() -&gt; onDestroy() Broadcastreceiver 广播，可以接受来自应用内或者应用外的广播，分为两个角色：广播发送者，广播接收者 广播的注册方式有两种：一种是代码注册，一种是清单文件注册，代码注册的优先级要比清单文件注册的优先级要高； 广播的发送可以是有序广播也可以是无序广播，有序广播接收到广播的顺序按照优先级的顺序； 注意广播接收器onReceive() 方法运行在 UI 线程中，不可以做耗时操作，否则会导致ANR异常； ContentProvider 内容提供者，应用内数据共享 Fragment 一般和 viewpager 配合使用，不能单独使用，要配合Activity使用，但是有自己的生命周期 一般在onAttach()中获取参数值一些，onCreateView()中创建布局，布局加载完成后在onActivityCreated()中执行一些初始化操作，随后onStart(),onResume().onPause(),onStop(), fragment 销毁，onDestroyView() -&gt; onDestroy() -&gt;onDetach()]]></content>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点总结]]></title>
    <url>%2F2018%2F03%2F22%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[网上别人列出一些来，我把它拿过来了，需要自己一项一项复习查阅，以后有会继续添加新的，特此总结。 四大组件是什么与它们的生命周期（及Fragment）; Acitivty的四种启动模式与特点。 获取手机屏幕的密度 Activity状态保存与恢复。 Service的生命周期，启动方法，有什么区别。 service和activity怎么进行数据交互。 怎么保证service不被杀死。 广播使用的方式和场景以及广播的几种分类。 Intent的使用方法，可以传递哪些数据类型。 ContentProvider使用方法。 ContentProvider、ContentResolver、ContentObserver 之间的关系。 Thread、AsycTask、IntentService的使用场景与特点。 FrameLayout 、 LinearLayout 、 RelativeLayout 各自特点及绘制效率对比。 Android的数据存储形式。 Android两种序列化的区别和作用。 Sqlite的基本操作。 Android中的MVC、MVP模式。 Merge、ViewStub的作用。 动画有哪几类，各有什么特点？ Handler、Loop消息队列模型，各部分的作用。 Android的消息机制，子线程更新UI的方法和原理。 Android怎么加速启动Activity。 App的启动过程。 Android优化方法。 如何防止内存泄漏？ Android中弱引用与软引用的应用场景。 Bitmap的四种属性，如何加载大图（inJustDecodeBounds）。 View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。 View刷新机制和绘制流程。 Activity、Window、View的联系和理解。 invalidate和requestLayout的区别及使用。 Touch事件分发机制和冲突处理。 Android IPC:Binder原理。 Android5.0（UI库）、6.0（权限）、7.0特性、8.0特性。]]></content>
      <tags>
        <tag>Android知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 传递数据]]></title>
    <url>%2F2018%2F03%2F14%2FKotlin-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[今天在掘金看到使用 Kotlin 高阶函数传递Intent 数据很简洁，觉着可以试试，并应用到项目中去，自己再加以理解，记录笔记，方便查阅。掘金原文章地址：https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw 传统的Intent 数据传递我就不介绍了，只介绍Kotlin实现方式：123456789101112131415161718192021//目标 假设叫`KTestActivity4` 定义 object IntentOptions&#123; private const val MSG_KEY = "key for message" var Intent.message: String? get() = getStringExtra(MSG_KEY) set(message) &#123; putExtra(MSG_KEY,message) &#125; &#125;//跳转时 with(KTestActivity4.IntentOptions)&#123; intent = Intent(this@KTestActivity5,KTestActivity4::class.java) intent.message = "I am KTestActivity5" startActivity(intent) &#125;//使用with(IntentOptions)&#123; var message= intent.message Toast.makeText(this@KTestActivity4,"显示信息："+message,Toast.LENGTH_SHORT).show() &#125; 假设有多个数据传递：1234567891011121314151617181920212223object IntentOptions&#123; private const val MSG_KEY = "key for message" private const val MSG_ID = "ID for message" var Intent.message: String? get() = getStringExtra(MSG_KEY) set(message) &#123; putExtra(MSG_KEY,message) &#125; // 再多增加一条即可 var Intent.id: String? get() = getStringExtra(MSG_ID) set(id) &#123; putExtra(MSG_ID,id) &#125; &#125;// 传递时with(KTestActivity4.IntentOptions)&#123; intent = Intent(this@KTestActivity5,KTestActivity4::class.java) intent.message = "I am KTestActivity5" intent.id = "I am id" startActivity(intent) &#125; 还有另外一种传递方式：委托机制，不是特别明白。国外大神封装的github地址：https://github.com/Takhion/android-extras-delegates]]></content>
      <tags>
        <tag>Kotlin#Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴Android开发手册]]></title>
    <url>%2F2018%2F03%2F13%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Android%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[摘自阿里巴巴Android开发手册 强制要求的 1. Activity 间的数据通信，对于数据量比较大的，避免使用 intent + Parcelable 的方式，可以考虑 EventBus等替代方案，以免造成 TransationTooLargeException 2. Activity 间通过隐士 Intent的跳转，在发出 Intent 之前必须通过 resolveActivity 检查，避免找不到合适的调用组件，造成 ActivityNotFoundException 的异常。 12345678910 public void viewUrl(String url, String mimeType) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(Uri.parse(url), mimeType); if (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123; startActivity(intent); &#125;else &#123; // 找不到指定的 Activity &#125;&#125; 而不应该：1234567Intent intent = new Intent();intent.setAction("com.example.DemoIntent ");try &#123; startActivity(intent);&#125; catch (ActivityNotFoundException e) &#123; e.printStackTrace();&#125; 3. 避免在Service#onStartCommand/onBind()方法中执行耗时操作，如果确实有需求，应采用IntentService 或采用其他异步机制完成。正例： 12345678910111213141516171819202122232425public class MainActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; public void startIntentService(View source) &#123; Intent intent = new Intent(this, MyIntentService.class); startService(intent); &#125;&#125;public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService"); &#125; @Override protected void onHandleIntent(Intent intent) &#123; synchronized (this) &#123; try &#123;...... &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; 4. 避免在 BroadcastReceive#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService完成，而不应该在BroadcastReceiver 内创建子线程去做。 说明：由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅，可以使用 IntentService,创建 HanlderThread 或者调用 Context#registerReceiver(BroadcastReceiver,IntentFitter,String,Handler) 方法等方式，在其他 Worker 线程执行 onReceive.BroadcastReceiver#onReceive() 方法耗时超过10秒钟，可能会被系统杀死。正例： 1234567891011IntentFilter filter = new IntentFilter();filter.addAction(LOGIN_SUCCESS);this.registerReceiver(mBroadcastReceiver, filter);mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; Intent userHomeIntent = new Intent(); userHomeIntent.setClass(this, UserHomeService.class); this.startService(userHomeIntent); &#125;&#125;; 反例：123456789mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; MyDatabaseHelper myDB = new MyDatabaseHelper(context); myDB.initData(); // have more database operation here &#125;&#125;; 5. 避免使用隐士 Intent 广播敏感信息，信息可能被其他注册了对应 BroadcastReceiver 的App接收。 说明：通过Context#sendBroadcast()发送的隐士广播会被感兴趣的 receiver 接收，恶意应用注册监听该广播的 receiver可能会获取到 Intent 中传递的敏感信息，并进行其他危险操作。如果发送的广播为使用 Context#sendOrderedBroadcast()方法发送的有序广播，优先级较高的恶意 receiver可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。 如果广播仅限于应用内，则可以是iyongLocalBroadcastManager#sendBroadcast()实现，避免敏感信息外泄和intent拦截的风险。 正例：123Intent intent = new Intent("my-sensitive-event");intent.putExtra("event", "this is a test event");LocalBroadcastManager.getInstance(this).sendBroadcast(intent); 反例：1234567891011Intent intent = new Intent();v1.setAction("com.sample.action.server_running");v1.putExtra("local_ip", v0.h);v1.putExtra("port", v0.i);v1.putExtra("code", v0.g);v1.putExtra("connected", v0.s);v1.putExtra("pwd_predefined", v0.r);if (!TextUtils.isEmpty(v0.t)) &#123; v1.putExtra("connected_usr", v0.t);&#125;context.sendBroadcast(v1); 以上广播可能被其他应用的如下 receiver 接收导致敏感信息泄露：12345678910111213final class MyReceiver extends BroadcastReceiver &#123; public final void onReceive(Context context, Intent intent) &#123; if (intent != null &amp;&amp; intent.getAction() != null) &#123; String s = intent.getAction(); if (s.equals("com.sample.action.server_running") &#123; String ip = intent.getStringExtra("local_ip"); String pwd = intent.getStringExtra("code"); String port = intent.getIntExtra("port", 8888); boolean status = intent.getBooleanExtra("connected", false); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>阿里巴巴Android开发手册规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听键盘显示与隐藏]]></title>
    <url>%2F2018%2F03%2F08%2F%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[项目中有时候需要监听keyboard的显示与隐藏，特此备注，方便使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class KeyboardWatcher &#123; private ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener; private View rootView; private int viewSize = -1; private boolean isShowing = false; private OnKeyboardListener onKeyboardListener; public KeyboardWatcher(Activity activity)&#123; rootView = activity.getWindow().getDecorView().getRootView(); &#125; public KeyboardWatcher register(OnKeyboardListener listener)&#123; onKeyboardListener = listener; if(onGlobalLayoutListener == null) &#123; onGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect r = new Rect(); rootView.getWindowVisibleDisplayFrame(r); int viewHeight = r.bottom - r.top; if(viewSize &lt; 0)&#123; viewSize = viewHeight; return; &#125; if(viewHeight != viewSize)&#123; // 大于100dp才算变化 if(Math.abs(viewHeight - viewSize) &gt; dpToPx(rootView.getContext(),100)) &#123; if (viewHeight &lt; viewSize &amp;&amp; !isShowing) &#123; onKeyboardListener.onShow(viewHeight); isShowing = true; &#125; else if(isShowing)&#123; onKeyboardListener.onHide(); isShowing = false; &#125; &#125; viewSize = viewHeight; &#125; &#125; &#125;; &#125; rootView.post(new Runnable() &#123; @Override public void run() &#123; viewSize = rootView.getHeight(); rootView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener); &#125; &#125;); return this; &#125; public void unRegister()&#123; rootView.getViewTreeObserver().removeGlobalOnLayoutListener(onGlobalLayoutListener); rootView = null; &#125; public interface OnKeyboardListener&#123; void onShow(int viewSize); void onHide(); &#125; private int dpToPx(Context context,int dp) &#123; return (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, dp, context.getResources().getDisplayMetrics() ); &#125;&#125; 使用方法1234KeyBoardWatcher keyboardWatcher = new KeyboardWatcher()keyboardWatcher.register(this)//实现KeyboardWatcher.OnKeyboardListener接口//实现方法onShow() , onHide(),对应键盘的显示与隐藏]]></content>
      <tags>
        <tag>keyboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment 懒加载]]></title>
    <url>%2F2018%2F02%2F28%2FFragment-%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[因为项目中经常用到tabLayout + viewpager 结合使用，页面切换时要用到延迟加载的情况，所以单独写出一个demo，方便查看和便于使用 1.首先新建一个BaseLazyFragment/** * Created by xuqianqian on 2018/2/28. */ public abstract class BaseLazyFragment extends Fragment { protected View mRootView; public Context mContext; protected boolean isVisible; private boolean isPrepared; private boolean isLoad = false; //最先执行 @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (getUserVisibleHint()) {//当前显示 isVisible = true; if(!isLoad){ lazyLoad(); } } else { isVisible = false; //onInvisible(); } } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mContext = getActivity(); setHasOptionsMenu(true); } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { if (mRootView == null) { mRootView = getLayout(); } return mRootView; } @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); isPrepared = true; //如果已经加载过了，就无需再重新加载 if(!isLoad){ lazyLoad(); } } /** * 懒加载 */ protected void lazyLoad() { if (!isPrepared || !isVisible) { return; } isLoad = true; initData(); } // protected void onInvisible() { // // } //初始化布局View public abstract View getLayout(); public abstract void initData(); } 2.让你的fragment extend BaseLazyFragmentpublic class GankFragment extends BaseLazyFragment { String type; public static GankFragment newInstance(String type) { GankFragment gankFragment = new GankFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;type&quot;, type); gankFragment.setArguments(bundle); return gankFragment; } //加载布局 @Override public View getLayout() { type = getArguments().getString(&quot;type&quot;); TextView tv = new TextView(getActivity()); tv.setText(type); tv.setGravity(Gravity.CENTER); return tv; } @Override public void initData() { //初始化一些控件，加载网络数据 } } 3.剩下的就是FragmentPagerAdapter了public class TitleAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragments; private List&lt;String&gt; types; public TitleAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments, List&lt;String&gt; types) { super(fm); this.fragments = fragments; this.types = types; } @Override public Fragment getItem(int position) { return fragments.get(position); } @Override public int getCount() { return fragments.size(); } @Override public CharSequence getPageTitle(int position) { return types.get(position); } } MainActivity.java private List&lt;String&gt; titles = new ArrayList&lt;&gt;(); private List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;(); TitleAdapter titleAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TabLayout tablayout = findViewById(R.id.tablayout); ViewPager viewpager = findViewById(R.id.viewpager); titles.add(&quot;android&quot;); titles.add(&quot;ios&quot;); titles.add(&quot;web&quot;); titles.add(&quot;java&quot;); fragments.add(GankFragment.newInstance(&quot;android&quot;)); fragments.add(GankFragment.newInstance(&quot;ios&quot;)); fragments.add(GankFragment.newInstance(&quot;web&quot;)); fragments.add(GankFragment.newInstance(&quot;java&quot;)); titleAdapter = new TitleAdapter(getSupportFragmentManager(), fragments, titles); viewpager.setAdapter(titleAdapter); tablayout.setTabMode(TabLayout.MODE_FIXED); tablayout.setupWithViewPager(viewpager); } https://github.com/QQabby/LazyFragmentApplication]]></content>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog]]></title>
    <url>%2F2018%2F02%2F28%2FDialog%2F</url>
    <content type="text"><![CDATA[快速初始化materialDialognew MaterialDialog.Builder(mContext) .title(&quot;title&quot;) .content(&quot;I&apos;m a content&quot;) .negativeText(&quot;cancel&quot;) .negativeColorRes(R.color.colorNegative) .positiveText(&quot;ok&quot;) .positiveColorRes(R.color.colorPositive) .onPositive(new MaterialDialog.SingleButtonCallback() { @Override public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) { showMsg(&quot;click dialog ok&quot;); ... } }) .show();]]></content>
      <tags>
        <tag>materialDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序速查笔记]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这个微信小程序也出来好长时间了，一直想做一个属于自己的小程序，这不说动手就动手实现一个吧，比较简易，中间也遇到不少问题，记录一下，方便以后自己查阅。 微信小程序的结构 默认没有这么些文件夹的，只有index ，然后这个标识 app 开头的文件都是一些全局的设置。可以自己查看下，都有注释，就从这个配置开始说。 修改启动页面默认启动页面是index页面，如果要修改，打开app.json配置文件，在顶部你会发现有一个pages的配置，如下： &quot;pages&quot;: [ &quot;pages/home/home&quot; 只需要将我们的想要显示的页面的路径写在 第一个 就可以成为启动页，特别注意路径一定要正确。 当然你会新建很多页面，所有的页面都必须写在这个里面，不然跳转的时候会找不到。 底部tab栏切换就是底部tab栏切换,同样还是在app.json 配置文件中修改如下： &quot;tabBar&quot;: { &quot;color&quot;: &quot;#333333&quot;, &quot;selectedColor&quot;: &quot;#2B91D8&quot;, &quot;backgroundColor&quot;: &quot;#eee&quot;, &quot;borderStyle&quot;: &quot;white&quot;, &quot;list&quot;: [ { &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_home_nor.png&quot;, &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_home_pre.png&quot; }, { &quot;pagePath&quot;: &quot;pages/myCenter/myCenter&quot;, &quot;text&quot;: &quot;我的&quot;, &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_center_nor.png&quot;, &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_center_pre.png&quot; } ] }, 这里的 pagePath 就是页面的路径，text文字，iconPath图标，注意图片一定要带后缀，selectedIconPath点击态的图标，各自换成你自己的就行，问题不会太大。 加载中如下： 有标签可以直接显示这个,在wxml文件中编写： &lt;loading hidden=&quot;{{hidden}}&quot; bindchange=&quot;loadingChange&quot;&gt; 加载中... &lt;/loading&gt; 可以控制显示还是隐藏，在.js文件中可以控制： data: { hidden: false, } 可以在data 底下配置默认值，hidden: false 默认不显示，赋值的时候必须在这里面写： that.setData({ hidden: true }) 网络请求 wx.request({ //网络请求地址url url: &apos;https://xx&apos;, header: { // &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &apos;content-type&apos;: &apos;application/json&apos; // &apos;content-type&apos;: &apos;text/xml&apos; }, //请求头参数配置 data: { page: pageNo, timestamp: timeStamps }, method: &quot;POST&quot;, success: function (res) { //xmlstring2json 是我使用第三方xml转json的一个库 var xml2json = require(&apos;..//lib/xmlstring2json/dist/xml2json&apos;); var json = JSON.stringify(xml2json(res.data), null, 4); var jsonObject = xml2json(res.data); var jokeObject = jsonObject.root.joke //timestamp if(pageNo == 0){ timeStamps = jsonObject.root.timestamp.text } // console.log(&apos;json::&apos; + jsonObject.root.timestamp.text) // var data = new Array(); // for (var i = 0; i &lt; jokeObject.length;i++){ // var text = JSON.stringify(jokeObject[i].text).replace(&quot;#&quot;, &quot;&quot;) // //JSON.parse(text).text // var value = JSON.parse(text).text; // data.push(value) // } // console.log(&apos;data::：&apos; + jokeObject[0].text.text ); // var l = jokeObject; var l; if(pageNo == 0){ l = jokeObject }else{ var l = that.data.list; for (var i = 0; i &lt; jokeObject.length; i++) { l.push(jokeObject[i]) } } //页面绑定的数据赋值 that.setData({ list: l }) pageNo++ that.setData({ hidden: true }) }, fail : function(s){ wx.showModal({ title: &apos;提示&apos;, content: &apos;请求接口失败&apos; + JSON.stringify(s) }) } 要进行网络请求，首先测试阶段可以将开发工具里的： 最后一个选项勾选上，不校验…,同时管理员还需在后台配置网络请求的域名，两个缺一不可。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给TextView上的drawable上的图片添加动画？]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%A6%82%E4%BD%95%E7%BB%99TextView%E4%B8%8A%E7%9A%84drawableEnd%E7%AD%89%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[可能你遇到过这样的场景，就是在 xml 里，给TextView添加了一个drawableLeft或者drawableRight等，你想给这个图片添加一个动画，然而你会发现当你给这个TextView加动画吧并不是我们想要的，我们只想要那个图片做动画，文字不需要做任何动画，目前可以有两种做法。 第一种做法 也是比较通俗的方法，说这个drawable 单独弄成ImageView不就好了，在xml里新增一个ImageView 是吧，干嘛非要加在一个标签里面，要相信布局都是很强大的，肯定可以实现效果。 第二种做法 你说真的没办法，必须写在一个里面，也是有办法的，那就不能在xml里设置drawableLeft了，代码设置，如下： 123AnimationDrawable d = (AnimationDrawable) getResources().getDrawable(R.drawable.animation_draw); d.setBounds(0,0,d.getIntrinsicWidth(),d.getIntrinsicHeight()); messageText.setCompoundDrawables(d, null, null, null); 这个具体的动画在这个animation_draw里，如下： 12345678&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot; &gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot; android:duration=&quot;500&quot; /&gt;&lt;/animation-list&gt; 这是一个帧动画，里面可以放很多的item,从而形成动画,碰到了这种情况记录下，方便以后查阅。]]></content>
      <tags>
        <tag>add animation to drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O 新特性 AutoSizing]]></title>
    <url>%2F2018%2F01%2F16%2FAndroid-O-%E6%96%B0%E7%89%B9%E6%80%A7-AutoSizing%2F</url>
    <content type="text"><![CDATA[自动调整TextView的大小的使用autoSizing Android 8.0允许根据TextView的大小自动设置文本展开或收缩的大小,这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。 在之前看 文字太多？控件太小？试试 TextView 的新特性 Autosizing 吧！ 作者写到关于这个属性的所有用法，在这里我就不多说什么了，用法其实挺简单，关键是我在用的时候遇到了一些小问题，导致一直出不来。 官方文档 点击即可查看，可以看别人讲解的同时也可自行查阅文档，双方对比着看，感觉会好一点。 如下图可以简单明了的说明该特性： 具体最简单的使用有两种： 1.一种就是api &gt;= api 26的可以直接在xml里面该属性：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:autoSizeTextType=&quot;uniform&quot; /&gt; 在此需要注意的是：使用这个autoSizeTextType的时候，控件的layout_width layout_height 不能使用这个wrap_content否则看不出什么效果，要使用具体可衡量的。这个也不难理解，因为它要计算，你设置一个模糊的宽和高，就算不出来了。 2. api&lt;26 的低设备 的兼容写法 官方文档里也明确说明了兼容低版本The library provides support to Android 4.0 (API level 14) and higher. 也就是兼容到4.0以上，写法有些不同，如下：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; tools:ignore=&quot;MissingPrefix&quot; app:autoSizeTextType=&quot;uniform&quot; /&gt;&lt;/LinearLayout&gt; 这个app是这个xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 我们在自定义控件的时候经常遇到它，tools是这个xmlns:tools=&quot;http://schemas.android.com/tools&quot; 当然以上写法都支持动态编码，具体可查阅文档 敲黑板重点你会发现你写完之后编译是报错的，错误类似是这样的： 找不到！！！ 在写那篇文章作者的帮助下，发现首先要兼容低版本，module 的 build.gradle 文件添加依赖时候 就是这个com.android.support:appcompat-v7:xx 后面的版本号要26以上，你看看你自己项目里有哪个版本你就写上哪个，还要在project 的 build.gradle 文件里添加：maven{ url &#39;https://maven.google.com&#39; }添加到对应的位置123456789allprojects &#123; repositories &#123; jcenter() //添加如下内容 maven&#123; url &apos;https://maven.google.com&apos; &#125; &#125;&#125; 至此我发现我的项目终于不报错了，可以运行起来并进行下一步的实践操作了，大家如果在项目中也遇到这样的问题，按我那样改应该没啥问题了，顺便把我写的代码上传到github 上了，又需要的可以下载看看：demo 另外在查看 Android O新特性中发现一个比较好玩的东西：现在，findViewById() 函数的全部实例均返回 T，而不是 View。以后就可以这么写啦：1EditText et = findViewById(R.id.et); 就是那样，无需强转了，当然了使用了Kotlin的话就忽略吧，因为Kotlin连findViewById也不用写，哈哈。更多好玩特性可查看 文档。]]></content>
      <tags>
        <tag>Android O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改自动生成get/set方法模板代码]]></title>
    <url>%2F2018%2F01%2F11%2F%E4%BF%AE%E6%94%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get-set%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天看到面对接口脏数据你还在V层if str==null else setText? 一文，觉着写得挺好，开发过程中多思考多动手，会带来意想不到的效果。底下评论大家也都说了各自的方法和见解，文中有一些问题作者后来也解决了，看到评论里有人说： 说到配置as,就可以实现在创建bean时自动生成return xx==null?&quot;&quot;:xx; 觉着很好，因为我觉着这是一种挺简单的方法，但是就如同底下人问了怎么配置呀，我也不知道，于是我就在自己as工具里新建了一个bean对象，按住alt+insert添加get/set方法，发现了解决办法。如下图： 平时手快也没注意，今天仔细看了看，那上面的意思不就是，get 方法模块，set方法模板吗，后面跟着 IntelliJ Default大概就是默认的生成模板吧，点击后面的三个点按钮进去看看，如下： 这是set的，get方法也类似是这样的，大概也能看懂，想着是不是可以直接模板就好了，发现无法修改，后来又发现左上角的+号，原来是自己可以新建一个模板，然后再生成的时候选择自己的模板就好了，如我们在get模板中新建一个自己的模板： 我们知道我们只需要改一下最后get方法return那个地方的代码，也就是这儿： 不确定是不是，我们可以在后面跟着一个“#”号试试：123$&#123;name&#125;() &#123; return $field.name+&quot;#&quot;;&#125; 在生成的时候选择我们自定义的模板： 发现最后生成的代码：1234567public String getAge() &#123; return age + &quot;#&quot;;&#125;public void setAge(String age) &#123; this.age = age;&#125; 这样证明确定是这样的，那么我么可以继续进行真正的判断了：我们先把这个默认里的get方法代码拷贝到 MyGetter中，我们再根据我们自己的需要修改模板代码,其它地方不变，就修改需要修改的地方：我们想要实现这样的：return xx==null?&quot;&quot;:xx,Ok ，那么我认为大概是这么写的，首先判断是否是字符串：12345678$&#123;name&#125;() &#123; #if(field.String)&#123; return $field.name == null ? &quot;&quot; : $field.name; &#125; #else return $field.name; #end &#125; 我们对比一个default的写法：123$&#123;name&#125;() &#123; return $field.name;&#125; 好的，我们再继续生成一下：1234567public String getAge() &#123; return age == null ? &quot;&quot; : age; &#125; public void setAge(String age) &#123; this.age = age; &#125; 好的，达成效果，耶，居然还可以这么玩，以后可根据自己需求自行修改，谢谢大家。]]></content>
      <tags>
        <tag>get/set.template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2018%2F01%2F09%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[● standard 标准模式​ 简述：对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。例如：A启动A，A再接着启动A,A再接着启动A,，然后再分别出栈，如图所示：​ ● singleTop简述：当活动的启动模式指定为 singleTop ,在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。例如：如果快速点击一个按钮，进入Activity，要保证启动的Activity不为多个，可以使用将Activity的启动模式改为 singleTop，就不会启动多个了。如图所示：​ ● singleTask简述：当活动的启动模式指定为singleTask，每次启动该活动时候，它会先在系统中查找属性值taskaffinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，他就会这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了“singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。 如果设置了“singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 当栈底部的 A 重新被启动打开时，会执行onNewIntent() onStart() 方法。 使用场景：应用主页面一般是 singleTask ● singleInstance（单独任务栈）简述：使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都会共用同一个返回栈，也就解决了共享活动实例的问题。​ 返回的页面顺序是：C-B-A]]></content>
      <tags>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL实例]]></title>
    <url>%2F2018%2F01%2F08%2FAIDL%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[说到进程间通信，一般首先就会想到AIDL，也看了很多文章，做下笔记，记录一下，方便以后查阅。 对于 AIDL 我是这样理解的，首先进程间是无法通信的，那要通信就得有一个媒介或者说两个进程有统一对外的接口可以相互识别，从这个 AIDL全程的名字Android Interface Definition Language (android 接口定义语言) 来看不难看出它就是我们进程间通信的媒介，它可以实现我们想要的通信。 在翻阅网上各类文章的讲解后，我认为一个比较好的实例可以更好理解这个东西，具体如下： 第一步我们新创建两个module，代表我们两个进程，进程名称默认就是我们程序的包名： 第二步我们先编写service这个module里的代码，先定义一个 Person的一个bean对象，记住一定要implements Parcelable 接口，大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041public class Person implements Parcelable &#123; private String mName; public Person(String name) &#123; mName = name; &#125; protected Person(Parcel in) &#123; mName = in.readString(); &#125; public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel in) &#123; return new Person(in); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(mName); &#125; @Override public String toString() &#123; return "\nPerson&#123;" + "mName='" + mName + '\'' + '&#125;'; &#125;&#125; 然后我们再新建一个文件夹：aidl,新建一个包名和Person类一模一样的包名和与之对应的aidl,还有一个我们对外提供获取person集合的一个aidl: 在Person.aidl里，我们序列化我们java里的 Person 类： 12345package com.example.service.bean;//还要和声明的实体类在一个包里，同时注意不要新建aidl文件，因为你会发现，新建不了，//提示你名称唯一，此时你新建一个file,名字为Person.aidl就可以，需要特别注意下parcelable Person; IMyAidl.aidl 文件提供对外方法：12345678910111213141516// IMyAidl.aidlpackage com.example.service.bean;//特别注意一定要手动导包，不会自动导包import com.example.service.bean.Person;// Declare any non-default types here with import statements//可以理解为通信媒介interface IMyAidl &#123; /** * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出) */ void addPerson(in Person person); List&lt;Person&gt; getPersonList();&#125; 然后在我们的java文件里，新建一个MyAidlService,123456789101112131415161718192021222324252627282930313233343536373839public class MyAidlService extends Service &#123; private final String TAG = this.getClass().getSimpleName(); private ArrayList&lt;Person&gt; mPersons; /** * 创建生成本地的binder ,实现AIDL的方法 */ private IBinder mIBinder = new IMyAidl.Stub()&#123; @Override public void addPerson(Person person) throws RemoteException &#123; mPersons.add(person); &#125; @Override public List&lt;Person&gt; getPersonList() throws RemoteException &#123; return mPersons; &#125; &#125;; /** * 客户端与服务端绑定时的回调，返回IBinder对象后客户端就可以通过它远程调用服务端的方法，即实现了通讯 * @param intent * @return */ @Nullable @Override public IBinder onBind(Intent intent) &#123; mPersons = new ArrayList&lt;&gt;(); return mIBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; 最后别忘了在清单文件中注册MyAidlService1234&lt;service android:name="com.example.service.MyAidlService" android:enabled="true" android:exported="true" /&gt; 到此，我们完成了service端的工作： 第三步将我们刚才创建好的aidl文件夹拷贝到 app module下main文件夹下，在MainActivity中绑定服务，123Intent intent = new Intent(); intent.setComponent(new ComponentName("com.example.service","com.example.service.MyAidlService")); bindService(intent,mConnection,BIND_AUTO_CREATE); 其中这个mConnection可以让我们拿到IMyAidl对象的代理123456789101112private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mAidl = IMyAidl.Stub.asInterface(iBinder); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mAidl = null; &#125; &#125;; 通过返回的IBinder 拿到这个IMyAidl，此时我们就可以通信了，例如我们调用IMyAidl中的addPerson方法，再调用getPersonList看看：1234567891011Random random = new Random(); Person person = new Person("qian"+random.nextInt(20)); try&#123; mAidl.addPerson(person); List&lt;Person&gt; mPersons = mAidl.getPersonList(); tvName.setText(mPersons.toString()); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; 打印发现list 返回了我们添加的Person，完成了app与service两个进程间的通信。demo地址：https://github.com/QQabby/AIDLDemo]]></content>
      <tags>
        <tag>AIDL实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文件相关]]></title>
    <url>%2F2017%2F12%2F28%2F%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[向sd卡根目录中写入文件123456789101112//首先判断是否存在sd卡if(Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED))&#123; //获取外部设备 File file=new File(Environment.getExternalStorageDirectory(),"qianqian.txt"); FileOutputStream outStream=new FileOutputStream(file); //写入文件 outStream.write(content.getBytes()); outStream.close(); &#125; 读取assets下的文件路径123//格式如下file:///android_asset/myVideo.htmlfile:///android_asset/xx(文件名称) 读取assets下的文件转化为String123456789101112131415public String getFromAssets(String fileName) &#123; try &#123; InputStreamReader inputReader = new InputStreamReader( getResources().getAssets().open(fileName)); BufferedReader bufReader = new BufferedReader(inputReader); String line = ""; String Result = ""; while ((line = bufReader.readLine()) != null) Result += line; return Result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125;]]></content>
      <tags>
        <tag>向sd卡写入文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU算法还一知半解？]]></title>
    <url>%2F2017%2F12%2F19%2Flru%2F</url>
    <content type="text"><![CDATA[某年某月某日，糖葫芦同学在掘金app上看了几篇文章，偶然看到了一篇熟悉的词LRU算法，脑海里就想这不是经常说的嘛，就那么回事，当天晚上睡觉，LRU算法是啥来着，好像是什么最近最少使用的，白天在地铁上看的文章也不少，但是到晚上想想好像啥也没记住，就记得LRU算法，我发现人大多数是这样的啊，对于自己熟悉的部分呢还能记着点，不熟悉或者不会的可能真的是看过就忘啊~既然这样还不如先把熟悉的弄明白。 第二天来到公司，我觉着还是有必要看一下这个LRU的源码，到底是怎么回事，嗯，糖葫芦同学刷刷得看，下面我们将进入正题，请戴眼镜的同学把眼镜擦一擦，哈哈哈 First先看源码，再用具体的demo加以验证，我们先看一下这个LruCache这个类的大致结构和方法，如下图所示： 这又是 get(K)，put(K,V), remove(K) 的方法的 给人的感觉就像是一个Map的集合嘛，又有Key ，又有value 的，再看下具体的代码： 12345678910111213141516171819202122232425public class LruCache&lt;K, V&gt; &#123; private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 看到开头，我们就明白了，哦原来这个LruCache类中维护一个LinkedHashMap的一个集合，缓存我们这个对象，而且构造方法里需要我们传入一个maxSize的一个值，根据上面的注释我们就明白了这个就是我们LruCache缓存对象的最大数目。 有什么用呢？根据惯性思维，我们可以认为，在put新的缓存对象的时候，根据我们设定的最大值remove集合里的某些缓存对象，进而添加新的缓存对象。 Second根据我们的分析，我们有必要去看一下这个put方法的源码：12345678910111213141516171819202122232425262728/** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous;&#125; 代码量也不是特别多，我们看下这个，在这个synchronized同步代码块里，我们看到这个 size,是对put进来缓存对象个数的累加，然后调用集合的map.put方法，返回一个对象 previous ，就是判断这个集合中是否添加了这个缓存对象，如果不为null,就对size减回去。 最后又调用一个 trimToSize(maxSize)方法，上面都是对添加一些逻辑的处理，那么不可能无限制添加啊，肯定有移除操作，那么我们推测这个逻辑可能在这个trimToSize(maxSize) 里处理。 源码如下：123456789101112131415161718192021222324252627282930313233/** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //只要当前size&lt;= maxSize 就结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; // 获取这个对象，然后从map中移除掉，保证size&lt;=maxSize Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 注释：Remove the eldest entries until the total of remaining entries is at or below the requested size 大概意思是说：清除时间最久的对象直到剩余缓存对象的大小小于设置的大小。没错是我们想找的。 这里说明一下：maxSize就是我们在构造方法里传入的，自己设置的1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这样LruCache的核心方法 trimToSize方法我们就说完了，接下来我将通过实例再次验证下： 设置场景 假设我们设置maxSize 为2，布局里显示3个imageView,分别代表3张我们要显示的图片，我们添加3张图片，看看会不会显示3张？ xml布局显示如下（代码就不贴了，很简单）： activity代码如下：12345678910111213141516171819202122232425262728public final int MAX_SIZE = 2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_lru); ImageView iv1 = (ImageView) findViewById(R.id.iv1); ImageView iv2 = (ImageView) findViewById(R.id.iv2); ImageView iv3 = (ImageView) findViewById(R.id.iv3); Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),R.drawable.bg); Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(),R.drawable.header_img); Bitmap bitmap3 = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); LruCache&lt;String,Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE); lruCache.put("1",bitmap1); lruCache.put("2",bitmap2); lruCache.put("3",bitmap3); Bitmap bitmap = lruCache.get("1"); iv1.setImageBitmap(bitmap); Bitmap b2 = lruCache.get("2"); iv2.setImageBitmap(b2); Bitmap b3 = lruCache.get("3"); iv3.setImageBitmap(b3); &#125; 图： 我们可以先尝试分析一下：因为我们设置的MaxSize 是2 ，那么在put第三个Bitmap的时候，在trimToSize方法中，发现这个size是3 ，maxSize 是2，会继续向下执行,不会break,结合下面代码看下12345678910111213141516171819202122232425262728public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //第一次循环：此时 size 是3，maxSize 是 2 //第二次循环，此时 size 是 2 ，maxSize 是 2 ，满足条件，break,结束循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; //获取最先添加的第一个元素 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); //移除掉第一个缓存对象 map.remove(key); // size = 2,减去移除的元素 size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 这个 safeSizeOf 是调用sizeOf方法。 那么也就是说，我们在put第三个bitmap的时候，LruCache 会自动帮我们移除掉第一个缓存对象，因为第一个最先添加进去，时间也最长，当然后添加的bitmap就是新的，最近的，那么我们推断这个iv1是显示不出图片的，因为被移除掉了，其它剩余两个可以显示，分析就到这里，看下运行结果是不是跟我们分析的一样： 哇！真的跟我们想的一样耶，证明我们想的是对的。这里我们思考一下就是为什么LruCache使用了这个LinkedHashMap,为什么LinkedHashMap的创造方法跟我们平时创建的不太一样，源码是这样的：1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 这里说一下在掘金发布的评论里 藏地情人评论是：new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true)这句代码表示，初始容量为零，0.75是加载因子，表示容量达到最大容量的75%的时候会把内存增加一半。最后这个参数至关重要。表示访问元素的排序方式，true表示按照访问顺序排序，false表示按照插入的顺序排序。这个设置为true的时候，如果对一个元素进行了操作(put、get)，就会把那个元素放到集合的最后。 确实也是这样的，我们看下LinkedHashMap的源码：1234567891011121314151617/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; 里面这个assessOrder 注释里也说的很明白：the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order -&gt; true 呢就表示会排序，false 就代表按照插入的顺序。默认不传就是 false ,而且我们每次 get(K) put(K,V) 的时候 会根据这个变量调整元素在集合里的位置。而这么做的目的也只有一个：保留最近使用的缓存对象，举个例子说明一下： 我们向这个集合里添加了三种元素 LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE);(MAX_SIZE=2) lruCache.put(&quot;1&quot;, bitmap1); lruCache.put(&quot;2&quot;, bitmap2); lruCache.put(&quot;3&quot;, bitmap3); 此时它们在集合里的顺序是这样的： 那比如说我们在put 3 元素之前，使用了1元素，就是调用了get(&quot;1&quot;)方法，我们知道LinkedHashMap就会改变链表里元素的存储顺序，代码是这样的：1234lruCache.put("1", bitmap1);lruCache.put("2", bitmap2);lruCache.get("1");lruCache.put("3", bitmap3); 那么此时对应链表里的顺序就是： 当我们再调用显示的时候，循环遍历就会优先把第一个位置的key = &quot;2&quot; 的缓存对象移除掉，保证了最近使用的原则，当然了因为把这个max_size = 2所以在我们执行lruCache.put(&quot;3&quot;, bitmap3); 时，集合最终会变成这样： 集合里只剩下 1 ,3对应的缓存对象。 至此，LruCache就说完了，如果看完的你有不明白的地方可以留言，一起讨论下~]]></content>
      <tags>
        <tag>Lru</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
