<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2018/11/07/LeakCannary%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>title: LeakCannary 原理分析<br>date: 2018-11-07 16:45:30<br>tags: leakcannary</p>
</blockquote>
<p>上篇写到  <a href="https://github.com/square/leakcanary">leakcanary</a> 的使用,这篇主要是了解<code>LeakCannary</code> 大概是如何工作的。</p>
<h1 id="1-首先它是如何监听Activity-销毁的？"><a href="#1-首先它是如何监听Activity-销毁的？" class="headerlink" title="1.首先它是如何监听Activity 销毁的？"></a>1.首先它是如何监听<code>Activity</code> 销毁的？</h1><p>因为我们知道只有当<code>activity</code> 销毁（<code>onDestroy()</code>）的时候，我们才能对这个<code>activity</code> 进行分析查看哪些对象可能存在内存泄漏。</p>
<p>发现了如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">install</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class="line">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class="line">        .buildAndInstall();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>buildAndInstall()</code> 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ....</span><br><span class="line">   <span class="keyword">if</span> (refWatcher != DISABLED) &#123;</span><br><span class="line">     <span class="keyword">if</span> (watchActivities) &#123;</span><br><span class="line">     <span class="comment">//这是观察activity的</span></span><br><span class="line">       ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (watchFragments) &#123;</span><br><span class="line">       FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class="line">   <span class="keyword">return</span> refWatcher;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityRefWatcher</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context, RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">    Application application = (Application) context.getApplicationContext();</span><br><span class="line">    ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line">    <span class="comment">//拿到application，注册activity的生命周期回调</span></span><br><span class="line">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中这个：<code>lifecycleCallbacks</code> 就是回调监听<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">      <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;<span class="comment">//监听activity销毁</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">          refWatcher.watch(activity);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么我们也可以通过<code>application</code> 注册获取<code>activity</code> 的生命周期监听回调，如下是我写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCircleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.life_layout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Application application = (Application) getApplicationContext();</span><br><span class="line">        application.registerActivityLifecycleCallbacks(<span class="keyword">new</span> Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityCreated..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityStarted..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityResumed..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityPaused..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivityStopped..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onActivitySaveInstanceState..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                application.unregisterActivityLifecycleCallbacks(<span class="keyword">this</span>);</span><br><span class="line">                Log.i(<span class="string">"xx"</span>,<span class="string">"activity is onDestroy..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以监听我们当前这个类的生命周期了，可以运行打印日志就知道了。</p>
<h1 id="2-内存泄漏的对象的引用路径"><a href="#2-内存泄漏的对象的引用路径" class="headerlink" title="2.内存泄漏的对象的引用路径"></a>2.内存泄漏的对象的引用路径</h1><p>这块使用到了 <code>square</code> 的另一个开源库 <a href="https://github.com/square/haha">haha</a> ,获取当前内存中的<code>heap</code>堆信息的<code>snapshot</code></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2018/11/07/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80-leakcannary/</url>
      <content type="html"><![CDATA[<blockquote>
<p>title: 小试牛刀-leakcannary<br>date: 2018-11-07 16:39:40<br>tags: leakcannary</p>
</blockquote>
<ul>
<li><p><code>build gradle</code>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.6.1&apos;</span><br><span class="line">releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.6.1&apos;</span><br><span class="line">// Optional, if you use support library fragments:</span><br><span class="line">debugImplementation &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.1&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>application</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">    public static RefWatcher getRefWatcher(Context context)&#123;</span><br><span class="line"></span><br><span class="line">        HealthApplication application = (HealthApplication) context.getApplicationContext();</span><br><span class="line"></span><br><span class="line">        return application.refWatcher;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监测 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefWatcher refWatcher = MyApplication.getRefWatcher(this);//1</span><br><span class="line">       refWatcher.watch(this);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例如：我们写一个泄漏的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_event_bus);</span><br><span class="line"></span><br><span class="line">        RefWatcher refWatcher = MyApplication.getRefWatcher(this);//1</span><br><span class="line">        refWatcher.watch(this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.obj = &quot;qianqian&quot;;</span><br><span class="line">        message.what = 666;</span><br><span class="line">        handler.sendMessageDelayed(message,600000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Handler handler = new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            Log.i(&quot;xx&quot;,&quot;handle message&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(View view)&#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>界面上一个按钮，点击按钮退出程序，在程序 <code>onCreate</code> 方法中我们发送了一个延时的消息，按照我们的分析，肯定会发生泄漏的。来我们看下<code>leakcannary</code> 给我们的提示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-0ebd9f3bf02894c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<p>我们知道当我们退出程序的时候 <code>MessageQueue</code> 中的消息还没执行完毕，<code>MessageQueue.mMessages</code> 这个变量持有的是<code>Message</code> 这个对象，而 <code>Message.target</code>中的 <code>target</code>持有的该<code>Activity</code>的 <code>handler</code>引用，所以此时<code>finish</code> 掉的 <code>activity</code> 并不会被回收，导致<code>LeakActivity</code> 发生内存泄漏。</p>
<ul>
<li>其中一种解决办法呢，就是我们可以通过在点击或<code>activity</code> 退出时，<code>removeMessage</code>，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void sendMessage(View view)&#123;</span><br><span class="line">        handler.removeMessages(666);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就不会有警告了。</p>
<p>也可以通过静态内部类+弱引用的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static class MyHandler extends Handler &#123;</span><br><span class="line">    private final WeakReference&lt;LeakActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    public MyHandler(SampleActivity activity) &#123;</span><br><span class="line">      mActivity = new WeakReference&lt;LeakActivity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">      LeakActivityactivity = mActivity.get();</span><br><span class="line">      if (activity != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">private final MyHandler handler= new MyHandler(this);</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_event_bus);</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.obj = &quot;qianqian&quot;;</span><br><span class="line">        message.what = 666;</span><br><span class="line">        handler.sendMessageDelayed(message,600000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实际项目中，可以用这个工具筛查一遍。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[EventBus 源码分析（下篇）]]></title>
      <url>/2018/10/08/EventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>上篇  <a href="https://www.jianshu.com/p/bb25f4f56d65" target="_blank" rel="noopener">EventBus 源码分析（上篇）</a> 说到注册订阅的前半部分，此篇用来分析发送事件到接收事件这个过程。</p>
</blockquote>
<h1 id="1-发送事件"><a href="#1-发送事件" class="headerlink" title="1. 发送事件"></a>1. 发送事件</h1><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new RemindBean(&quot;2018-02-12&quot;,&quot;happy&quot;));</span><br></pre></td></tr></table></figure></p>
<p><code>post</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/** Posts the given event to the event bus. */</span><br><span class="line">    public void post(Object event) &#123;</span><br><span class="line">      - 1.获取当前线程的postingThreadState 对象</span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">      - 2. 获取里面那个事件队列</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        - 3. 将事件添加到队列中去</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">      - 4. 判断当前的event 是否在 posting</span><br><span class="line">        if (!postingState.isPosting) &#123;</span><br><span class="line">            - 5. 是否是主线程</span><br><span class="line">            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">            postingState.isPosting = true;</span><br><span class="line">            - 6. 判断是否取消</span><br><span class="line">            if (postingState.canceled) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (!eventQueue.isEmpty()) &#123;//不为空，进入循环</span><br><span class="line">                    - 7.按照顺序，post一个 remove一个</span><br><span class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postingState.isPosting = false;</span><br><span class="line">                postingState.isMainThread = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PostingThreadState</code> 大概看一眼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final static class PostingThreadState &#123;</span><br><span class="line">        final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;();</span><br><span class="line">        boolean isPosting;</span><br><span class="line">        boolean isMainThread;</span><br><span class="line">        Subscription subscription;</span><br><span class="line">        Object event;</span><br><span class="line">        boolean canceled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>再就是 <code>postSingleEvent(eventQueue.remove(0), postingState);</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">         - 1. 获取event的字节码（例如就是：RemindBean.class）</span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        boolean subscriptionFound = false;</span><br><span class="line">      </span><br><span class="line">        if (eventInheritance) &#123;//默认为true</span><br><span class="line">          - 2. 根据eventClass 的字节码查找</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">            int countTypes = eventTypes.size();</span><br><span class="line">            - 3.循环遍历</span><br><span class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                - 4.根据事件，字节码查找订阅者</span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!subscriptionFound) &#123;</span><br><span class="line">            if (logNoSubscriberMessages) &#123;</span><br><span class="line">                Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                post(new NoSubscriberEvent(this, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>postSingleEventForEventType</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          - 1.根据字节码取出subscriptions,还记得我们之前在subscribe这个方法的时候，</span><br><span class="line">把subscrber,subscriberMethod 封装成一个subscription 对象。</span><br><span class="line"></span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                - 2. 取出每一个subscription 对象</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                boolean aborted = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                  - 3. post到相应的线程中回调</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postingState.event = null;</span><br><span class="line">                    postingState.subscription = null;</span><br><span class="line">                    postingState.canceled = false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (aborted) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>postToSubscription</code>: 根据定义的不同线程，调用相应的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            case POSTING://一般没定义的，这个就是post在哪个线程，响应就在哪个线程执行</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            case MAIN:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case BACKGROUND:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>invokeSubscriber</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          - 反射拿到字节码clazz 反射调用方法，就收到消息了</span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>end.</p>
]]></content>
      
        
        <tags>
            
            <tag> EventBus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eventbus 源码分析（上篇）]]></title>
      <url>/2018/10/08/Eventbus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>可用于应用内的消息事件传递，方便快捷，耦合性低</p>
<h1 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class EventBusMain extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.content_main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        EventBus.getDefault().register(this);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  - 订阅的事件 onEvent1</span><br><span class="line">    @Subscribe</span><br><span class="line">    public void onEvent1(RemindBean bean)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">- 订阅的事件 onEvent2</span><br><span class="line">    @Subscribe</span><br><span class="line">    public void onEvent2(UserInfo bean)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要发送消息传递的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new RemindBean())</span><br></pre></td></tr></table></figure></p>
<h1 id="2-源码解读"><a href="#2-源码解读" class="headerlink" title="2.源码解读"></a>2.源码解读</h1><p>放上官网的一张原理图，感觉挺清晰的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-6624ab6edcfd5d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>发布消息的一方(<code>Publisher</code>)，只需要 <code>post</code> 一个 <code>event</code> 之后就不用管了，<code>EventBus</code> 内部会将<code>event</code>逐一分发给订阅此 <code>event</code> 的订阅者（<code>Subscriber</code>）. 不错就是这样一个东西。</p>
<p>还记得以往我要实现两个不同的<code>activity</code> 之间要传递一些数据的时候，我都是通过定义一个<code>interface</code>的形式完成，时间一长，定义的接口一堆，在回顾查看代码也确实不够美观。好了话不多说，看下大家都在用的<code>Eventbus</code>.</p>
<h1 id="3-首先"><a href="#3-首先" class="headerlink" title="3.首先"></a>3.首先</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure>
<p><code>getDefault()</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EventBus 是一个单例模式，懒汉式，双重判断</span><br><span class="line"> /** Convenience singleton for apps using a process-wide EventBus instance. */</span><br><span class="line">    public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance == null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance == null) &#123;</span><br><span class="line">                    defaultInstance = new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>register</code> 是什么意思呢，就是就跟你订阅报纸一样，报社需要确定几个重要的问题：</p>
<ul>
<li>订阅者是谁（<code>Subscriber</code>）？</li>
<li>订阅的什么报纸(<code>Event</code>) ？</li>
</ul>
<p>就是我认为比较重要的，那么<code>register</code> 这一步就是<code>Subscriber</code> 告诉 报社，订阅的<code>event</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        - 1.先拿到这个订阅者(subscriber)类的字节码</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"></span><br><span class="line">        - 2. 通过这个类的字节码，拿到所有的订阅的 event,存放在List中</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">          - 3. 循环遍历所有的订阅的方法，完成subscriber 和 subscriberMethod 的关联</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看下这个如何根据<code>subscriberClass</code> 找到这个订阅的 <code>method</code>的，<code>findSubscriberMethods</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">       - 1.先从缓存中取</span><br><span class="line">       List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line"></span><br><span class="line">       - 2. 第一次肯定 null</span><br><span class="line">       if (subscriberMethods != null) &#123;</span><br><span class="line">           return subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       - 3. 查找默认也是false，感兴趣的可以看下</span><br><span class="line">       if (ignoreGeneratedIndex) &#123;</span><br><span class="line">           subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line"></span><br><span class="line">         - 4. 所以是走这里</span><br><span class="line">           subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">       &#125;</span><br><span class="line">       if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">           throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                   + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           - 5. 找到之后添加到缓存中，key是 subscriber ;value 是：methods</span><br><span class="line">           METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">           return subscriberMethods;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看下：<code>findUsingInfo(subscriberClass)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        - 1. 我认为就是准备一个查找结果得存储对象</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line"></span><br><span class="line">        - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass </span><br><span class="line">        同时赋值给clazz变量中,以下代码能够看出</span><br><span class="line">//      void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line"> //      this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">//&#125;</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line"></span><br><span class="line">        while (findState.clazz != null) &#123;进入循环中</span><br><span class="line">          //获取subscriberInfo 信息，返回null</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                  - 3. 进入到这里了</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            - 4. 查找父类中的方法</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>findUsingReflectionInSingleClass</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">       Method[] methods;</span><br><span class="line">       try &#123;</span><br><span class="line">           // This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">         - 1. 通过订阅者的字节码查找当前类中所有生命的方法</span><br><span class="line">           methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">       &#125; catch (Throwable th) &#123;</span><br><span class="line">           // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">           methods = findState.clazz.getMethods();</span><br><span class="line">           findState.skipSuperClasses = true;</span><br><span class="line">       &#125;</span><br><span class="line">         - 2. 循环遍历所有的方法</span><br><span class="line">       for (Method method : methods) &#123;</span><br><span class="line">           - 3. 获取方法的修饰符</span><br><span class="line">           int modifiers = method.getModifiers();</span><br><span class="line">     </span><br><span class="line">           - 4.判断修饰符，订阅方法的修饰符不能是private，static</span><br><span class="line">           if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">               - 5. 获取方法的所有的参数</span><br><span class="line">               Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">               - 6.判断参数的个数，只能有1个参数，订阅方法中</span><br><span class="line">               if (parameterTypes.length == 1) &#123;</span><br><span class="line">               - 7.获取方法上具有subscribe 注解</span><br><span class="line">                   Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line"></span><br><span class="line">                   - 8.含有subscribe注解的方法，就是该类订阅的方法，其它不符合的可能就是普通的方法</span><br><span class="line">                   if (subscribeAnnotation != null) &#123;</span><br><span class="line"></span><br><span class="line">                     - 9. 获取第一个参数eventType</span><br><span class="line">                       Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                         </span><br><span class="line">                       if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                         - 10. 获取注解的mode，就是我们在注解上标识的，</span><br><span class="line">                     有mainThread,Posting,background,async</span><br><span class="line">                           ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line"></span><br><span class="line">                         - 11. 将订阅方法的一系列信息（方法名称，threadMode,优先级，是否是粘性等）添加到集合subscriberMethods中去</span><br><span class="line">                           findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">             - 12. 参数是多个的时候抛出异常</span><br><span class="line">                   String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                   throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                           &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">           - 13. 方法的修饰符不是public的，抛出异常                </span><br><span class="line"></span><br><span class="line">             String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">               throw new EventBusException(methodName +</span><br><span class="line">                       &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们将所有信息都保存到<code>findState</code> 类中去了。再回头看我们原先那个方法,到第三步了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        - 1. 我认为就是准备一个查找结果得存储对象</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line"></span><br><span class="line">        - 2. 将订阅者的subscriberClass 存储起来，保存在一个FindState 类中的subscriberClass </span><br><span class="line">        同时赋值给clazz变量中,以下代码能够看出</span><br><span class="line">//      void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line"> //      this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">//&#125;</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line"></span><br><span class="line">        while (findState.clazz != null) &#123;进入循环中</span><br><span class="line">          //获取subscriberInfo 信息，返回null</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                  - 3. 进入到这里了，上面已经分析所有信息保存到findState中</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            - 4. 查找父类中的方法</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个<code>getMethodsAndRelease(findState)</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">        - 1. 取出里面的subscriberMethods</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">        findState.recycle();</span><br><span class="line">        synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">            for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = findState;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      - 2. 返回集合</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们知道了根据订阅者（<code>subscriber</code>）的<code>clazz</code> 找到了所有订阅的方法事件<br> <code>methods</code> </p>
<p>回到最初的第一步<code>register</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        - 2. 完成</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            - 3.循环遍历所有的订阅方法和订阅者之间建立关联</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>subscribe(subscriber, subscriberMethod)</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// Must be called in synchronized block</span><br><span class="line">    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        - 1. 订阅方法的eventType的字节码</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">        - 2. 订阅者和订阅方法封装成一个Subscription 对象</span><br><span class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line"></span><br><span class="line">        - 3. subscriptionsByEventType 第一次也是null ,根据eventType</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"></span><br><span class="line">        - 4. 第一次肯定为null</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            - 5. key 为 eventType, value 是subscriptions对象</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          - 抛出异常</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      - 6. 获取所有添加的subscriptions</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">          - 7. 会判断每个订阅方法的优先级，添加到这个 subscriptions中，按照优先级</span><br><span class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">      - 8.获取订阅的方法集合</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents == null) &#123;</span><br><span class="line">            subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">          - 9. 为空添加到 typesBySubscriber</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        - 10. 订阅事件添加到subscribedEvents集合中去</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">        - 11. 判断是否是粘性事件的关联</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，如果你跟着我一步步看到这里，应该大概明白一些了，还有一部分没完，就是<code>register</code> 前半部分完成订阅，存储等工作；剩下<code>post(event)</code> 方法就是将<code>event</code> 分发给相应订阅过此事件的订阅者了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[AsyncTask源码解读]]></title>
      <url>/2018/09/19/AsyncTask%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>屡思路</p>
<h1 id="1-初始-AsyncTask"><a href="#1-初始-AsyncTask" class="headerlink" title="1. 初始 AsyncTask"></a>1. 初始 AsyncTask</h1><p><code>AsyncTask</code> 这个类的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>是一个抽象类<br><code>Params</code> 表示输入参数的类型<br><code>Progress</code> 表示后台任务的执行进度<br><code>Result</code> 表示返回结果的类型</p>
<h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><blockquote>
<p>在 <code>AsyncTask</code> 这个类的顶部有一些代码注释，里面讲述了如何使用一个 <code>AsyncTask</code>,如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;Here is an example of subclassing:&lt;/p&gt;</span><br><span class="line"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span><br><span class="line"> * private class DownloadFilesTask extends AsyncTask&amp;lt;URL, Integer, Long&amp;gt; &#123;</span><br><span class="line"> *     protected Long doInBackground(URL... urls) &#123;</span><br><span class="line"> *         int count = urls.length;</span><br><span class="line"> *         long totalSize = 0;</span><br><span class="line"> *         for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line"> *             totalSize += Downloader.downloadFile(urls[i]);</span><br><span class="line"> *             publishProgress((int) ((i / (float) count) * 100));</span><br><span class="line"> *             // Escape early if cancel() is called</span><br><span class="line"> *             if (isCancelled()) break;</span><br><span class="line"> *         &#125;</span><br><span class="line"> *         return totalSize;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     protected void onProgressUpdate(Integer... progress) &#123;</span><br><span class="line"> *         setProgressPercent(progress[0]);</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     protected void onPostExecute(Long result) &#123;</span><br><span class="line"> *         showDialog(&quot;Downloaded &quot; + result + &quot; bytes&quot;);</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">//user</span><br><span class="line">&lt;p&gt;Once created, a task is executed very simply:&lt;/p&gt;</span><br><span class="line"> * &lt;pre class=&quot;prettyprint&quot;&gt;</span><br><span class="line"> * new DownloadFilesTask().execute(url1, url2, url3);</span><br><span class="line"> * &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="3-内部重要方法"><a href="#3-内部重要方法" class="headerlink" title="3. 内部重要方法"></a>3. 内部重要方法</h1><ul>
<li><code>onPreExecute()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">  protected void onPreExecute() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在主线程中运行，异步任务之前会被调用，一般用于做一些准备工作；</p>
<ul>
<li><code>doInBackground()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line"> protected abstract Result doInBackground(Params... params);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在线程池中运行，此方法一般用于执行异步任务，通过<code>publishProgress</code> 方法来更新进度；</p>
<ul>
<li><code>onProgressUpdate()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">    protected void onProgressUpdate(Progress... values) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主线程中运行，当通过<code>publishProgress</code> 方法调用后，<code>onProgressUpdate()</code> 方法会被调用；</p>
<ul>
<li><code>onPostExecute()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">    protected void onPostExecute(Result result) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主线程中运行，将返回的结果展示。</p>
<h1 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h1><p>从它的 <code>execute</code> 方法开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line">    public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">      //sDefaultExecutor 定义如下，线程池</span><br><span class="line">        return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">    public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">            Params... params) &#123;</span><br><span class="line">      //首先判断是不是 PENDING</span><br><span class="line">        if (mStatus != Status.PENDING) &#123;</span><br><span class="line">            switch (mStatus) &#123;</span><br><span class="line">                case RUNNING:</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                            + &quot; the task is already running.&quot;);</span><br><span class="line">                case FINISHED:</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                            + &quot; the task has already been executed &quot;</span><br><span class="line">                            + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      //将状态设置为 RUNNING 状态</span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line">      //1.调用了 onPreExecute() 方法</span><br><span class="line">        onPreExecute();</span><br><span class="line">      //将参数封装到 mWorker.mParams 中去了</span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        //调用execute 将mFuture 传进去了</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了弄明白整体流程，首页要搞明白上面的 <code>mWorker</code>  <code>mFuture</code> 是干嘛的。</p>
<ul>
<li><code>mWorker</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> private final WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line">//抽象类 并且实现了Callable 接口</span><br><span class="line">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</span><br><span class="line">        Params[] mParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    private static class AsyncTaskResult&lt;Data&gt; &#123;</span><br><span class="line">        final AsyncTask mTask;</span><br><span class="line">        final Data[] mData;</span><br><span class="line"></span><br><span class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">            mData = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//在AsyncTask 的构造方法中，分别对 mWorker, mFuture 进行了初始化</span><br><span class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : new Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">          //实现 了 call 方法</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">              //设置调用了为 true</span><br><span class="line">                mTaskInvoked.set(true);</span><br><span class="line">              //</span><br><span class="line">                Result result = null;</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                 //设置线程的优先级</span><br><span class="line">   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    //noinspection unchecked</span><br><span class="line">                    //将 2. doInBackground的结果存储到 result 中</span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; catch (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(true);</span><br><span class="line">                    throw tr;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  //最后执行postResult</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">              //返回结果</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>postResult(result)</code> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">               new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">       message.sendToTarget();</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>发送一条 <code>MESSAGE_POST_RESULT</code> 的消息，并且将<code>result</code> 存入到了 <code>AsyncTaskResult</code>中的 <code>mData</code> 中去了，<br>其中 <code>AsyncTaskResult</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    private static class AsyncTaskResult&lt;Data&gt; &#123;</span><br><span class="line">        final AsyncTask mTask;</span><br><span class="line">        final Data[] mData;</span><br><span class="line"></span><br><span class="line">        AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">            mData = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getHandler</code> 获取一个 <code>Handler</code> ,我们看下 <code>handleMessage</code> 的<code>MESSAGE_POST_RESULT</code> 对这条消息的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">       public InternalHandler(Looper looper) &#123;</span><br><span class="line">           super(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">               case MESSAGE_POST_RESULT:</span><br><span class="line">                 //是他是他 就是他</span><br><span class="line">                   // There is only one result</span><br><span class="line">                   result.mTask.finish(result.mData[0]);</span><br><span class="line">                   break;</span><br><span class="line">               case MESSAGE_POST_PROGRESS:</span><br><span class="line">                   result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>result</code> 是 <code>AsyncTaskResult</code> 类型，前面我们见到过的，<code>mTask</code> 当时我们传的是 <code>this</code> 也就是当前的 <code>AsyncTask</code> ,调用<code>finish</code> 方法，将<code>mData</code> 返回的结果传入进去，还记得我们前面看过的吗，将返回的结果存入<code>AsyncTaskResult.mData</code>中去了。</p>
<p>下面看下 <code>finish</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">      //判断是否取消，如果取消了，就不执行onPostExecute 了</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //4. 就执行onPostExecute 方法了</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">      // 将状态标志为 finish</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ok ，上述都是 <code>mWorker</code> 工作的，接下来是我们一开始说的 <code>mFuture</code></p>
<ul>
<li><code>mFuture</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private final FutureTask&lt;Result&gt; mFuture;</span><br><span class="line"></span><br><span class="line">//初始化也是在AsyncTask 构造方法中执行的，在mWorker 之下，并且将mWorder 传入</span><br><span class="line">mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>postResultIfNotInvoked(get());</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void postResultIfNotInvoked(Result result) &#123;</span><br><span class="line">        final boolean wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">      //wasTaskInvoked 为true ,之前在 mWorker 中设置了为true</span><br><span class="line">//mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">//            public Result call() throws Exception &#123;</span><br><span class="line"> //               mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">        if (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>FutureTask</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">我们知道mWorker implement Callable 接口，传入赋值给了callable 变量</span><br><span class="line"> public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">        if (callable == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.callable = callable;</span><br><span class="line">        this.state = NEW;       // ensure visibility of callable</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">        if (state != NEW ||</span><br><span class="line">            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">          //callable 变量又赋值给了 c</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                boolean ran;</span><br><span class="line">                try &#123;</span><br><span class="line">                  //这里调用c.call 实际上就是调用 mWorker.call 方法</span><br><span class="line">//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = true;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    result = null;</span><br><span class="line">                    ran = false;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                if (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // runner must be non-null until state is settled to</span><br><span class="line">            // prevent concurrent calls to run()</span><br><span class="line">            runner = null;</span><br><span class="line">            // state must be re-read after nulling runner to prevent</span><br><span class="line">            // leaked interrupts</span><br><span class="line">            int s = state;</span><br><span class="line">            if (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ok ，这是 <code>mFuture</code>,还剩下最后一个：</p>
<p><code>exec.execute(mFuture);</code></p>
<p><code>exec</code> 就是 <code>sDefaultExecutor</code>  ,其实 就是 <code>SerialExecutor</code>,如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br></pre></td></tr></table></figure></p>
<p><code>SerialExecutor</code> 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">       final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">       Runnable mActive;</span><br><span class="line"></span><br><span class="line">       public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">           mTasks.offer(new Runnable() &#123;</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       r.run();</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       scheduleNext();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">         //第一次肯定为null ，执行 scheduleNext</span><br><span class="line">           if (mActive == null) &#123;</span><br><span class="line">               scheduleNext();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected synchronized void scheduleNext() &#123;</span><br><span class="line">         //给 mActivie 赋值，mTasks.poll 会从第一个开始取</span><br><span class="line">           if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">               THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们将 <code>mFuture</code> 传入，实际就是 <code>r</code>.<br><code>mTask</code> 是 <code>ArrayDeque&lt;Runnable&gt;</code> 姑且认为它是这个排队序列的吧。看下<code>offer</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">      插入一个 element 在队尾</span><br><span class="line">     * Inserts the specified element at the end of this deque.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is equivalent to &#123;@link #offerLast&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param e the element to add</span><br><span class="line">     * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)</span><br><span class="line">     * @throws NullPointerException if the specified element is null</span><br><span class="line">     */</span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        return offerLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>看注释，也就是说是每次执行一个任务，都是在当前 <code>deque</code> 的队尾开始排队的。并且执行是串行的，因为当第二个线程过来的时候，判断 <code>mActive</code> 不为 <code>null</code> 将不会执行 <code>scheduleNext</code>.(我这个是8.0)源码，其实在 <code>android 3.0</code> 之后 <code>AsyncTask</code> 都是采用串行执行任务的。</p>
<p>各个版本的不同如下：<br><code>android 1.6</code>之前 ——  串行<br><code>android 1.6-3.0</code> 之间 —– 并行<br><code>android 3.0</code> 之后 —– 串行</p>
<p>尽管如此，我们仍然可以通过 调用 <code>executeOnExecutor</code> 来并行执行任务。</p>
<p>ok ， 回到那个 <code>execute</code> 方法中，我们说调用了 <code>r.run</code> 实际山就是 调用 <code>mFuture.run</code> 方法：<br>上面我们展示过在 <code>mFuture.run</code> 方法中如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">                  //这里调用c.call 实际上就是调用 mWorker.call 方法</span><br><span class="line">//，由我们上面的分析知道，在mWorker.call 方法中最终会返回 result 结果</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = true;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    result = null;</span><br><span class="line">                    ran = false;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用<code>mWorker.call</code>  方法，而在 <code>mWorker.call</code> 方法中，我们完成一系列的任务，调用了 <code>doInBackground</code> <code>onPostExecute</code> 完成了整个的调用过程。</p>
<p>有的人可能已经注意到了 还差一个 <code>onProgressUpdate</code> 方法还没被调用，我们知道只有调用那个 <code>publishProgress</code> 方法的时候才能调用 <code>onProgressUpdate</code> ,那下面我们卡夏 <code>publishProgress</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">    protected final void publishProgress(Progress... values) &#123;</span><br><span class="line">        //如果没取消</span><br><span class="line">        if (!isCancelled()) &#123;</span><br><span class="line">    //会发送一个 MESSAGE_POST_PROGRESS 的消息            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">        public InternalHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case MESSAGE_POST_RESULT:</span><br><span class="line">                    // There is only one result</span><br><span class="line">                    result.mTask.finish(result.mData[0]);</span><br><span class="line">                    break;</span><br><span class="line">                case MESSAGE_POST_PROGRESS://是他是他 就是他</span><br><span class="line">                    //3. 调用了 onProgressUpdate 方法了</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>会调用 <code>AsyncTask</code> 的 <code>onProgressUpdate</code> 方法了。结束。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Service 启动过程]]></title>
      <url>/2018/09/11/Service%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>看完 <code>Activity</code> 的启动过程，发现 <code>Service</code> 的启动过程相对来说就比较简单了。</p>
</blockquote>
<p>要说起启动过程，就得从 <code>startService</code> 开始：</p>
<h1 id="1-startService"><a href="#1-startService" class="headerlink" title="1.startService"></a>1.startService</h1><p>根据源码的跳转，发现跳转到 <code>ContextWrapper</code> 这个类中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        return mBase.startService(service);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>mBase</code> 是类型是：<code>Context</code> 类型，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而我们又知道 <code>Context</code> 是一个抽象类 ，实现者是 <code>ContextImpl</code> ,所以我们应该是查看<code>ContextImpl</code> 这个类中的 <code>startService(service)</code> 方法。</p>
<p><code>ContextImpl</code> 中的方法定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        return startServiceCommon(service, false, mUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>startService</code> 中又调用了 <code>startServiceCommon(service,(requirForeground:false),mUser)</code> 这个方法，继续跟进：</p>
<h1 id="2-startServiceCommon"><a href="#2-startServiceCommon" class="headerlink" title="2.startServiceCommon"></a>2.startServiceCommon</h1><p><code>startServiceCommon</code> 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private ComponentName startServiceCommon(Intent service, boolean requireForeground,</span><br><span class="line">            UserHandle user) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //校验要启动的service</span><br><span class="line">            validateServiceIntent(service);</span><br><span class="line">            service.prepareToLeaveProcess(this);</span><br><span class="line">            ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                            getContentResolver()), requireForeground,</span><br><span class="line">                            getOpPackageName(), user.getIdentifier());</span><br><span class="line">            if (cn != null) &#123;</span><br><span class="line">                if (cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                    throw new SecurityException(</span><br><span class="line">                            &quot;Not allowed to start service &quot; + service</span><br><span class="line">                            + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">                &#125; else if (cn.getPackageName().equals(&quot;!!&quot;)) &#123;</span><br><span class="line">                    throw new SecurityException(</span><br><span class="line">                            &quot;Unable to start service &quot; + service</span><br><span class="line">                            + &quot;: &quot; + cn.getClassName());</span><br><span class="line">                &#125; else if (cn.getPackageName().equals(&quot;?&quot;)) &#123;</span><br><span class="line">                    throw new IllegalStateException(</span><br><span class="line">                            &quot;Not allowed to start service &quot; + service + &quot;: &quot; + cn.getClassName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return cn;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面有几个需要说明一下：</p>
<ul>
<li><code>ActivityManager.getService()</code>  点进去查看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    public static IActivityManager getService() &#123;</span><br><span class="line">        return IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                protected IActivityManager create() &#123;</span><br><span class="line">                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    return am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先是返回的类型是 <code>IActivityManager</code> 类型，其中在<code>create</code> 方法中，拿到远程服务的<code>Binder</code> 对象，其中<code>IActivityManager.Stub.asInterface(b)</code> 不知道大家有没有想起<code>AIDL</code> 这就很熟悉了，就是拿到远程服务的代理对象：<code>IActivityManager</code>,通过代理对象调用远程的方法，是应用进程与服务进程通信的媒介，如果没猜错的话就是在<code>ActivityManagerService</code> 中实现了，查看<code>ActivityManagerService</code> 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityManagerService extends IActivityManager.Stub</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>果然不出所料，<code>AMS extend  IActivityManager.Stub</code>  .</p>
<ul>
<li><code>mMainThread.getApplicationThread()</code> 首先明白 <code>mMainThread</code> 是 <code>ActivityThread</code> 类的实例变量，通过<code>getApplicationThread()</code> 方法拿到一个 <code>ApplicationThread</code> 类的实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ApplicationThread getApplicationThread()</span><br><span class="line">    &#123;</span><br><span class="line">        return mAppThread;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>而<code>ApplicationThread</code> 类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现 <code>ApplicationThread</code> 是 <code>ActivityThread</code> 的一个内部类.并且实现了 <code>IApplicationThread.Stub</code> ,而我们又把这个类型传入给了<code>AMS</code>,相当于远程服务拿到了一个访问应用进程的代理，类型为：<code>IApplicationThread</code></p>
<blockquote>
<p>总结：到目前为止，客户端拿到了远程服务的代理<code>（IActivityManager）</code>, 服务端拿到了客户端的代理<code>（IApplicationThread）</code>,它们互相拿到各自进程的代理类，是它们进行进程间通信的基础。</p>
</blockquote>
<p>ok ,我们回到最初那个地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                            getContentResolver()), requireForeground,</span><br><span class="line">                            getOpPackageName(), user.getIdentifier());</span><br></pre></td></tr></table></figure></p>
<p>通过前面的分析我们知道：<code>ActivityManager.getService().</code> 实际就是 <code>AMS</code> 远程代理，最终在<code>AMS</code> 中完成，我们去 <code>AMS</code> 代码中查看下 <code>startService</code> 代码：</p>
<h1 id="3-ActivityManagerService-startService"><a href="#3-ActivityManagerService-startService" class="headerlink" title="3.ActivityManagerService.  startService"></a>3.ActivityManagerService.  startService</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">            String resolvedType, boolean requireForeground, String callingPackage, int userId)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;startService&quot;);</span><br><span class="line">        // Refuse possible leaked file descriptors</span><br><span class="line">        if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (callingPackage == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;callingPackage cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                &quot;*** startService: &quot; + service + &quot; type=&quot; + resolvedType + &quot; fg=&quot; + requireForeground);</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            final int callingPid = Binder.getCallingPid();</span><br><span class="line">            final int callingUid = Binder.getCallingUid();</span><br><span class="line">            final long origId = Binder.clearCallingIdentity();</span><br><span class="line">            ComponentName res;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 又调用了startServiceLocked 方法</span><br><span class="line">                res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                        resolvedType, callingPid, callingUid,</span><br><span class="line">                        requireForeground, callingPackage, userId);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>startServiceLocked</code> 方法很复杂，大概如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">            int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">ServiceRecord r = res.record;//启动service的信息保存在 serviceRecord 中</span><br><span class="line">....</span><br><span class="line">   ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">        return cmp;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部又调用了：<code>startServiceInnerLocked</code> 方法</p>
<h1 id="4-startServiceInnerLocked"><a href="#4-startServiceInnerLocked" class="headerlink" title="4.startServiceInnerLocked"></a>4.startServiceInnerLocked</h1><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">            boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">...</span><br><span class="line">  String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>又调用： <code>bringUpServiceLocked</code></p>
<h1 id="5-bringUpServiceLocked"><a href="#5-bringUpServiceLocked" class="headerlink" title="5.bringUpServiceLocked"></a>5.bringUpServiceLocked</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">            boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">realStartServiceLocked(r, app, execInFg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后又调用了 <code>realStartServiceLocked(r, app, execInFg);</code> </p>
<h1 id="6-realStartServiceLocked"><a href="#6-realStartServiceLocked" class="headerlink" title="6.realStartServiceLocked"></a>6.realStartServiceLocked</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">      ....</span><br><span class="line">          app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                    app.repProcState);</span><br><span class="line">      ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>app.thread</code>  是 <code>IApplicationThread</code> 类型，就是远程调用客户端进程里的方法，<code>scheduleCreateService</code> ,而我们又知道 <code>ApplicationThread</code> 实现了 <code>IApplicationThread</code>，所以就查看 <code>ApplicationThread</code> 类中的 <code>scheduleCreateService</code>方法，前面我们说过<code>ApplicationThread</code> 是 <code>ActivityThread</code> 的一个内部类，查看：</p>
<h1 id="7-ApplicationThread-scheduleCreateService"><a href="#7-ApplicationThread-scheduleCreateService" class="headerlink" title="7.ApplicationThread.scheduleCreateService"></a>7.ApplicationThread.scheduleCreateService</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleCreateService(IBinder token,</span><br><span class="line">                ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">            updateProcessState(processState, false);</span><br><span class="line">            CreateServiceData s = new CreateServiceData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.info = info;</span><br><span class="line">            s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">            sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>发现内部通过发送一个 <code>CREATE_SERVICE</code> 的消息，<code>H</code> 是 <code>Handle</code>,继续查看：<br><code>handleMessage</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case CREATE_SERVICE:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj)));</span><br><span class="line">                    handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>到 <code>handleCreateService</code> 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">        // If we are getting ready to gc after going to the background, well</span><br><span class="line">        // we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                data.info.applicationInfo, data.compatInfo);</span><br><span class="line">        Service service = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">            service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate service &quot; + data.info.name</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</span><br><span class="line">          //创建context</span><br><span class="line">            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">            context.setOuterContext(service);</span><br><span class="line">          //创建Application</span><br><span class="line">            Application app = packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">  //通过attach 方法，将context application ，service 连接起来</span><br><span class="line">            service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                    ActivityManager.getService());</span><br><span class="line">          //调用service oncreate方法</span><br><span class="line">            service.onCreate();</span><br><span class="line">            mServices.put(data.token, service);</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create service &quot; + data.info.name</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>service.onCreate();</code> ok ，调用了 <code>onCreate</code> 方法，至此，<code>service</code>的启动过程的就完成了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[TransitionDrawable]]></title>
      <url>/2018/08/16/TransitionDrawable/</url>
      <content type="html"><![CDATA[<ul>
<li>1.首先创建一个<code>xml</code> 在 <code>drawable</code> 目录下</li>
</ul>
<p><code>transition_image</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;transition xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/first"</span> /&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/two"</span> /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.在xml中引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:drawable=<span class="string">"@drawable/transition_image"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.在<code>Activity</code>中使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImageView mImageView = (ImageView) findViewById(R.id.iv); </span><br><span class="line">TransitionDrawable transitionDrawable = (TransitionDrawable) mImageView.getDrawable(); </span><br><span class="line">transitionDrawable.startTransition(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<h1 id="另外一种写法实现多张图片效果"><a href="#另外一种写法实现多张图片效果" class="headerlink" title="另外一种写法实现多张图片效果"></a>另外一种写法实现多张图片效果</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransitionDrawable transitionDrawable = <span class="keyword">new</span> TransitionDrawable(<span class="keyword">new</span> Drawable[]&#123;getResources().getDrawable(R.drawable.first),getResources().getDrawable(R.drawable.two)&#125;);</span><br><span class="line">mImageView.setImageDrawable(transitionDrawable);</span><br><span class="line">transitionDrawable.startTransition(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 两个Drawable之间淡入淡出 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序的爬坑之路]]></title>
      <url>/2018/07/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%88%AC%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>近期由于项目需要，需要编写小程序，遇到一些问题，记录下来，也是给自己开发的一个总结。</p>
</blockquote>
<h1 id="1-关于模板-template"><a href="#1-关于模板-template" class="headerlink" title="1.关于模板 template"></a>1.关于模板 template</h1><p>在看完 <a href="&quot;https://developers.weixin.qq.com/miniprogram/dev/index.html&quot;">官方文档</a> 里的说明之后，我并没有成功使用，按照它那个设置完成后，一直说找不到，最后在知道，原来除了实例那些之外，还要在当前 <code>wxml</code> 中 <code>import</code> 进来。</p>
<ul>
<li>1.先建一个 <code>template</code> 的文件夹，新建 <code>wxml</code>,根据具体的路径引入进来，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import src=&quot;../template/line.wxml&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还有一个就是如果有相对应的 <code>wxss</code>文件，可在 <code>app.wxss</code>文件中引用，这样整个项目都不需要引用这个样式文件了。</p>
<p><strong>注意：模板拥有自己的作用域，只能使用 data 传入的数据以及模版定义文件中定义的 <wxs> 模块。</wxs></strong></p>
<h1 id="2-关于水平居中，垂直居中"><a href="#2-关于水平居中，垂直居中" class="headerlink" title="2. 关于水平居中，垂直居中"></a>2. 关于水平居中，垂直居中</h1><p>一开始感觉这啥玩意，不听话啊，让居中也不居中，就是不动啊，很是郁闷，后来发现了一些规律。</p>
<p><strong>2.1 水平居中</strong></p>
<ul>
<li>首先如果是行内元素，例如 <text> 这样的，如果想水平居中，使用<code>text-align:center</code> 你会发现不好使啊，纹丝不动，原因是因为行内元素长度随内容变化，所以它不能让你在一行的中间，因为它的长度就是文字长度。</text></li>
</ul>
<p><strong>解决方案：</strong>可以换成<code>view</code> 控件，或者使用：<code>display:block</code> + <code>text-align:center</code></p>
<ul>
<li>其它元素可以使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">======3个一起使用==========</span><br><span class="line">text-align:center;</span><br><span class="line">align-items:center;</span><br><span class="line">justify-content: center;</span><br><span class="line">==================</span><br><span class="line">margin:auto # 子容器在父容器中居中,单独使用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2.2 垂直居中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//可使用如下</span><br><span class="line">display:flex;</span><br><span class="line">align-items:center;</span><br><span class="line">justify-content:center;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-关于几个控件平分整个屏幕宽度问题"><a href="#3-关于几个控件平分整个屏幕宽度问题" class="headerlink" title="3.关于几个控件平分整个屏幕宽度问题"></a>3.关于几个控件平分整个屏幕宽度问题</h1><blockquote>
<p>一开始我还想着获取屏幕的宽和高，然后再动态给控件设置具体的值，后来发现有更简单的做法</p>
</blockquote>
<p>例如：像这样一行排四个<br><img src="https://upload-images.jianshu.io/upload_images/1948557-35b5b4254918c3fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>解决方案：</strong>设置控件的宽度为 ：25%，这样就自动平分啦。当然还有其它的方式，但是我认为百分比的这种写法感觉很直观。</p>
<h1 id="4-flex-布局"><a href="#4-flex-布局" class="headerlink" title="4. flex 布局"></a>4. flex 布局</h1><p>熟练掌握 <code>flexbox</code> 布局，可以更轻松的编写任何常见的布局，可以查看相关专业的文章。</p>
<p>未完待续…..</p>
]]></content>
      
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin-可观察属性]]></title>
      <url>/2018/06/27/Kotlin-%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>类似于观察者模式，当所监测的对象发生改变时，能够收到回调通知。</p>
</blockquote>
<p>例如：我们监测一个变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str: String by Delegates.observable(<span class="string">"qianqian"</span>,&#123;</span><br><span class="line">        property: KProperty&lt;*&gt;, oldValue: String, newValue: String -&gt;</span><br><span class="line">        Log.i(<span class="string">"xx"</span>,<span class="string">"改变的属性名称：$&#123;property.name&#125; --- $&#123;oldValue&#125; -- $&#123;newValue&#125;"</span> )</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//点击一个按钮，改变str的值</span></span><br><span class="line">     <span class="function">fun <span class="title">foo</span><span class="params">(view : View)</span></span>&#123;</span><br><span class="line">        str = <span class="string">"haha"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候我们会发现，当改变<code>str</code> 的值的时候，会打印信息，也就是收到回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">改变的属性名称：str --- qianqian -- haha</span><br></pre></td></tr></table></figure></p>
<p>再比如：检测对象里的其中一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    var name: String by Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123;</span><br><span class="line">        prop, old, <span class="keyword">new</span> -&gt;</span><br><span class="line">        println(<span class="string">"$old -&gt; $new"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    val user = User()</span><br><span class="line">    user.name = <span class="string">"first"</span></span><br><span class="line">    user.name = <span class="string">"second"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;no name&gt; -&gt; first</span><br><span class="line">first -&gt; second</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin let with run also apply区分]]></title>
      <url>/2018/04/28/Kotlin-let-with-run-also-apply%E5%8C%BA%E5%88%86/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1948557-701b869e22eff1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>它与其它特殊之处在于，它返回本省对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;().apply &#123;</span><br><span class="line">            add(<span class="string">"qq"</span>)</span><br><span class="line">            add(<span class="string">"mi"</span>)</span><br><span class="line">        &#125;.let &#123;<span class="comment">//this-&gt;ArrayList本身</span></span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"list==="</span>+it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list===[qq, mi]</span><br></pre></td></tr></table></figure>
<p>这里<code>T</code> 就是 <code>ArrayList&lt;String&gt;()</code> 返回对象本身，也就是<code>ArrayList</code></p>
<ul>
<li><p>内部是 <code>this</code> 还是 <code>it</code> 这个倒没什么，编辑器一般都会有提示，如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-f6a5a83174af7964.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1540798437731.png"></p>
</li>
</ul>
<p><code>apply</code> 是 <code>this</code> , <code>also</code> 是 <code>it</code> </p>
<h1 id="run"><a href="#run" class="headerlink" title="run"></a>run</h1><ul>
<li><p><code>run</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; R): R &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>返回最后一行，传入<code>block</code> 返回 最后一行，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;().run &#123;</span><br><span class="line">            add(<span class="string">"lala"</span>)</span><br><span class="line">            add(<span class="string">"kaka"</span>)</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;.let &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"返回：："</span>+it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回：：kaka</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也是返回最后一行，但是它内部不能调用对象的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">letGo</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="string">"qianqian"</span>.let &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,it)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>letGO</code> 返回 <code>1</code> </p>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><p>类似于：<code>apply</code> + <code>let</code> 的结合</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(ArrayList&lt;String&gt;())&#123;</span><br><span class="line">            add(<span class="string">"haha"</span>)</span><br><span class="line">            add(<span class="string">"heihei"</span>)</span><br><span class="line">            <span class="keyword">this</span><span class="comment">//最后返回ArrayList对象</span></span><br><span class="line">        &#125;.let &#123;</span><br><span class="line">            Log.i(<span class="string">"xx"</span>,<span class="string">"list==="</span>+it)<span class="comment">//打印：[haha,heihei]</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> let </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取手机屏幕的密度]]></title>
      <url>/2018/04/24/%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AF%86%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>目前有两种方式，一种是根据手机的分辨率计算，另外一种是通过代码获取。</p>
<h1 id="第一种：根据手机分辨率进行计算-计算得出实际的dpi"><a href="#第一种：根据手机分辨率进行计算-计算得出实际的dpi" class="headerlink" title="第一种：根据手机分辨率进行计算(计算得出实际的dpi)"></a>第一种：根据手机分辨率进行计算(计算得出实际的dpi)</h1><p>比如我的手机魅族分辨率是：1920*1080，屏幕尺寸大小是：5.5寸的，那么计算：<br>(宽的平方+高的平方之后开根号，最后除以屏幕的尺寸)<br>dpi  = (√1920^2+1080^2 ) / 5.5 ≈ 401</p>
<p>参照下图：</p>
<pre><code>ldpi（低）~120dpi density=0.75
mdpi（中）~160dpi density=1
hdpi（高）~240dpi density=1.5
xhdpi（超高）~320dpi density=2
xxhdpi（超超高）~480dpi density=3
xxxhdpi（超超超高）~640dpi density=4
</code></pre><p>对应图片的目录应该是：xxhdpi</p>
<h1 id="第二种：通过代码方式-系统定义的dpi"><a href="#第二种：通过代码方式-系统定义的dpi" class="headerlink" title="第二种：通过代码方式(系统定义的dpi)"></a>第二种：通过代码方式(系统定义的dpi)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line"><span class="keyword">float</span> ydpi = getResources().getDisplayMetrics().ydpi;</span><br></pre></td></tr></table></figure>
<p>不同手机获取的<code>xdpi ydpi</code> 值有的一模一样，有的有些差异，但是相差不会太大，两者获取的值近乎一样。</p>
<p>两者计算出的结果并不完全相同，因为你们想，实际计算得出的<code>dpi</code> 很容易根据屏幕尺寸的不同，得出不同的<code>dpi</code> ，这样的话得到的值很多，无法适配。我查阅网上相关介绍，就是每个手机初始有一个固定的<code>dpi</code> ，分别是上述的：120，160，240，320，480，640，安卓实际进行缩放的时候按照的是系统定义的这些，而不是实际计算得出的<code>dpi</code>,这一点需要注意。</p>
]]></content>
      
        
        <tags>
            
            <tag> dpi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EventBus 为什么订阅的方法必须是public？]]></title>
      <url>/2018/04/08/EventBus-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A2%E9%98%85%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E6%98%AFpublic%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在看了源码之后发现是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities </span></span><br><span class="line">            <span class="comment">//获取所有声明的方法</span></span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//获取方法的标识符</span></span><br><span class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">            <span class="comment">//方法的标识符必须是public </span></span><br><span class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">              <span class="comment">//否则抛出异常 ，说这个方法必须加上@Subscribe ,并且是public 的，不能是静态的，抽象的</span></span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后就没有然后了，之前怀疑<code>private</code> 修饰的方法，反射后不能被其他类调用，后来查了相关资料，发现可以，后来去网上寻找无果，后来在我微信关注的公众号里，群主伯特说：虽然可以反射调用<code>private</code> 的方法，但是必须通过<code>setAccess</code>来修改访问权限。说是修改，实则破坏了<code>java</code>中的作用域，迫不得已不推荐这么做。<code>EventBus</code> 作为三方库，显然不会在你设置为<code>private</code> 时，好心办坏事，强制访问。</p>
<p>仅此而已，仅此而已。分享给还不知道的童鞋。</p>
]]></content>
      
        
        <tags>
            
            <tag> EventBus </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity状态保存与恢复]]></title>
      <url>/2018/03/23/Activity%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      <content type="html"></content>
      
        
        <tags>
            
            <tag> Activity状态保存与恢复 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[四大组件是什么与它们的生命周期（及Fragment）]]></title>
      <url>/2018/03/22/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%8F%8AFragment%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>首先当我们一开始学习安卓的时候想必就是四大组件了以及它们的生命周期，现在就来复习回想下。</p>
</blockquote>
<p>四大组件有：<code>Activity</code>, <code>ContentProvider</code>, <code>BroadcastReceiver</code>, <code>Service</code></p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><blockquote>
<p>提供与用户交互的界面或者可以说是一个窗口</p>
</blockquote>
<p>下面我是从官方文档中关于<code>Activity生命周期</code> 的一张图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1948557-eea2764dbf62c03a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lifetcycle.jpg"></p>
<p>正常启动时：<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code>    </p>
<ul>
<li><p>而后我们看到当 <code>Another activity comes into the foreground</code> 执行 <code>onPause()</code> 方法<br>当按 <code>home</code> 键的时候： 当前<code>Activity</code> 已经不可见了，所以执行：<code>onPause() -&gt; onStop()</code>    </p>
</li>
<li><p>当重新回到<code>app</code>时，分为两种情况就是：①是app还在后台，执行：<code>onRestart() -&gt; onStart() -&gt; onResume()</code>; ②是app被系统杀死了，则执行：<code>onCreate() -&gt; onStart() &gt; onResume()</code>    </p>
</li>
<li><p>当在<code>app</code> 里 从 <code>A -&gt; B</code> 此时<code>A隐藏，B显示</code>，当重新返回<code>A</code> 时，执行：<code>onPause() -&gt; onResume()</code>,这种应用场景一般是比如需要返回做刷新操作的，可以将刷新方法写在<code>onResume()</code> 方法中执行。</p>
</li>
<li><p>最后当退出应用程序的时候执行 <code>onDestroy()</code></p>
</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><blockquote>
<p>服务，有前台服务和后台服务，一般提供需在后台长期运行的服务，例如：音乐播放器等</p>
</blockquote>
<p>它的生命周期如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-cf5c1a9d2dddaaca.png" alt="lifetcycle.jpg"></p>
<p>因为启动服务的方法有两个：<code>startService() 和 bindService()</code> 两者的生命周期略有不同。    </p>
<ul>
<li><p>首先来看：<code>startService()</code> 方式<br>启动：<code>onCreate() -&gt; onStartCommand()</code> 调用<code>stopServcie()</code> 停止服务，随后执行 <code>onDestroy()</code>    </p>
</li>
<li><p>其次是：<code>bindService()</code> 方式<br>启动：<code>onCreate() -&gt; onBind()</code> 服务启动起来了，调用<code>unbindService()</code> 停止服务，随后执行 <code>onUnbind() -&gt; onDestroy()</code></p>
</li>
</ul>
<h1 id="Broadcastreceiver"><a href="#Broadcastreceiver" class="headerlink" title="Broadcastreceiver"></a>Broadcastreceiver</h1><blockquote>
<p>广播，可以接受来自应用内或者应用外的广播，分为两个角色：广播发送者，广播接收者</p>
</blockquote>
<ul>
<li>广播的注册方式有两种：一种是代码注册，一种是清单文件注册，代码注册的优先级要比清单文件注册的优先级要高；</li>
<li>广播的发送可以是有序广播也可以是无序广播，有序广播接收到广播的顺序按照优先级的顺序；</li>
<li>注意广播接收器<code>onReceive()</code> 方法运行在 <code>UI</code> 线程中，不可以做耗时操作，否则会导致<code>ANR</code>异常；</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><blockquote>
<p>内容提供者，应用内数据共享</p>
</blockquote>
<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><blockquote>
<p>一般和 <code>viewpager</code> 配合使用，不能单独使用，要配合<code>Activity</code>使用，但是有自己的生命周期</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160420203710750" alt="fragment"></p>
<p>一般在<code>onAttach()</code>中获取参数值一些，<code>onCreateView()</code>中创建布局，布局加载完成后在<code>onActivityCreated()</code>中执行一些初始化操作，随后<code>onStart(),onResume().onPause(),onStop(),</code> fragment 销毁，<code>onDestroyView() -&gt; onDestroy() -&gt;onDetach()</code></p>
]]></content>
      
        
        <tags>
            
            <tag> 生命周期 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android知识点总结]]></title>
      <url>/2018/03/22/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>网上别人列出一些来，我把它拿过来了，需要自己一项一项复习查阅，以后有会继续添加新的，特此总结。</p>
</blockquote>
<ul>
<li><p><a href="/2018/03/22/四大组件是什么与它们的生命周期（及Fragment）">四大组件是什么与它们的生命周期（及Fragment）</a>;</p>
</li>
<li><p><a href="/2018/01/09/Activity启动模式">Acitivty的四种启动模式与特点</a>。</p>
</li>
<li><p><a href="/2018/04/24/获取手机屏幕的密度">获取手机屏幕的密度</a></p>
</li>
<li><p>Activity状态保存与恢复。</p>
</li>
<li><p>Service的生命周期，启动方法，有什么区别。</p>
</li>
<li><p>service和activity怎么进行数据交互。</p>
</li>
<li><p>怎么保证service不被杀死。</p>
</li>
<li><p>广播使用的方式和场景以及广播的几种分类。</p>
</li>
<li><p>Intent的使用方法，可以传递哪些数据类型。</p>
</li>
<li><p>ContentProvider使用方法。</p>
</li>
<li><p>ContentProvider、ContentResolver、ContentObserver 之间的关系。</p>
</li>
<li><p>Thread、AsycTask、IntentService的使用场景与特点。</p>
</li>
<li><p>FrameLayout 、 LinearLayout 、 RelativeLayout 各自特点及绘制效率对比。</p>
</li>
<li><p>Android的数据存储形式。</p>
</li>
<li><p>Android两种序列化的区别和作用。</p>
</li>
<li><p>Sqlite的基本操作。</p>
</li>
<li><p>Android中的MVC、MVP模式。</p>
</li>
<li><p>Merge、ViewStub的作用。</p>
</li>
<li><p>动画有哪几类，各有什么特点？</p>
</li>
<li><p>Handler、Loop消息队列模型，各部分的作用。</p>
</li>
<li><p>Android的消息机制，子线程更新UI的方法和原理。</p>
</li>
<li><p>Android怎么加速启动Activity。</p>
</li>
<li><p>App的启动过程。</p>
</li>
<li><p>Android优化方法。</p>
</li>
<li><p>如何防止内存泄漏？</p>
</li>
<li><p>Android中弱引用与软引用的应用场景。</p>
</li>
<li><p>Bitmap的四种属性，如何加载大图（inJustDecodeBounds）。</p>
</li>
<li><p>View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。</p>
</li>
<li><p>View刷新机制和绘制流程。</p>
</li>
<li><p>Activity、Window、View的联系和理解。</p>
</li>
<li><p>invalidate和requestLayout的区别及使用。</p>
</li>
<li><p>Touch事件分发机制和冲突处理。</p>
</li>
<li><p>Android IPC:Binder原理。</p>
</li>
<li><p>Android5.0（UI库）、6.0（权限）、7.0特性、8.0特性。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android知识点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin 传递数据]]></title>
      <url>/2018/03/14/Kotlin-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天在掘金看到使用 <code>Kotlin</code> 高阶函数传递<code>Intent</code> 数据很简洁，觉着可以试试，并应用到项目中去，自己再加以理解，记录笔记，方便查阅。掘金原文章地址：<a href="https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0TuDlsfBtO7wP9TwI8CeJw</a></p>
</blockquote>
<p>传统的<code>Intent</code> 数据传递我就不介绍了，只介绍<code>Kotlin</code>实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标 假设叫`KTestActivity4`  定义   </span></span><br><span class="line">object IntentOptions&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> val MSG_KEY = <span class="string">"key for message"</span></span><br><span class="line"></span><br><span class="line">        var Intent.message: String?</span><br><span class="line">            get() = getStringExtra(MSG_KEY)</span><br><span class="line">            set(message) &#123;</span><br><span class="line">                putExtra(MSG_KEY,message)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//跳转时 </span></span><br><span class="line">with(KTestActivity4.IntentOptions)&#123;</span><br><span class="line">            intent = Intent(<span class="keyword">this</span><span class="meta">@KTestActivity</span>5,KTestActivity4::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">            <span class="title">intent</span>.<span class="title">message</span> </span>= <span class="string">"I am KTestActivity5"</span></span><br><span class="line">             startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">with(IntentOptions)&#123;</span><br><span class="line">            var message= intent.message</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="meta">@KTestActivity</span>4,<span class="string">"显示信息："</span>+message,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>假设有多个数据传递：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">object IntentOptions&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> val MSG_KEY = <span class="string">"key for message"</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> val MSG_ID = <span class="string">"ID for message"</span></span><br><span class="line"></span><br><span class="line">        var Intent.message: String?</span><br><span class="line">            get() = getStringExtra(MSG_KEY)</span><br><span class="line">            set(message) &#123;</span><br><span class="line">                putExtra(MSG_KEY,message)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 再多增加一条即可</span></span><br><span class="line">          var Intent.id: String?</span><br><span class="line">              get() = getStringExtra(MSG_ID)</span><br><span class="line">              set(id) &#123;</span><br><span class="line">                putExtra(MSG_ID,id)</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 传递时</span></span><br><span class="line">with(KTestActivity4.IntentOptions)&#123;</span><br><span class="line">            intent = Intent(<span class="keyword">this</span><span class="meta">@KTestActivity</span>5,KTestActivity4::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">            <span class="title">intent</span>.<span class="title">message</span> </span>= <span class="string">"I am KTestActivity5"</span></span><br><span class="line">             intent.id = <span class="string">"I am id"</span></span><br><span class="line">             startActivity(intent)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>还有另外一种传递方式：委托机制，不是特别明白。国外大神封装的<code>github</code>地址：<a href="https://github.com/Takhion/android-extras-delegates">https://github.com/Takhion/android-extras-delegates</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Kotlin#Intent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里巴巴Android开发手册]]></title>
      <url>/2018/03/13/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Android%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<blockquote>
<p>摘自阿里巴巴Android开发手册</p>
</blockquote>
<h1 id="强制要求的"><a href="#强制要求的" class="headerlink" title="强制要求的"></a>强制要求的</h1><ul>
<li><strong>1.</strong> Activity 间的数据通信，对于数据量比较大的，避免使用 <code>intent + Parcelable</code> 的方式，可以考虑 <code>EventBus</code>等替代方案，以免造成 <code>TransationTooLargeException</code></li>
<li><strong>2.</strong> <code>Activity</code> 间通过隐士 <code>Intent</code>的跳转，在发出 <code>Intent</code> 之前必须通过 <code>resolveActivity</code> 检查，避免找不到合适的调用组件，造成 <code>ActivityNotFoundException</code> 的异常。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">viewUrl</span><span class="params">(String url, String mimeType)</span> </span>&#123;</span><br><span class="line"> Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">	intent.setDataAndType(Uri.parse(url), mimeType);</span><br><span class="line">	<span class="keyword">if</span> (getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_</span><br><span class="line">ONLY) != <span class="keyword">null</span>) &#123;</span><br><span class="line"> startActivity(intent);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 找不到指定的 Activity</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>而不应该：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"com.example.DemoIntent "</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> startActivity(intent);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ActivityNotFoundException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>3.</strong> 避免在<code>Service#onStartCommand/onBind()</code>方法中执行耗时操作，如果确实有需求，应采用<code>IntentService</code> 或采用其他异步机制完成。<br>正例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"> setContentView(R.layout.main);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startIntentService</span><span class="params">(View source)</span> </span>&#123;</span><br><span class="line"> Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService.class);</span><br><span class="line"> startService(intent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">......</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>4.</strong> 避免在 <code>BroadcastReceive#onReceive()</code>中执行耗时操作，如果有耗时工作，应该创建 <code>IntentService</code>完成，而不应该在<code>BroadcastReceiver</code> 内创建子线程去做。    </p>
</li>
</ul>
<p>说明：<br>由于该方法是在主线程执行，如果执行耗时操作会导致 <code>UI</code> 不流畅，可以使用 <code>IntentService</code>,创建 <code>HanlderThread</code> 或者调用 <code>Context#registerReceiver(BroadcastReceiver,IntentFitter,String,Handler)</code> 方法等方式，在其他 <code>Worker</code> 线程执行 <code>onReceive</code>.<code>BroadcastReceiver#onReceive()</code> 方法耗时超过10秒钟，可能会被系统杀死。<br>正例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(LOGIN_SUCCESS);</span><br><span class="line"><span class="keyword">this</span>.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"> Intent userHomeIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"> userHomeIntent.setClass(<span class="keyword">this</span>, UserHomeService.class);</span><br><span class="line"> <span class="keyword">this</span>.startService(userHomeIntent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mBroadcastReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"> MyDatabaseHelper myDB = <span class="keyword">new</span> MyDatabaseHelper(context);</span><br><span class="line"> myDB.initData();</span><br><span class="line"> <span class="comment">// have more database operation here</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>5.</strong> 避免使用隐士 <code>Intent</code> 广播敏感信息，信息可能被其他注册了对应 <code>BroadcastReceiver</code> 的App接收。</li>
</ul>
<p>说明：<br>通过<code>Context#sendBroadcast()</code>发送的隐士广播会被感兴趣的 <code>receiver</code> 接收，恶意应用注册监听该广播的 <code>receiver</code>可能会获取到 <code>Intent</code> 中传递的敏感信息，并进行其他危险操作。如果发送的广播为使用 <code>Context#sendOrderedBroadcast()</code>方法发送的有序广播，优先级较高的恶意 <code>receiver</code>可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。</p>
<p>如果广播仅限于应用内，则可以是iyong<code>LocalBroadcastManager#sendBroadcast()</code>实现，避免敏感信息外泄和intent拦截的风险。</p>
<p>正例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"my-sensitive-event"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"event"</span>, <span class="string">"this is a test event"</span>);</span><br><span class="line">LocalBroadcastManager.getInstance(<span class="keyword">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>
<p>反例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">v1.setAction(<span class="string">"com.sample.action.server_running"</span>);</span><br><span class="line">v1.putExtra(<span class="string">"local_ip"</span>, v0.h);</span><br><span class="line">v1.putExtra(<span class="string">"port"</span>, v0.i);</span><br><span class="line">v1.putExtra(<span class="string">"code"</span>, v0.g);</span><br><span class="line">v1.putExtra(<span class="string">"connected"</span>, v0.s);</span><br><span class="line">v1.putExtra(<span class="string">"pwd_predefined"</span>, v0.r);</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(v0.t)) &#123;</span><br><span class="line"> v1.putExtra(<span class="string">"connected_usr"</span>, v0.t);</span><br><span class="line">&#125;</span><br><span class="line">context.sendBroadcast(v1);</span><br></pre></td></tr></table></figure></p>
<p>以上广播可能被其他应用的如下 <code>receiver</code> 接收导致敏感信息泄露：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.getAction() != <span class="keyword">null</span>) &#123;</span><br><span class="line"> String s = intent.getAction();</span><br><span class="line"> <span class="keyword">if</span> (s.equals(<span class="string">"com.sample.action.server_running"</span>) &#123;</span><br><span class="line"> String ip = intent.getStringExtra(<span class="string">"local_ip"</span>);</span><br><span class="line"> String pwd = intent.getStringExtra(<span class="string">"code"</span>);</span><br><span class="line"> String port = intent.getIntExtra(<span class="string">"port"</span>, <span class="number">8888</span>);</span><br><span class="line"> <span class="keyword">boolean</span> status = intent.getBooleanExtra(<span class="string">"connected"</span>, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 阿里巴巴Android开发手册规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[监听键盘显示与隐藏]]></title>
      <url>/2018/03/08/%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>项目中有时候需要监听<code>keyboard</code>的显示与隐藏，特此备注，方便使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyboardWatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener;</span><br><span class="line">    <span class="keyword">private</span> View rootView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> viewSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isShowing = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> OnKeyboardListener onKeyboardListener;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyboardWatcher</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        rootView = activity.getWindow().getDecorView().getRootView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyboardWatcher <span class="title">register</span><span class="params">(OnKeyboardListener listener)</span></span>&#123;</span><br><span class="line">        onKeyboardListener = listener;</span><br><span class="line">        <span class="keyword">if</span>(onGlobalLayoutListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            onGlobalLayoutListener = <span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Rect r = <span class="keyword">new</span> Rect();</span><br><span class="line">                    rootView.getWindowVisibleDisplayFrame(r);</span><br><span class="line">                    <span class="keyword">int</span> viewHeight = r.bottom - r.top;</span><br><span class="line">                    <span class="keyword">if</span>(viewSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        viewSize = viewHeight;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(viewHeight != viewSize)&#123;</span><br><span class="line">                        <span class="comment">// 大于100dp才算变化</span></span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(viewHeight - viewSize) &gt; dpToPx(rootView.getContext(),<span class="number">100</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (viewHeight &lt; viewSize &amp;&amp; !isShowing) &#123;</span><br><span class="line">                                onKeyboardListener.onShow(viewHeight);</span><br><span class="line">                                isShowing = <span class="keyword">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isShowing)&#123;</span><br><span class="line">                                onKeyboardListener.onHide();</span><br><span class="line">                                isShowing = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        viewSize = viewHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rootView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                viewSize = rootView.getHeight();</span><br><span class="line">                rootView.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rootView.getViewTreeObserver().removeGlobalOnLayoutListener(onGlobalLayoutListener);</span><br><span class="line">        rootView = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnKeyboardListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onShow</span><span class="params">(<span class="keyword">int</span> viewSize)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onHide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dpToPx</span><span class="params">(Context context,<span class="keyword">int</span> dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) TypedValue.applyDimension(</span><br><span class="line">                TypedValue.COMPLEX_UNIT_DIP, dp, context.getResources().getDisplayMetrics()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KeyBoardWatcher keyboardWatcher = <span class="keyword">new</span>  KeyboardWatcher()</span><br><span class="line">keyboardWatcher.register(<span class="keyword">this</span>)<span class="comment">//实现KeyboardWatcher.OnKeyboardListener接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法onShow() , onHide(),对应键盘的显示与隐藏</span></span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> keyboard </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment 懒加载]]></title>
      <url>/2018/02/28/Fragment-%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<blockquote>
<p>因为项目中经常用到tabLayout + viewpager 结合使用，页面切换时要用到延迟加载的情况，所以单独写出一个demo，方便查看和便于使用</p>
</blockquote>
<h1 id="1-首先新建一个BaseLazyFragment"><a href="#1-首先新建一个BaseLazyFragment" class="headerlink" title="1.首先新建一个BaseLazyFragment"></a>1.首先新建一个<code>BaseLazyFragment</code></h1><pre><code>/**
 * Created by xuqianqian on 2018/2/28.
 */
public  abstract class BaseLazyFragment extends Fragment {

    protected View mRootView;
    public Context mContext;
    protected boolean isVisible;
    private boolean isPrepared;
    private boolean isLoad = false;

    //最先执行
    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
        if (getUserVisibleHint()) {//当前显示
            isVisible = true;
            if(!isLoad){
                lazyLoad();
            }
        } else {
            isVisible = false;
            //onInvisible();
        }
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mContext = getActivity();
        setHasOptionsMenu(true);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        if (mRootView == null) {
            mRootView = getLayout();
        }
        return mRootView;
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        isPrepared = true;
        //如果已经加载过了，就无需再重新加载
        if(!isLoad){
            lazyLoad();
        }
    }

    /**
     * 懒加载
     */
    protected void lazyLoad() {
        if (!isPrepared || !isVisible) {
            return;
        }
        isLoad = true;
        initData();
    }

//    protected void onInvisible() {
//
//    }
    //初始化布局View
    public abstract View getLayout();

    public abstract void initData();
}
</code></pre><h1 id="2-让你的fragment-extend-BaseLazyFragment"><a href="#2-让你的fragment-extend-BaseLazyFragment" class="headerlink" title="2.让你的fragment extend BaseLazyFragment"></a>2.让你的<code>fragment extend BaseLazyFragment</code></h1><pre><code>public class GankFragment extends BaseLazyFragment {

String type;
public static GankFragment newInstance(String type) {
    GankFragment gankFragment = new GankFragment();
    Bundle bundle = new Bundle();
    bundle.putString(&quot;type&quot;, type);
    gankFragment.setArguments(bundle);
    return gankFragment;
}
//加载布局
@Override
public View getLayout() {

    type = getArguments().getString(&quot;type&quot;);
    TextView tv = new TextView(getActivity());
    tv.setText(type);
    tv.setGravity(Gravity.CENTER);
    return tv;
}

@Override
public void initData() {

    //初始化一些控件，加载网络数据
}

}
</code></pre><h1 id="3-剩下的就是FragmentPagerAdapter了"><a href="#3-剩下的就是FragmentPagerAdapter了" class="headerlink" title="3.剩下的就是FragmentPagerAdapter了"></a>3.剩下的就是FragmentPagerAdapter了</h1><pre><code>public class TitleAdapter extends FragmentPagerAdapter {

private List&lt;Fragment&gt; fragments;

private List&lt;String&gt; types;

public TitleAdapter(FragmentManager fm, List&lt;Fragment&gt; fragments, List&lt;String&gt; types) {
    super(fm);
    this.fragments = fragments;
    this.types = types;
}

@Override
public Fragment getItem(int position) {
    return fragments.get(position);
}

@Override
public int getCount() {
    return fragments.size();
}

@Override
public CharSequence getPageTitle(int position) {
    return types.get(position);
}
}
</code></pre><p><code>MainActivity.java</code></p>
<pre><code>private List&lt;String&gt; titles = new ArrayList&lt;&gt;();

private List&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;();
TitleAdapter titleAdapter;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    TabLayout tablayout = findViewById(R.id.tablayout);
    ViewPager viewpager = findViewById(R.id.viewpager);

    titles.add(&quot;android&quot;);
    titles.add(&quot;ios&quot;);
    titles.add(&quot;web&quot;);
    titles.add(&quot;java&quot;);

    fragments.add(GankFragment.newInstance(&quot;android&quot;));
    fragments.add(GankFragment.newInstance(&quot;ios&quot;));
    fragments.add(GankFragment.newInstance(&quot;web&quot;));
    fragments.add(GankFragment.newInstance(&quot;java&quot;));

    titleAdapter = new TitleAdapter(getSupportFragmentManager(), fragments, titles);
    viewpager.setAdapter(titleAdapter);
    tablayout.setTabMode(TabLayout.MODE_FIXED);
    tablayout.setupWithViewPager(viewpager);
}
</code></pre><p><a href="https://github.com/QQabby/LazyFragmentApplication" title="源码地址">https://github.com/QQabby/LazyFragmentApplication</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 懒加载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dialog]]></title>
      <url>/2018/02/28/Dialog/</url>
      <content type="html"><![CDATA[<h1 id="快速初始化materialDialog"><a href="#快速初始化materialDialog" class="headerlink" title="快速初始化materialDialog"></a>快速初始化materialDialog</h1><pre><code>new MaterialDialog.Builder(mContext)
                    .title(&quot;title&quot;)
                    .content(&quot;I&apos;m a content&quot;)
                    .negativeText(&quot;cancel&quot;)
                    .negativeColorRes(R.color.colorNegative)
                    .positiveText(&quot;ok&quot;)
                    .positiveColorRes(R.color.colorPositive)
                    .onPositive(new     MaterialDialog.SingleButtonCallback() {
                            @Override
                            public void onClick(@NonNull MaterialDialog     dialog, @NonNull DialogAction which) {
                            showMsg(&quot;click dialog ok&quot;);
                            ...
                    }
                })
                .show();
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> materialDialog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序速查笔记]]></title>
      <url>/2018/01/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这个微信小程序也出来好长时间了，一直想做一个属于自己的小程序，这不说动手就动手实现一个吧，比较简易，中间也遇到不少问题，记录一下，方便以后自己查阅。</p>
</blockquote>
<h1 id="微信小程序的结构"><a href="#微信小程序的结构" class="headerlink" title="微信小程序的结构"></a>微信小程序的结构</h1><p><img src="http://upload-images.jianshu.io/upload_images/1948557-4007311aabb448cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<p>默认没有这么些文件夹的，只有<code>index</code> ，然后这个标识 <code>app</code> 开头的文件都是一些全局的设置。可以自己查看下，都有注释，就从这个配置开始说。</p>
<h1 id="修改启动页面"><a href="#修改启动页面" class="headerlink" title="修改启动页面"></a>修改启动页面</h1><p>默认启动页面是<code>index</code>页面，如果要修改，打开<code>app.json</code>配置文件，在顶部你会发现有一个<code>pages</code>的配置，如下：</p>
<pre><code>&quot;pages&quot;: [

&quot;pages/home/home&quot;
</code></pre><p>只需要将我们的想要显示的页面的路径写在 <strong>第一个</strong> 就可以成为启动页，特别注意路径一定要正确。</p>
<p>当然你会新建很多页面，所有的页面都必须写在这个里面，不然跳转的时候会找不到。</p>
<h1 id="底部tab栏切换"><a href="#底部tab栏切换" class="headerlink" title="底部tab栏切换"></a>底部tab栏切换</h1><p>就是底部<code>tab</code>栏切换,同样还是在<code>app.json</code> 配置文件中修改如下：</p>
<pre><code>  &quot;tabBar&quot;: {
  &quot;color&quot;: &quot;#333333&quot;,
  &quot;selectedColor&quot;: &quot;#2B91D8&quot;,
  &quot;backgroundColor&quot;: &quot;#eee&quot;,
  &quot;borderStyle&quot;: &quot;white&quot;,
      &quot;list&quot;: [
    {
  &quot;pagePath&quot;: &quot;pages/home/home&quot;,
  &quot;text&quot;: &quot;首页&quot;,
  &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_home_nor.png&quot;,
  &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_home_pre.png&quot;
    },
    {
  &quot;pagePath&quot;: &quot;pages/myCenter/myCenter&quot;,
  &quot;text&quot;: &quot;我的&quot;,
  &quot;iconPath&quot;: &quot;pages/home/images/tab_icon_center_nor.png&quot;,
  &quot;selectedIconPath&quot;: &quot;pages/home/images/tab_icon_center_pre.png&quot;
    }
  ]
},
</code></pre><p>这里的 <code>pagePath</code> 就是页面的路径，<code>text</code>文字，<code>iconPath</code>图标，注意图片一定要带后缀，<code>selectedIconPath</code>点击态的图标，各自换成你自己的就行，问题不会太大。</p>
<h1 id="加载中"><a href="#加载中" class="headerlink" title="加载中"></a>加载中</h1><p>如下：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-8f82d095641d4734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p>
<p>有标签可以直接显示这个,在<code>wxml</code>文件中编写：</p>
<pre><code>&lt;loading hidden=&quot;{{hidden}}&quot; bindchange=&quot;loadingChange&quot;&gt;  
       加载中...  
&lt;/loading&gt;  
</code></pre><p>   <code></code> 可以控制显示还是隐藏，在<code>.js</code>文件中可以控制：</p>
<pre><code>data: {
    hidden: false,
  }
</code></pre><p> 可以在<code>data</code> 底下配置默认值，<code>hidden: false</code> 默认不显示，赋值的时候必须在这里面写：</p>
<pre><code>that.setData({
    hidden: true
  })
</code></pre><h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><pre><code> wx.request({
//网络请求地址url
url: &apos;https://xx&apos;,
header: {
  // &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;
  &apos;content-type&apos;: &apos;application/json&apos;
  // &apos;content-type&apos;: &apos;text/xml&apos;
},
//请求头参数配置
data: {
  page: pageNo,
  timestamp: timeStamps

},
method: &quot;POST&quot;,

success: function (res) {

  //xmlstring2json  是我使用第三方xml转json的一个库
  var xml2json = require(&apos;..//lib/xmlstring2json/dist/xml2json&apos;);
  var json = JSON.stringify(xml2json(res.data), null, 4);


  var jsonObject = xml2json(res.data);
  var jokeObject = jsonObject.root.joke
  //timestamp
  if(pageNo == 0){
    timeStamps = jsonObject.root.timestamp.text
  }


 // console.log(&apos;json::&apos; + jsonObject.root.timestamp.text)
  // var data = new Array();
  // for (var i = 0; i &lt; jokeObject.length;i++){
  //   var text = JSON.stringify(jokeObject[i].text).replace(&quot;#&quot;, &quot;&quot;)
  //   //JSON.parse(text).text
  //   var value = JSON.parse(text).text;
  //   data.push(value)
  // }
  // console.log(&apos;data::：&apos; + jokeObject[0].text.text );

  // var l =  jokeObject;
  var l;
  if(pageNo == 0){
    l = jokeObject

  }else{
    var l = that.data.list;
    for (var i = 0; i &lt; jokeObject.length; i++) {
      l.push(jokeObject[i])
    } 
  }
    //页面绑定的数据赋值
  that.setData({
    list: l
  })

  pageNo++

  that.setData({
    hidden: true
  })
},
fail : function(s){
  wx.showModal({
    title: &apos;提示&apos;,
    content: &apos;请求接口失败&apos; + JSON.stringify(s)
  })
}
</code></pre><p>要进行网络请求，首先测试阶段可以将开发工具里的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948557-8bed851f43caa7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后一个选项勾选上，不校验…,同时管理员还需在后台配置网络请求的域名，两个缺一不可。</p>
]]></content>
      
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何给TextView上的drawable上的图片添加动画？]]></title>
      <url>/2018/01/24/%E5%A6%82%E4%BD%95%E7%BB%99TextView%E4%B8%8A%E7%9A%84drawableEnd%E7%AD%89%E4%B8%8A%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>可能你遇到过这样的场景，就是在 <code>xml</code> 里，给<code>TextView</code>添加了一个<code>drawableLeft</code>或者<code>drawableRight</code>等，你想给这个图片添加一个动画，然而你会发现当你给这个<code>TextView</code>加动画吧并不是我们想要的，我们只想要那个图片做动画，文字不需要做任何动画，目前可以有两种做法。</p>
<h1 id="第一种做法"><a href="#第一种做法" class="headerlink" title="第一种做法"></a>第一种做法</h1><blockquote>
<p>也是比较通俗的方法，说这个<code>drawable 单独弄成ImageView</code>不就好了，在<code>xml</code>里新增一个<code>ImageView</code> 是吧，干嘛非要加在一个标签里面，要相信布局都是很强大的，肯定可以实现效果。</p>
</blockquote>
<h1 id="第二种做法"><a href="#第二种做法" class="headerlink" title="第二种做法"></a>第二种做法</h1><blockquote>
<p>你说真的没办法，必须写在一个里面，也是有办法的，那就不能在<code>xml</code>里设置<code>drawableLeft</code>了，代码设置，如下：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable d = (AnimationDrawable) getResources().getDrawable(R.drawable.animation_draw);  </span><br><span class="line">d.setBounds(0,0,d.getIntrinsicWidth(),d.getIntrinsicHeight());</span><br><span class="line"> messageText.setCompoundDrawables(d, null, null, null);</span><br></pre></td></tr></table></figure>
<p>这个具体的动画在这个<code>animation_draw</code>里，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">                android:oneshot=&quot;false&quot;</span><br><span class="line">       &gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/ic_launcher&quot;</span><br><span class="line">           android:duration=&quot;500&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个帧动画，里面可以放很多的<code>item</code>,从而形成动画,碰到了这种情况记录下，方便以后查阅。</p>
]]></content>
      
        
        <tags>
            
            <tag> add animation to drawable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android O 新特性 AutoSizing]]></title>
      <url>/2018/01/16/Android-O-%E6%96%B0%E7%89%B9%E6%80%A7-AutoSizing/</url>
      <content type="html"><![CDATA[<h1 id="自动调整TextView的大小的使用autoSizing"><a href="#自动调整TextView的大小的使用autoSizing" class="headerlink" title="自动调整TextView的大小的使用autoSizing"></a>自动调整TextView的大小的使用autoSizing</h1><blockquote>
<p>Android 8.0允许根据TextView的大小自动设置文本展开或收缩的大小,这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。</p>
</blockquote>
<p>在之前看 <a href="https://juejin.im/post/5a56f70cf265da3e5468fa59" target="_blank" rel="noopener">文字太多？控件太小？试试 TextView 的新特性 Autosizing 吧！</a> 作者写到关于这个属性的所有用法，在这里我就不多说什么了，用法其实挺简单，关键是我在用的时候遇到了一些小问题，导致一直出不来。</p>
<p><a href="https://developer.android.com/guide/topics/ui/look-and-feel/autosizing-textview.html" target="_blank" rel="noopener">官方文档</a> 点击即可查看，可以看别人讲解的同时也可自行查阅文档，双方对比着看，感觉会好一点。</p>
<p>如下图可以简单明了的说明该特性：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fe2fd1fa4e936?w=469&amp;h=713&amp;f=gif&amp;s=764107" alt=""></p>
<p>具体最简单的使用有两种：</p>
<h1 id="1-一种就是api-gt-api-26的可以直接在xml里面该属性："><a href="#1-一种就是api-gt-api-26的可以直接在xml里面该属性：" class="headerlink" title="1.一种就是api &gt;= api 26的可以直接在xml里面该属性："></a>1.一种就是api &gt;= api 26的可以直接在xml里面该属性：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:autoSizeTextType=&quot;uniform&quot; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此需要注意的是：使用这个<code>autoSizeTextType</code>的时候，控件的<code>layout_width</code> <code>layout_height</code> 不能使用这个<code>wrap_content</code>否则看不出什么效果，要使用具体可衡量的。这个也不难理解，因为它要计算，你设置一个模糊的宽和高，就算不出来了。</p>
</blockquote>
<h1 id="2-api-lt-26-的低设备-的兼容写法"><a href="#2-api-lt-26-的低设备-的兼容写法" class="headerlink" title="2. api&lt;26 的低设备 的兼容写法"></a>2. api&lt;26 的低设备 的兼容写法</h1><blockquote>
<p>官方文档里也明确说明了兼容低版本<code>The library provides support to Android 4.0 (API level 14) and higher.</code> 也就是兼容到4.0以上，写法有些不同，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;TextView</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;200dp&quot;</span><br><span class="line">      tools:ignore=&quot;MissingPrefix&quot;</span><br><span class="line">      app:autoSizeTextType=&quot;uniform&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这个<code>app</code>是这个<code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code> 我们在自定义控件的时候经常遇到它，<code>tools</code>是这个<code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code> 当然以上写法都支持动态编码，具体可查阅文档</p>
<h1 id="敲黑板重点"><a href="#敲黑板重点" class="headerlink" title="敲黑板重点"></a>敲黑板重点</h1><p>你会发现你写完之后编译是报错的，错误类似是这样的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/16/160fe486f97e25be?w=888&amp;h=158&amp;f=png&amp;s=18247" alt=""></p>
<p>找不到！！！</p>
<p>在写那篇文章作者的帮助下，发现首先要兼容低版本，<code>module</code> 的 <code>build.gradle</code> 文件添加依赖时候 就是这个<code>com.android.support:appcompat-v7:xx</code> 后面的版本号要26以上，你看看你自己项目里有哪个版本你就写上哪个，还要在<code>project</code> 的 <code>build.gradle</code> 文件里添加：<br><code>maven{
            url &#39;https://maven.google.com&#39;
        }</code>添加到对应的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        //添加如下内容</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &apos;https://maven.google.com&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此我发现我的项目终于不报错了，可以运行起来并进行下一步的实践操作了，大家如果在项目中也遇到这样的问题，按我那样改应该没啥问题了，顺便把我写的代码上传到<code>github</code> 上了，又需要的可以下载看看：<br><a href="&quot;https://github.com/QQabby/AutoSizingDemo&quot;">demo</a></p>
<p>另外在查看 <code>Android O</code>新特性中发现一个比较好玩的东西：现在，<code>findViewById()</code> 函数的全部实例均返回 <t extends="" view=""> T，而不是 View。以后就可以这么写啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EditText et =  findViewById(R.id.et);</span><br></pre></td></tr></table></figure></t></p>
<p>就是那样，无需强转了，当然了使用了<code>Kotlin</code>的话就忽略吧，因为<code>Kotlin</code>连<code>findViewById</code>也不用写，哈哈。更多好玩特性可查看 <a href="https://developer.android.com/about/versions/oreo/android-8.0.html#fvbi-signature" target="_blank" rel="noopener">文档</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Android O </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修改自动生成get/set方法模板代码]]></title>
      <url>/2018/01/11/%E4%BF%AE%E6%94%B9%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90get-set%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今天看到<br><a href="https://juejin.im/post/5a55c8896fb9a01caf374e93" target="_blank">面对接口脏数据你还在V层if str==null else setText?</a><br> 一文，觉着写得挺好，开发过程中多思考多动手，会带来意想不到的效果。底下评论大家也都说了各自的方法和见解，文中有一些问题作者后来也解决了，看到评论里有人说：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b35580365?w=658&amp;h=389&amp;f=png&amp;s=25367" alt="image.png"></p>
<p>说到配置as,就可以实现在创建bean时自动生成<code>return xx==null?&quot;&quot;:xx;</code> 觉着很好，因为我觉着这是一种挺简单的方法，但是就如同底下人问了怎么配置呀，我也不知道，于是我就在自己<code>as</code>工具里新建了一个bean对象，按住<code>alt+insert</code>添加<code>get/set</code>方法，发现了解决办法。如下图：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b3568a2be?w=389&amp;h=636&amp;f=png&amp;s=16071" alt="image.png"></p>
<p>平时手快也没注意，今天仔细看了看，那上面的意思不就是，<code>get</code> 方法模块，<code>set</code>方法模板吗，后面跟着 <code>IntelliJ Default</code>大概就是默认的生成模板吧，点击后面的三个点<br>按钮进去看看，如下：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b531389d1?w=787&amp;h=609&amp;f=png&amp;s=47221" alt="image.png"></p>
<p>这是<code>set</code>的，<code>get</code>方法也类似是这样的，大概也能看懂，想着是不是可以直接模板就好了，发现无法修改，后来又发现左上角的<code>+</code>号，原来是自己可以新建一个模板，然后再生成的时候选择自己的模板就好了，如我们在<code>get</code>模板中新建一个自己的模板：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b3c7e8344?w=431&amp;h=149&amp;f=png&amp;s=7606" alt="image.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b357e2825?w=262&amp;h=269&amp;f=png&amp;s=4331" alt="image.png"></p>
<p>我们知道我们只需要改一下最后<code>get</code>方法<code>return</code>那个地方的代码，也就是这儿：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b38fb2a31?w=1240&amp;h=679&amp;f=png&amp;s=129573" alt="image.png"></p>
<p>不确定是不是，我们可以在后面跟着一个“#”号试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">  return $field.name+&quot;#&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在生成的时候选择我们自定义的模板：<br><img src="https://user-gold-cdn.xitu.io/2018/1/11/160e3c7b56ef9685?w=394&amp;h=643&amp;f=png&amp;s=17595" alt="image.png"></p>
<p>发现最后生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getAge() &#123;</span><br><span class="line">    return age + &quot;#&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(String age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样证明确定是这样的，那么我么可以继续进行真正的判断了：<br>我们先把这个默认里的<code>get</code>方法代码拷贝到 <code>MyGetter</code>中，我们再根据我们自己的需要修改模板代码,其它地方不变，就修改需要修改的地方：<br>我们想要实现这样的：<code>return xx==null?&quot;&quot;:xx</code>,Ok ，那么我认为大概是这么写的，首先判断是否是字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">	#if(field.String)&#123;</span><br><span class="line">		return $field.name == null ? &quot;&quot; : $field.name;</span><br><span class="line">	&#125;</span><br><span class="line">	#else</span><br><span class="line">		return $field.name;</span><br><span class="line">	#end </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们对比一个<code>default</code>的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;() &#123;</span><br><span class="line">  return $field.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，我们再继续生成一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getAge() &#123;</span><br><span class="line">        return age == null ? &quot;&quot; : age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(String age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，达成效果，耶，居然还可以这么玩，以后可根据自己需求自行修改，谢谢大家。</p>
]]></content>
      
        
        <tags>
            
            <tag> get/set.template </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity启动模式]]></title>
      <url>/2018/01/09/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>  ● standard 标准模式<br>​    简述：对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。<br>例如：A启动A，A再接着启动A,A再接着启动A,，然后再分别出栈，如图所示：<br>​<br><img src="http://upload-images.jianshu.io/upload_images/1948557-bf56470a07ad09ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>  ● singleTop<br>简述：当活动的启动模式指定为 singleTop ,在启动活动时如果发现返回栈的栈顶已经<br>是该活动，则认为可以直接使用它，不会再创建新的活动实例。<br>例如：如果快速点击一个按钮，进入Activity，要保证启动的Activity不为多个，可以使用<br>将Activity的启动模式改为 singleTop，就不会启动多个了。如图所示：<br>​<br><img src="http://upload-images.jianshu.io/upload_images/1948557-d5f43b4894e1a4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>  ● singleTask<br>简述：当活动的启动模式指定为singleTask，每次启动该活动时候，它会先在系统中查找属性值taskaffinity等于它的属性值taskAffinity的任务存在；如果存在这样的任务，他就会这个任务中启动，否则就会在新任务中启动。因此，如果我们想要设置了“singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</p>
<p>如果设置了“singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在在相应的Activity实例，如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity实例会位于任务的堆栈顶端中。</p>
<p>每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948557-9133171e9085b6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">                             </p>
<blockquote>
<p>当栈底部的 <code>A</code> 重新被启动打开时，会执行<code>onNewIntent()</code>  <code>onStart()</code> 方法。</p>
</blockquote>
<p>使用场景：应用主页面一般是 <code>singleTask</code> </p>
<p>  ● singleInstance（单独任务栈）<br>简述：使用singleInstance 模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都会共用同一个返回栈，也就解决了共享活动实例的问题。<br>​<br><img src="http://upload-images.jianshu.io/upload_images/1948557-358424952cd1bed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>返回的页面顺序是：C-B-A</p>
]]></content>
      
        
        <tags>
            
            <tag> launchMode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AIDL实例]]></title>
      <url>/2018/01/08/AIDL%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>说到进程间通信，一般首先就会想到<code>AIDL</code>，也看了很多文章，做下笔记，记录一下，方便以后查阅。</p>
</blockquote>
<p>对于  <code>AIDL</code> 我是这样理解的，首先进程间是无法通信的，那要通信就得有一个媒介或者说两个进程有统一对外的接口可以相互识别，从这个 <code>AIDL</code>全程的名字<code>Android Interface Definition Language</code> (android 接口定义语言) 来看不难看出它就是我们进程间通信的媒介，它可以实现我们想要的通信。</p>
<p>在翻阅网上各类文章的讲解后，我认为一个比较好的实例可以更好理解这个东西，具体如下：</p>
<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>我们新创建两个<code>module</code>，代表我们两个进程，进程名称默认就是我们程序的包名：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-2622b4af0ef4f45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p>
<h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>我们先编写<code>service</code>这个<code>module</code>里的代码，先定义一个  <code>Person</code>的一个<code>bean</code>对象，记住一定要<code>implements Parcelable</code> 接口，大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-2be1461f1e8c1cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        mName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\nPerson&#123;"</span> +</span><br><span class="line">                <span class="string">"mName='"</span> + mName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们再新建一个文件夹：<code>aidl</code>,新建一个包名和<code>Person</code>类一模一样的包名和与之对应的<code>aidl</code>,还有一个我们对外提供获取<code>person</code>集合的一个<code>aidl</code>:<br><img src="http://upload-images.jianshu.io/upload_images/1948557-44cd8f26c62f570f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br> 在<code>Person.aidl</code>里，我们序列化我们<code>java</code>里的 <code>Person</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还要和声明的实体类在一个包里，同时注意不要新建aidl文件，因为你会发现，新建不了，</span></span><br><span class="line"><span class="comment">//提示你名称唯一，此时你新建一个file,名字为Person.aidl就可以，需要特别注意下</span></span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure>
<p><code>IMyAidl.aidl</code> 文件提供对外方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// IMyAidl.aidl</span><br><span class="line">package com.example.service.bean;</span><br><span class="line">//特别注意一定要手动导包，不会自动导包</span><br><span class="line">import com.example.service.bean.Person;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">//可以理解为通信媒介</span><br><span class="line">interface IMyAidl &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">         * 除了基本数据类型，其他类型的参数都需要标上方向类型：in(输入), out(输出), inout(输入输出)</span><br><span class="line">         */</span><br><span class="line">        void addPerson(in Person person);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; getPersonList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在我们的<code>java文件</code>里，新建一个<code>MyAidlService</code>,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAidlService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String  TAG = <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Person&gt; mPersons;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建生成本地的binder ,实现AIDL的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mIBinder = <span class="keyword">new</span> IMyAidl.Stub()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mPersons.add(person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mPersons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端与服务端绑定时的回调，返回IBinder对象后客户端就可以通过它远程调用服务端的方法，即实现了通讯</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        mPersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> mIBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后别忘了在清单文件中注册<code>MyAidlService</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">            android:name=<span class="string">"com.example.service.MyAidlService"</span></span><br><span class="line">            android:enabled=<span class="string">"true"</span></span><br><span class="line">            android:exported=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>到此，我们完成了<code>service</code>端的工作：</p>
<h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>将我们刚才创建好的<code>aidl</code>文件夹拷贝到 <code>app</code> <code>module</code>下<code>main</code>文件夹下，在<code>MainActivity</code>中绑定服务，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.service"</span>,<span class="string">"com.example.service.MyAidlService"</span>));</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure></p>
<p>其中这个<code>mConnection</code>可以让我们拿到<code>IMyAidl</code>对象的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;</span><br><span class="line"></span><br><span class="line">            mAidl = IMyAidl.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName componentName) &#123;</span><br><span class="line">            mAidl = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过返回的<code>IBinder</code> 拿到这个<code>IMyAidl</code>，此时我们就可以通信了，例如我们调用<code>IMyAidl</code>中的<code>addPerso</code>n方法，再调用<code>getPersonList</code>看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       Person person = <span class="keyword">new</span> Person(<span class="string">"qian"</span>+random.nextInt(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           mAidl.addPerson(person);</span><br><span class="line">           List&lt;Person&gt; mPersons = mAidl.getPersonList();</span><br><span class="line"></span><br><span class="line">           tvName.setText(mPersons.toString());</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>打印发现list 返回了我们添加的<code>Person</code>，完成了<code>app</code>与<code>service</code>两个进程间的通信。<br><code>demo</code>地址：<a href="https://github.com/QQabby/AIDLDemo">https://github.com/QQabby/AIDLDemo</a></p>
]]></content>
      
        
        <tags>
            
            <tag> AIDL实例 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写文件相关]]></title>
      <url>/2017/12/28/%E5%86%99%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="向sd卡根目录中写入文件"><a href="#向sd卡根目录中写入文件" class="headerlink" title="向sd卡根目录中写入文件"></a>向sd卡根目录中写入文件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先判断是否存在sd卡</span></span><br><span class="line"><span class="keyword">if</span>(Environment.getExternalStorageState().equals(</span><br><span class="line">                Environment.MEDIA_MOUNTED))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取外部设备</span></span><br><span class="line">    File file=<span class="keyword">new</span> File(Environment.getExternalStorageDirectory(),<span class="string">"qianqian.txt"</span>);</span><br><span class="line">    FileOutputStream outStream=<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">     <span class="comment">//写入文件</span></span><br><span class="line">    outStream.write(content.getBytes());</span><br><span class="line">    outStream.close();  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="读取assets下的文件路径"><a href="#读取assets下的文件路径" class="headerlink" title="读取assets下的文件路径"></a>读取assets下的文件路径</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式如下</span></span><br><span class="line">file:<span class="comment">///android_asset/myVideo.html</span></span><br><span class="line">file:<span class="comment">///android_asset/xx(文件名称)</span></span><br></pre></td></tr></table></figure>
<h1 id="读取assets下的文件转化为String"><a href="#读取assets下的文件转化为String" class="headerlink" title="读取assets下的文件转化为String"></a>读取assets下的文件转化为String</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFromAssets</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStreamReader inputReader = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    getResources().getAssets().open(fileName));</span><br><span class="line">            BufferedReader bufReader = <span class="keyword">new</span> BufferedReader(inputReader);</span><br><span class="line">            String line = <span class="string">""</span>;</span><br><span class="line">            String Result = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufReader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">                Result += line;</span><br><span class="line">            <span class="keyword">return</span> Result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 向sd卡写入文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LRU算法还一知半解？]]></title>
      <url>/2017/12/19/lru/</url>
      <content type="html"><![CDATA[<blockquote>
<p>某年某月某日，糖葫芦同学在掘金app上看了几篇文章，偶然看到了一篇熟悉的词LRU算法，脑海里就想这不是经常说的嘛，就那么回事，当天晚上睡觉，LRU算法是啥来着，好像是什么最近最少使用的，白天在地铁上看的文章也不少，但是到晚上想想好像啥也没记住，就记得LRU算法，我发现人大多数是这样的啊，对于自己熟悉的部分呢还能记着点，不熟悉或者不会的可能真的是看过就忘啊~既然这样还不如先把熟悉的弄明白。</p>
</blockquote>
<p><strong>第二天来到公司，我觉着还是有必要看一下这个LRU的源码，到底是怎么回事，嗯，糖葫芦同学刷刷得看，下面我们将进入正题，请戴眼镜的同学把眼镜擦一擦，哈哈哈</strong></p>
<h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><p>先看源码，再用具体的demo加以验证，我们先看一下这个LruCache这个类的大致结构和方法，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-45d318e41e5b213e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这又是 get(K)，put(K,V), remove(K) 的方法的 给人的感觉就像是一个Map的集合嘛，又有Key ，又有value 的，再看下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Size of this cache in units. Not necessarily the number of elements. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> createCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> evictionCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hitCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> missCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize for caches that do not override &#123;<span class="doctag">@link</span> #sizeOf&#125;, this is</span></span><br><span class="line"><span class="comment">     *     the maximum number of entries in the cache. For all other caches,</span></span><br><span class="line"><span class="comment">     *     this is the maximum sum of the sizes of the entries in this cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到开头，我们就明白了，哦原来这个LruCache类中维护一个LinkedHashMap的一个集合，缓存我们这个对象，而且构造方法里需要我们传入一个<code>maxSize</code>的一个值，根据上面的注释我们就明白了这个就是我们LruCache缓存对象的最大数目。</p>
<h1 id="有什么用呢？"><a href="#有什么用呢？" class="headerlink" title="有什么用呢？"></a>有什么用呢？</h1><p>根据惯性思维，我们可以认为，在<code>put</code>新的缓存对象的时候，根据我们设定的最大值<code>remove</code>集合里的某些缓存对象，进而添加新的缓存对象。</p>
<h1 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h1><p>根据我们的分析，我们有必要去看一下这个<code>put</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Caches &#123;<span class="doctag">@code</span> value&#125; for &#123;<span class="doctag">@code</span> key&#125;. The value is moved to the head of</span></span><br><span class="line"><span class="comment"> * the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value mapped by &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码量也不是特别多，我们看下这个，在这个<code>synchronized</code>同步代码块里，我们看到这个 <code>size</code>,是对put进来缓存对象个数的累加，然后调用集合的<code>map.put</code>方法，返回一个对象 <code>previous</code> ，就是判断这个集合中是否添加了这个缓存对象，如果不为null,就对<code>size</code>减回去。</p>
<p>最后又调用一个 <code>trimToSize(maxSize)</code>方法，上面都是对添加一些逻辑的处理，那么不可能无限制添加啊，肯定有移除操作，那么我们推测这个逻辑可能在这个<code>trimToSize(maxSize)</code> 里处理。</p>
<p>源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove the eldest entries until the total of remaining entries is at or</span></span><br><span class="line"><span class="comment">     * below the requested size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span></span><br><span class="line"><span class="comment">     *            to evict even 0-sized elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                            + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//只要当前size&lt;= maxSize 就结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取这个对象，然后从map中移除掉，保证size&lt;=maxSize</span></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注释：<code>Remove the eldest entries until the total of remaining entries is at or below the requested size</code> 大概意思是说：清除时间最久的对象直到剩余缓存对象的大小小于设置的大小。没错是我们想找的。</p>
<p><strong>这里说明一下：maxSize就是我们在构造方法里传入的，自己设置的</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样LruCache的核心方法 <code>trimToSize</code>方法我们就说完了，接下来我将通过实例再次验证下：</p>
<h1 id="设置场景"><a href="#设置场景" class="headerlink" title="设置场景"></a>设置场景</h1><blockquote>
<p>假设我们设置maxSize 为2，布局里显示3个imageView,分别代表3张我们要显示的图片，我们添加3张图片，看看会不会显示3张？</p>
</blockquote>
<p>xml布局显示如下（代码就不贴了，很简单）：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-18f522db17aec271?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>activity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_lru);</span><br><span class="line"></span><br><span class="line">        ImageView iv1 = (ImageView) findViewById(R.id.iv1);</span><br><span class="line">        ImageView iv2 = (ImageView) findViewById(R.id.iv2);</span><br><span class="line">        ImageView iv3 = (ImageView) findViewById(R.id.iv3);</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),R.drawable.bg);</span><br><span class="line">        Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(),R.drawable.header_img);</span><br><span class="line">        Bitmap bitmap3 = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);</span><br><span class="line"></span><br><span class="line">        LruCache&lt;String,Bitmap&gt; lruCache = <span class="keyword">new</span> LruCache&lt;&gt;(MAX_SIZE);</span><br><span class="line">        lruCache.put(<span class="string">"1"</span>,bitmap1);</span><br><span class="line">        lruCache.put(<span class="string">"2"</span>,bitmap2);</span><br><span class="line">        lruCache.put(<span class="string">"3"</span>,bitmap3);</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = lruCache.get(<span class="string">"1"</span>);</span><br><span class="line">        iv1.setImageBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">        Bitmap b2 = lruCache.get(<span class="string">"2"</span>);</span><br><span class="line">        iv2.setImageBitmap(b2);</span><br><span class="line"></span><br><span class="line">        Bitmap b3 = lruCache.get(<span class="string">"3"</span>);</span><br><span class="line">        iv3.setImageBitmap(b3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-fd26e11dddac2ae8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bg.png"><img src="http://upload-images.jianshu.io/upload_images/1948557-2aa9e1e0c1e34387?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="header_img.png"><img src="http://upload-images.jianshu.io/upload_images/1948557-8d33912205bfd6e8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ic_launcher.png"></p>
<p>我们可以先尝试分析一下：因为我们设置的MaxSize 是2 ，那么在put第三个Bitmap的时候，在<code>trimToSize</code>方法中，发现这个size是3 ，maxSize 是2，会继续向下执行,不会break,结合下面代码看下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                            + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次循环：此时 size 是3，maxSize 是 2</span></span><br><span class="line">                <span class="comment">//第二次循环，此时 size 是 2 ，maxSize 是 2 ，满足条件，break,结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//获取最先添加的第一个元素</span></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">              <span class="comment">//移除掉第一个缓存对象</span></span><br><span class="line">                map.remove(key);</span><br><span class="line">              <span class="comment">// size = 2,减去移除的元素</span></span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>safeSizeOf</code> 是调用<code>sizeOf</code>方法。</p>
<p>那么也就是说，我们在<code>put</code>第三个<code>bitmap</code>的时候，<code>LruCache</code> 会自动帮我们移除掉第一个缓存对象，因为第一个最先添加进去，时间也最长，当然后添加的<code>bitmap</code>就是新的，最近的，那么我们推断这个<code>iv1</code>是显示不出图片的，因为被移除掉了，其它剩余两个可以显示，分析就到这里，看下运行结果是不是跟我们分析的一样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1948557-abc32df8ceb0fda9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result.png"></p>
<p>哇！真的跟我们想的一样耶，证明我们想的是对的。这里我们思考一下就是为什么<code>LruCache</code>使用了这个<code>LinkedHashMap</code>,为什么<code>LinkedHashMap</code>的创造方法跟我们平时创建的不太一样，源码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里说一下在掘金发布的评论里 <code>藏地情人</code>评论是：<code>new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true)</code>这句代码表示，初始容量为零，<code>0.75</code>是加载因子，表示容量达到最大容量的<code>75%</code>的时候会把内存增加一半。最后这个参数至关重要。表示访问元素的排序方式，<code>true</code>表示按照访问顺序排序，<code>false</code>表示按照插入的顺序排序。这个设置为<code>true</code>的时候，如果对一个元素进行了操作<code>(put、get)</code>，就会把那个元素放到集合的最后。</p>
</blockquote>
<p>确实也是这样的，我们看下<code>LinkedHashMap</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>里面这个<code>assessOrder</code> 注释里也说的很明白：<code>the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for
access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</code> -&gt; <code>true</code> 呢就表示会排序，<code>false</code> 就代表按照插入的顺序。<br>默认不传就是 <code>false</code>  ,而且我们每次  <code>get(K) put(K,V)</code> 的时候 会根据这个变量调整元素在集合里的位置。而这么做的目的也只有一个：保留最近使用的缓存对象，举个例子说明一下：</p>
<p>   我们向这个集合里添加了三种元素</p>
<pre><code>LruCache&lt;String, Bitmap&gt; lruCache = new LruCache&lt;&gt;(MAX_SIZE);(MAX_SIZE=2)
lruCache.put(&quot;1&quot;, bitmap1);
lruCache.put(&quot;2&quot;, bitmap2);
lruCache.put(&quot;3&quot;, bitmap3);
</code></pre><p>   此时它们在集合里的顺序是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-336a0efa4167a370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="order.png"></p>
<p>那比如说我们在<code>put</code> 3 元素之前，使用了1元素，就是调用了<code>get(&quot;1&quot;)</code>方法，我们知道LinkedHashMap就会改变链表里元素的存储顺序，代码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lruCache.put(<span class="string">"1"</span>, bitmap1);</span><br><span class="line">lruCache.put(<span class="string">"2"</span>, bitmap2);</span><br><span class="line">lruCache.get(<span class="string">"1"</span>);</span><br><span class="line">lruCache.put(<span class="string">"3"</span>, bitmap3);</span><br></pre></td></tr></table></figure></p>
<pre><code>那么此时对应链表里的顺序就是：
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1948557-dea6180979615101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p>
<p>当我们再调用显示的时候，循环遍历就会优先把第一个位置的<code>key = &quot;2&quot;</code> 的缓存对象移除掉，保证了最近使用的原则，当然了因为把这个<code>max_size = 2</code>所以在我们执行<code>lruCache.put(&quot;3&quot;, bitmap3);</code> 时，集合最终会变成这样：<br><img src="http://upload-images.jianshu.io/upload_images/1948557-334107b8260732f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="result.png"></p>
<p>集合里只剩下 <code>1 ,3</code>对应的缓存对象。</p>
<p>至此，LruCache就说完了，如果看完的你有不明白的地方可以留言，一起讨论下~</p>
]]></content>
      
        
        <tags>
            
            <tag> Lru </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/11/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
